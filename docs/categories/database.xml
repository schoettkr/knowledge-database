<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knowledge Database (Posts about database)</title><link>https://schoettkr.github.io/knowledge-database/</link><description></description><atom:link href="https://schoettkr.github.io/knowledge-database/categories/database.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:schoettkr@gmail.com"&gt;schoettkr&lt;/a&gt; </copyright><lastBuildDate>Mon, 28 Jan 2019 13:12:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Database Essentials - Lecture 07</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-07/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
This lecture is the third part of the Introduction to SQL that we began in lecture 5.
&lt;/p&gt;

&lt;div id="outline-container-orgfe997ce" class="outline-2"&gt;
&lt;h2 id="orgfe997ce"&gt;Introduction to SQL&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfe997ce"&gt;
&lt;p&gt;
What we'll cover here:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Data Manipulation
&lt;ul class="org-ul"&gt;
&lt;li&gt;create, update, delete data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Data Definition
&lt;ul class="org-ul"&gt;
&lt;li&gt;data integrity rules / constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Relational Views (Relationale Sichten)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb59887f" class="outline-3"&gt;
&lt;h3 id="orgb59887f"&gt;Data Manipulation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb59887f"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org263257a" class="outline-4"&gt;
&lt;h4 id="org263257a"&gt;Create Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org263257a"&gt;
&lt;p&gt;
With the command &lt;code&gt;insert&lt;/code&gt; tuples can be added to tables. There are different syntactical variants.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;p&gt;
&lt;b&gt;insert a complete data set&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;insert into &amp;lt;tablename&amp;gt; values (&amp;lt;value list for attributes in accordance to schema&amp;gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg to add to the faculty table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert into Faculty values ('Computer Science', 'Street of Nations 62, 09107 Chemnitz', 14568)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;adress&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;td class="org-left"&gt;Street of Nations 62, 09107 Chemnitz'&lt;/td&gt;
&lt;td class="org-right"&gt;14568&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;note that values for all attributes have been provided and that they were in correct order&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
&lt;b&gt;insert an incomplete data set&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;insert into &amp;lt;tablename&amp;gt; (&amp;lt;attribute list&amp;gt;) values (&amp;lt;value list for attributes in attribute list&amp;gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eg to add the math faculty without knowledge of the address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert into Faculty (name, persNr) values ('Mathematics', 91876)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;adress&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;td class="org-left"&gt;Street of Nations 62, 09107 Chemnitz'&lt;/td&gt;
&lt;td class="org-right"&gt;14568&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Mathematics&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;i&gt;null&lt;/i&gt;&lt;/td&gt;
&lt;td class="org-right"&gt;91876&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;note that only the values for the attributes provided in the attribute list are added and that the other attributes are filled with &lt;i&gt;null&lt;/i&gt; (resp null values)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;insert a query result&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;insert into &amp;lt;tablename&amp;gt; &amp;lt;select statement&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;results of a select statements can be inserted into a table when the domains of attributes are compatible&lt;/li&gt;
&lt;li&gt;for example &lt;img src="https://schoettkr.github.io/knowledge-database/images/add-tuple.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org267f898" class="outline-4"&gt;
&lt;h4 id="org267f898"&gt;Delete Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org267f898"&gt;
&lt;p&gt;
With the command &lt;code&gt;delete&lt;/code&gt; tuples that fulfill certain criteria/conditions may be deleted from tables. The syntax is &lt;code&gt;delete from &amp;lt;tablename&amp;gt; where &amp;lt;condition&amp;gt;&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
For example
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Personal&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="k"&gt;alter&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;67&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
has the following result in this table
&lt;img src="https://schoettkr.github.io/knowledge-database/images/delete-tuple.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc8953c1" class="outline-4"&gt;
&lt;h4 id="orgc8953c1"&gt;Update/Change Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc8953c1"&gt;
&lt;p&gt;
With the command &lt;code&gt;update&lt;/code&gt; attributtes of all tuples in a table can be changed in the same way. The syntax is &lt;code&gt;update &amp;lt;tablename&amp;gt; set &amp;lt;attribute1&amp;gt; = &amp;lt;expression1&amp;gt;, &amp;lt;attribute2&amp;gt; = &amp;lt;expression2&amp;gt;, ...&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
For example
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt; &lt;span class="n"&gt;Personal&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;gehalt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gehalt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
has the following result in this table
&lt;img src="https://schoettkr.github.io/knowledge-database/images/update-attributes-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
It is also possible to provide conditions to &lt;code&gt;update&lt;/code&gt;. Then the syntax stays the same but gets an &lt;code&gt;where&lt;/code&gt; statement added onto it: &lt;code&gt;update &amp;lt;tablename&amp;gt; set &amp;lt;attribute1&amp;gt; = &amp;lt;expression1&amp;gt;, &amp;lt;attribute2&amp;gt; = &amp;lt;expression2&amp;gt;, ... where &amp;lt;condition&amp;gt;&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
For example to merge department 3 into department 2
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt; &lt;span class="n"&gt;Personal&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;Abteilung&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;Abteilung&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
has the following result in this table
&lt;img src="https://schoettkr.github.io/knowledge-database/images/update-attributes-2.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f5500e" class="outline-4"&gt;
&lt;h4 id="org1f5500e"&gt;Procedure of Changes&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1f5500e"&gt;
&lt;p&gt;
Basically there are two steps when changing data:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;creation of a temporary relation with the candidates that are due to be changed&lt;/li&gt;
&lt;li&gt;execution of the change operation
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;insert&lt;/code&gt; → insertion of the temporary table in the target table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt; → change of the attributes initially in the temporary table (based on comparisons with the values in the original table) and then adoption into the target/original table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt; → mark the tuples that shall be deleted an deletion in one step&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Why this effort you may ask? Well conditions may include subqueries which would else operate on data/tables that are already modified (partially)!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3db5edd" class="outline-3"&gt;
&lt;h3 id="org3db5edd"&gt;Data Definition&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3db5edd"&gt;
&lt;p&gt;
We now look at the Data Definition Language (DDL) which is mainly used to define database structure and the rules for accessing the data.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6b6e561" class="outline-4"&gt;
&lt;h4 id="org6b6e561"&gt;Table Management&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6b6e561"&gt;
&lt;p&gt;
To create a new table use the command &lt;code&gt;create table {TABLENAME} ( {ATTRIBUTE_DEFINITION_1}, {ATTRIBUTE_DEFINITION_2}, ... )&lt;/code&gt;. To alter the schema of a table after its creation use &lt;code&gt;alter table {TABLENAME} add column ({ATTRIBUTE_DEFINITION})&lt;/code&gt; to add an attribute, &lt;code&gt;alter table {TABLENAME} alter column ({ATTRIBUTE_DEFINITION})&lt;/code&gt; to modify an attribute and &lt;code&gt;alter table {TABLENAME} drop column {ATTRIBUTE_NAME}&lt;/code&gt; to delete an attribute. If you want to delete a whole table issue the command &lt;code&gt;drop table {TABLENAME}&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Now to define an attribute you need to provide a data type for that specific attribute.
&lt;/p&gt;

&lt;p&gt;
Here are the data types SQL supports by default with some examples:
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org1195b6b"&gt;&lt;/a&gt;Boolean&lt;br&gt;
&lt;div class="outline-text-6" id="text-org1195b6b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when null values are allowed then &lt;code&gt;unknown&lt;/code&gt; is also supported as the null value&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;boolean values can be compared and are assignable
&lt;ul class="org-ul"&gt;
&lt;li&gt;they compare as &lt;code&gt;true &amp;gt; false&lt;/code&gt; and in every comparison where the null value or &lt;code&gt;unknown&lt;/code&gt; is an operand (is involved) the result will be &lt;code&gt;unknown&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org98b872b"&gt;&lt;/a&gt;Strings/Characters&lt;br&gt;
&lt;div class="outline-text-6" id="text-org98b872b"&gt;
&lt;p&gt;
The number of allowed characters (max length) is usually defined as well when specifying such attribute type. If the number/amount/count is omitted then usually 1 is the predefined max length of the character string. Character strings can be defined in the following ways:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;character ({AMOUNT})&lt;/code&gt; or &lt;code&gt;char ({AMOUNT}&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in this case the character string &lt;i&gt;always&lt;/i&gt; has the &lt;i&gt;exact&lt;/i&gt; length of {AMOUNT}&lt;/li&gt;
&lt;li&gt;when strings are assigned that are shorter than {AMOUNT} the string is padded by whitespaces on the right hand side&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;character varying ({AMOUNT})&lt;/code&gt; or &lt;code&gt;varchar ({AMOUNT}&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in this case the character string has a &lt;i&gt;maximum&lt;/i&gt; length of {AMOUNT}&lt;/li&gt;
&lt;li&gt;shorter strings therefore need less space (internally)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org9aa28be"&gt;&lt;/a&gt;Numericals (exact)&lt;br&gt;
&lt;div class="outline-text-6" id="text-org9aa28be"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;are used for &lt;i&gt;exact&lt;/i&gt; representations of numbers&lt;/li&gt;
&lt;li&gt;the precision of a number is specified by providing the the amount of digits to be hold
&lt;ul class="org-ul"&gt;
&lt;li&gt;and for decimal numbers the amount of decimal places can be specified as well&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numeric [{PRECISION}[, {DECIMAL_PLACES}]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;without specification the amount of decimal places is always 0 and the precision depends on the specific precision&lt;/li&gt;
&lt;li&gt;there are also some predefined variants without decimal places eg &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt; the concrete specification of those depends on the implementation as well&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numeric(7,2)&lt;/code&gt; represents all numbers from -99999.99 to 99999.99 with two decimal places&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org42e5d7a"&gt;&lt;/a&gt;Numericals (approximal)&lt;br&gt;
&lt;div class="outline-text-6" id="text-org42e5d7a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;are used for &lt;i&gt;approximate&lt;/i&gt; representations of floating point numbers in the common expression via significand (Mantisse, Ziffernstellen einer Gleitkommazahl vor der Potenz) and exponent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float [{PRECISION}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;{PRECISION} specifies the "size" of the significand&lt;/li&gt;
&lt;li&gt;there are also some predefined float types for example &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; of which the precision is also dependant on the specific implementation&lt;/li&gt;
&lt;li&gt;example float literals: &lt;code&gt;10E3&lt;/code&gt; or &lt;code&gt;-3.1E-6&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgdf16cba"&gt;&lt;/a&gt;Date and Time&lt;br&gt;
&lt;div class="outline-text-6" id="text-orgdf16cba"&gt;
&lt;p&gt;
There are three different data types to represent dates and times. The typical date and time components can be accessed individually:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt; represents a calendric date value and offers the components &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;day&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt; represents time values and offers the components &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; (precision is preset in seconds)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; represents time and date values at the same time (precision is preset to microseconds)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Date and time values can optionally be parameterized to set the precision explicitly and handle time zones.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org13a47f0"&gt;&lt;/a&gt;Interval&lt;br&gt;
&lt;div class="outline-text-6" id="text-org13a47f0"&gt;
&lt;p&gt;
The data type &lt;code&gt;interval&lt;/code&gt; describes a time period/range. Such range/period may for example occur as the result when subtracting date or time values. Intervals may also be added to or subtracted from date values.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;slides: Wird als zusammenhängender Teilbereich zwischen Start- und Endeinheit &lt;code&gt;(year, month, day, hour, minute, second)&lt;/code&gt; definiert&lt;/li&gt;
&lt;li&gt;slides example: &lt;code&gt;interval year to month&lt;/code&gt; covers all intervals between 0 years, 0 month and 99 years, 11 months; &lt;code&gt;interval hour to second(2)&lt;/code&gt; covers all intervals between 0 hours, 0 minutes, 0 seconds and 99 hours, 59 minutes, 59.99 seconds (the parameter &lt;code&gt;2&lt;/code&gt; specifies the precision of the seconds component)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga580cf0" class="outline-3"&gt;
&lt;h3 id="orga580cf0"&gt;Integrity Constraints/Rules/Conditions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga580cf0"&gt;
&lt;p&gt;
Data integrity contains guidelines for data retention, specifying or guaranteeing the length of time data can be retained in a particular database. To achieve data integrity, these rules are consistently and routinely applied to all data entering the system, and any relaxation of enforcement could cause errors in the data. Implementing checks on the data as close as possible to the source of input (such as human data entry), causes less erroneous data to enter the system. Strict enforcement of data integrity rules results in lower error rates, and time saved troubleshooting and tracing erroneous data and the errors it causes to algorithms.
&lt;/p&gt;

&lt;p&gt;
Data integrity also includes rules defining the relations a piece of data can have, to other pieces of data, such as a Customer record being allowed to link to purchased Products, but not to unrelated data such as Corporate Assets. Data integrity often includes checks and correction for invalid data, based on a fixed schema or a predefined set of rules. An example being textual data entered where a date-time value is required. Rules for data derivation are also applicable, specifying how a data value is derived based on algorithm, contributors and conditions. It also specifies the conditions on how the data value could be re-derived.
&lt;/p&gt;

&lt;p&gt;
Integrity constraints are a set of rules to guarantee the consistency, the correctness and the completeness of data. Integrity constrains can be defined in regards to different aspect, let's look at some possible constraints in SQL.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgceb3452" class="outline-4"&gt;
&lt;h4 id="orgceb3452"&gt;Required/obligatory Data&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgceb3452"&gt;
&lt;p&gt;
Via the keyword &lt;code&gt;not null&lt;/code&gt; it can be specified in the attribute definition when the values for an attribute are not allowed to be empty/null. The DBMS then refuses insert or change operations which include a null value for that attribute. Example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;matrNr&lt;/span&gt;     &lt;span class="nb"&gt;integer&lt;/span&gt;     &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;name&lt;/span&gt;       &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;major&lt;/span&gt;      &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaf58d0b" class="outline-4"&gt;
&lt;h4 id="orgaf58d0b"&gt;Domain Integrity&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgaf58d0b"&gt;
&lt;p&gt;
Just the specification of a data type (eg &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;varchar&lt;/code&gt;) is often times not sufficient as a criteria for the allowed values. That's why there's the possibility to perform further validation via &lt;code&gt;check ({CONDITION})&lt;/code&gt;. Similarily whole new &lt;i&gt;attribute domains&lt;/i&gt; (then usable as attribute type) can be defined via restriction of existing data types via &lt;code&gt;create domain {DOMAIN NAME} as {DATA TYPE} [check ({CONDITION})]&lt;/code&gt;, eg:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;domain&lt;/span&gt; &lt;span class="n"&gt;genderType&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nb"&gt;char&lt;/span&gt; &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'m'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'f'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Here's a more involved example. Suppose that there's a company with 3 departments where the employees are paid at least 1000$ and at max 10000$. Here's how the table creation could look like when considering those attribute constraints:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;Staff&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;name&lt;/span&gt;         &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;gender&lt;/span&gt;       &lt;span class="n"&gt;genderType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;department&lt;/span&gt;   &lt;span class="nb"&gt;integer&lt;/span&gt;  &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;department&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;salary&lt;/span&gt;       &lt;span class="nb"&gt;integer&lt;/span&gt;  &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;salary&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In short: A domain defines the possible values of an attribute. Domain Integrity rules govern these values.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org014de6f" class="outline-4"&gt;
&lt;h4 id="org014de6f"&gt;Entity Integrity&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org014de6f"&gt;
&lt;p&gt;
Entity Integrity ensures that there are no duplicate records within the table and that the field that identifies each record within the table is unique and never null.
The existence of the Primary Key is the core of the entity integrity. If you define a primary key for each entity, they follow the entity integrity rule.
Entity integrity specifies that the Primary Keys on every instance of an entity must be kept, must be unique and must have values other than NULL.
Although most relational databases do not specifically dictate that a table needs to have a Primary Key, it is good practice to design a Primary Key for each table in the relational model. This mandates no NULL content, so that every row in a table must have a value that denotes the row as a unique element of the entity.
&lt;/p&gt;

&lt;p&gt;
Entity Integrity is the mechanism the system provides to maintain primary keys. The primary key serves as a unique identifier for rows in the table. Entity Integrity ensures two properties for primary keys:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The primary key for a row is unique; it does not match the primary key of any other row in the table.&lt;/li&gt;
&lt;li&gt;The primary key is not null, no component of the primary key may be set to null.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The uniqueness property ensures that the primary key of each row uniquely identifies it - there are no duplicates. The second property ensures that the primary key has meaning, has a value - no component of the key is missing.
&lt;/p&gt;

&lt;p&gt;
The system enforces Entity Integrity by not allowing operations (INSERT, UPDATE) to produce an invalid primary key. Any operation that creates a duplicate primary key or one containing nulls is rejected.
&lt;/p&gt;

&lt;p&gt;
In SQL the entity integrity via primary keys is specified via &lt;code&gt;primary key ({ATTRIBUTE NAME}[, {ATTRIBUTE NAME}])&lt;/code&gt;. Alternative &lt;i&gt;key&lt;/i&gt; (not primary) attributes can be specified via &lt;code&gt;unique ({ATTRIBUTE NAME}[, {ATTRIBUTE NAME}])&lt;/code&gt;. Here's an example where a primary key is utilized:
&lt;/p&gt;

&lt;p&gt;
There's a university where:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the lecture numbers are three digits&lt;/li&gt;
&lt;li&gt;the matricle numbers are six digits&lt;/li&gt;
&lt;li&gt;the grades are in the range of 1.0 to 5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is how we'd create a table for the exams:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;Exam&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
 &lt;span class="n"&gt;lectureNr&lt;/span&gt; &lt;span class="nb"&gt;integer&lt;/span&gt; &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;nummer&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;999&lt;/span&gt; &lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="n"&gt;matrNr&lt;/span&gt;    &lt;span class="nb"&gt;integer&lt;/span&gt; &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;nummer&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;100000&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;999999&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="n"&gt;note&lt;/span&gt;      &lt;span class="nb"&gt;numeric&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;note&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
 &lt;span class="k"&gt;primary&lt;/span&gt; &lt;span class="k"&gt;key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lectureNr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3c67b16" class="outline-4"&gt;
&lt;h4 id="org3c67b16"&gt;Referential Integrity&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3c67b16"&gt;
&lt;p&gt;
Wiki: Referential integrity is a property of data stating that all of its references are valid. In the context of relational databases, it requires that if a value of one attribute (column) of a relation (table) references a value of another attribute (either in the same or a different relation), then the referenced value must exist.
&lt;/p&gt;

&lt;p&gt;
For referential integrity to hold in a relational database, any column in a base table that is declared a foreign key can only contain either null values or values from a parent table's primary key or a candidate key. In other words, when a foreign key value is used it must reference a valid, existing primary key in the parent table. For instance, deleting a record that contains a value referred to by a foreign key in another table would break referential integrity. 
&lt;/p&gt;

&lt;p&gt;
Techopedia: Referential integrity (RI) is a relational database concept, which states that table relationships must always be consistent. In other words, any foreign key field must agree with the primary key that is referenced by the foreign key. Thus, any primary key field changes must be applied to all foreign keys, or not at all. The same restriction also applies to foreign keys in that any updates (but not necessarily deletions) must be propagated to the primary parent key.
&lt;/p&gt;

&lt;p&gt;
Back to the lecture slides :D . Up until now we're not able to guarantee that referenced tuples of a relation really exist. Look at the following example:
We have a table of lectures
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;6123&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
where the &lt;b&gt;persNr&lt;/b&gt; is a foreign key. The related table where &lt;b&gt;persNr&lt;/b&gt; is the primary key is the table of teachers:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;persNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;6123&lt;/td&gt;
&lt;td class="org-left"&gt;Ares&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;td class="org-left"&gt;Zeus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;43424&lt;/td&gt;
&lt;td class="org-left"&gt;Hera&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Up until now the referential integrity is fulfilled. &lt;i&gt;But&lt;/i&gt; if we were to execute the following operation &lt;code&gt;insert into Lectures values (500, 'Mathematics', 7111)&lt;/code&gt; we'd violate that principle because there's no tuple in Teachers where the primary key &lt;b&gt;persNr&lt;/b&gt; is &lt;code&gt;7111&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Now to a more formal defintion of referential integrity.
Suppose we have two relations R and S. The attribute(set) K is the primary key of R and the attribute(set) FK is the foreign key from R in S. To guarantee referential integrity the following condition has always to be true: \(\pi_{FK}(S) \subseteq \pi_{K}(R)\) which means that if two relations R and S are in a key/foreign-key relationship with eath other, then every attribute value of the foreign key has to exist (set is subset or equal to) as an attribute value in the primary key attribute.
&lt;/p&gt;

&lt;p&gt;
In the example given above (before the insert command) this would look like:
\(\pi_{Lecture.persNr}(Lecture) \subseteq \pi_{Teacher.persNr}(Teacher)\) → {6897, 6123} \subseteq {6897, 6123, 43424} so the condition for referential integrity is fullfilled &amp;amp;check; . &lt;i&gt;After&lt;/i&gt; the insert command the condition would &lt;b&gt;not&lt;/b&gt; be fulfilled → {6897, 6123, 7111} \nsubseteq {6897, 6123, 43424}.
&lt;/p&gt;

&lt;p&gt;
Analogously we need to fulfill some conditions when modifying data to ensure referential integrity:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;inserting/changing a tuple s in S
&lt;ul class="org-ul"&gt;
&lt;li&gt;for the inserted/changed value &lt;b&gt;fk&lt;/b&gt; of the foreign key &lt;b&gt;FK&lt;/b&gt; of s the following must be true: 
&lt;ul class="org-ul"&gt;
&lt;li&gt;→ fk ∈ π&lt;sub&gt;K&lt;/sub&gt;(R)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;deleting a tuple r ∈ R or changing the value k of the primary key attribute K of r the following must be true for the &lt;b&gt;original&lt;/b&gt; attribute value k of the key K:
&lt;ul class="org-ul"&gt;
&lt;li&gt;→ σ{FK=k}(S) = ∅ → meaning that in S no tuple is referencing the value of the key k as a foreign key (in attribute FK)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Let's learn how to ensure RI with SQL.
&lt;/p&gt;

&lt;p&gt;
When defining our schema we mark the foreign keys with the key word &lt;code&gt;foreign key&lt;/code&gt; in the same way we mark primary keys. After doing so a &lt;code&gt;references&lt;/code&gt; clause is added which specifies the table in which the just marked foreign key is present as a primary key. 
&lt;/p&gt;

&lt;p&gt;
Values of foreign key attributes that are marked via &lt;code&gt;foreign key&lt;/code&gt; can be null, unless they're explicitly marked as &lt;code&gt;not null&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The result of this procedure is that now to change or insert a tuple, the foreign key references in that tuple need to exist. Also the deletion of tuples which are referenced elsewhere is not possible anymore.
&lt;/p&gt;

&lt;p&gt;
Here's the SQL code to create a table Exams that references the Lectures(number, title, persNr) and Students(matrNr, name, credits) tables:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;Exam&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;lectureNr&lt;/span&gt; &lt;span class="nb"&gt;integer&lt;/span&gt;      &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lectureNr&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;999&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;matrNr&lt;/span&gt;    &lt;span class="nb"&gt;integer&lt;/span&gt;      &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrNr&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;100000&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;999999&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;grade&lt;/span&gt;     &lt;span class="nb"&gt;numeric&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grade&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
					  &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
					  &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
					  &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
  &lt;span class="k"&gt;primary&lt;/span&gt; &lt;span class="k"&gt;key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lectureNr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="k"&gt;foreign&lt;/span&gt; &lt;span class="k"&gt;key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lectureNr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;references&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;foreign&lt;/span&gt; &lt;span class="k"&gt;key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrNr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="k"&gt;references&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Besides prohibiting changes that violate RI it is also possible to &lt;b&gt;propagate changes&lt;/b&gt; via &lt;b&gt;automatical cascadings&lt;/b&gt; of changing operations.
&lt;/p&gt;

&lt;p&gt;
This means that a modification of a primary key value triggers the same change of all associated foreign key values. To have this behaviour &lt;code&gt;on update cascade&lt;/code&gt; is added to the &lt;code&gt;references&lt;/code&gt; clause (eg &lt;code&gt;foreign key (matrNr) references Student on update cascade&lt;/code&gt;)). The picture below shows this behaviour:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/cascade-on-update.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
It is also possible to cascade deletions. Beware this can be dangerous, because while the referential integrity is guaranteed you may delete data by accident. Adding &lt;code&gt;on delete cascade&lt;/code&gt; to the &lt;code&gt;references&lt;/code&gt; clause causes the deletion of all tuples that have k as a foreign key when a tuple with a primary key of k is deleted. The picture below shows this behaviour:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/cascade-on-delete.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Furthermore it is possible to automatically set the values foreign key attributes that are changed to &lt;code&gt;null&lt;/code&gt; to guarantee integrity.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when a primary key value is changed, all corresponding foreign key values are set to &lt;code&gt;null&lt;/code&gt; ; to achieve this specify &lt;code&gt;on update set null&lt;/code&gt; in the &lt;code&gt;references&lt;/code&gt; clause&lt;/li&gt;
&lt;li&gt;when a tuple is deleted that has a primary key which servers as a foreign key somewhere else then the foreign key values at those places can be set to &lt;code&gt;null&lt;/code&gt; by specifying &lt;code&gt;on delete set null&lt;/code&gt; in the &lt;code&gt;references&lt;/code&gt; clause&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/cascade-set-null.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org80fcca7" class="outline-4"&gt;
&lt;h4 id="org80fcca7"&gt;Cardinality and Participation&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org80fcca7"&gt;
&lt;p&gt;
Modelling cardinality and participation is principally possible with SQL. &lt;code&gt;1:1&lt;/code&gt; relationships can be expressed via foreign key integration that is marked with &lt;code&gt;unique&lt;/code&gt; to indicate the obligatory and unique relationship. Obligatory &lt;code&gt;1:N&lt;/code&gt; relationships can also be expressed with foreign keys. To do so the foreign key on the &lt;code&gt;N&lt;/code&gt; side has to be marked with &lt;code&gt;not null&lt;/code&gt;. However not all restrictions that can be modeled are directly convertable in SQL. Foreign keys of an &lt;i&gt;optional&lt;/i&gt; participation can for example not be marked as &lt;code&gt;unique&lt;/code&gt; and hold &lt;code&gt;null&lt;/code&gt; (null because optional) at the same time. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb0dedef" class="outline-4"&gt;
&lt;h4 id="orgb0dedef"&gt;Other Constraints (Sonstiges)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb0dedef"&gt;
&lt;p&gt;
There are also &lt;i&gt;assertions&lt;/i&gt; to express more complex circumstances, which can often not be associated with only one table. Assertions are not bound to a specific table: &lt;code&gt;create assertion {AssertionName} check ({condition})&lt;/code&gt;. Be careful though. While assertions are part of the SQL 92 standard, they are however not implemented in many DBS.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2f9f5ba" class="outline-3"&gt;
&lt;h3 id="org2f9f5ba"&gt;Relational Views&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2f9f5ba"&gt;
&lt;p&gt;
Bring the three level architecture from the first lecture to your mind.
We got to know the external view as an individual user view of a part (Ausschnitt) of the conceptual view. There's a construct that supports this design principle (Darstellungsprinzip) in the relational model.
&lt;/p&gt;

&lt;p&gt;
A view in the relational model (relational view) is a &lt;b&gt;virtual relation&lt;/b&gt; which is the result of applying relational operators to one or more base relations. A base relation (in contrast to a view) is relation which directly has tuples.
&lt;/p&gt;

&lt;p&gt;
There're different kinds of views:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;horizontal: view contains subset of tuples from the base relation&lt;/li&gt;
&lt;li&gt;vertical: view contains subset of attributes from the base relation&lt;/li&gt;
&lt;li&gt;joined: view is based on more than one base relation&lt;/li&gt;
&lt;li&gt;combined: arbitrary combination of horizontal, vertical and/or joined views&lt;/li&gt;
&lt;li&gt;aggregated/grouped: view is result of aggregate functions on p.r.n(pro re nata, ggf) grouped tuple sets&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Via &lt;code&gt;create view NAME as (SELECT-STATEMENT)&lt;/code&gt; views are created and via &lt;code&gt;drop view NAME&lt;/code&gt; views are deleted in SQL.
&lt;/p&gt;

&lt;p&gt;
Here's an example use case for views. The advisors of the different majors should only be able to access the data of "their" students (major).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;view&lt;/span&gt; &lt;span class="n"&gt;MathStudents&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
    &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;
    &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;major&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Math'&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;view&lt;/span&gt; &lt;span class="n"&gt;PhilosophyStudents&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
    &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;
    &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;major&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Philosophy'&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
In the following images are two more examples
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/view-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/view-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Updating views is possible when the view:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;does not contain aggregate functions nor instructions like &lt;code&gt;having&lt;/code&gt;, &lt;code&gt;distinct&lt;/code&gt; or &lt;code&gt;group by&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;only contains distinct column names and a key of the base table in the &lt;code&gt;select&lt;/code&gt; projection list&lt;/li&gt;
&lt;li&gt;contains only one table which is naturally modifiable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;But&lt;/b&gt; even if a view is theoretically changable it is not guaranteed that SQL or the DBMS allow the modification!
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org96ecc3a"&gt;&lt;/a&gt;Advantages of Views&lt;br&gt;
&lt;div class="outline-text-5" id="text-org96ecc3a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;data independence
&lt;ul class="org-ul"&gt;
&lt;li&gt;presentation of a consistent and coherent database structure even when there are structural changes of the underlieing tables&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;powerful safety/security mechanism
&lt;ul class="org-ul"&gt;
&lt;li&gt;arbitrary database contents (tables, attributes, data sets) can be shielded from users; access can also be provided individually&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;complexity reduction
&lt;ul class="org-ul"&gt;
&lt;li&gt;complex operations can be simplified by storing there interim results (Zwischenergebnisse) into views which then can be queried via less complex queries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;flexible presentation
&lt;ul class="org-ul"&gt;
&lt;li&gt;the same data can be presented in individual ways according to needs and rights of the diffrent users&lt;/li&gt;
&lt;li&gt;this also simplifies the user interaction with the database because it is possible to only display parts that affect them&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orgb300c9a"&gt;&lt;/a&gt;Disadvantages of Views&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgb300c9a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;update capabilities
&lt;ul class="org-ul"&gt;
&lt;li&gt;tuples can only be updated/inserted/deleted under certain conditions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fixed structure
&lt;ul class="org-ul"&gt;
&lt;li&gt;the structure of a view is determined when it is defined&lt;/li&gt;
&lt;li&gt;when for example new attributes are added to a base table then these are not in the view until it is deleted and recreated&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;performance
&lt;ul class="org-ul"&gt;
&lt;li&gt;there's an overhead because a view has to be calculated/derived at each access
&lt;ul class="org-ul"&gt;
&lt;li&gt;this can matter especially for large computations (eg aggregate functions) or multiplle involved base tables&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;this may be corrected via so called &lt;i&gt;materialized views&lt;/i&gt; of which the results are stored (zwischengespeichert) but here the actuality (Aktualität) of the data has to be ensured as well&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-07/</guid><pubDate>Tue, 04 Dec 2018 23:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 06</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-06/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
In this lecture we continued the Introduction to SQL that we began in the last session.
&lt;/p&gt;

&lt;div id="outline-container-orgff295de" class="outline-2"&gt;
&lt;h2 id="orgff295de"&gt;Introduction to SQL&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgff295de"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9629e6f" class="outline-3"&gt;
&lt;h3 id="org9629e6f"&gt;Simple Queries (One Table)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9629e6f"&gt;
&lt;p&gt;
All queries to a database in SQL are realized via the &lt;code&gt;select&lt;/code&gt; statement.
This is the general construction:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; &lt;code&gt;attribute|expression&lt;/code&gt; → which attributes should the result table contain?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt; &lt;code&gt;list of tables&lt;/code&gt; → which tables are required for the query?&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;where&lt;/code&gt;  &lt;code&gt;condition&lt;/code&gt; ] → which conditions should the result tuples fulfill?&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;group by&lt;/code&gt;  &lt;code&gt;list of attributes&lt;/code&gt; ] → summarize/condense identical attribute values&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;having&lt;/code&gt;  &lt;code&gt;condition&lt;/code&gt; ] → condition in regards to grouped tables&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;order by&lt;/code&gt;  &lt;code&gt;sort&lt;/code&gt; ] → specification of sorting for the resulting table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The &lt;code&gt;where&lt;/code&gt; clause is used to refine the result set of tuples from a &lt;code&gt;select&lt;/code&gt; statement. The (basic) predicates (Basisprädikate) to &lt;code&gt;where&lt;/code&gt; can be versatile, for example
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;comparison between the value of one expression and another&lt;/li&gt;
&lt;li&gt;specify range/boundaries for a certain value&lt;/li&gt;
&lt;li&gt;is the value included in a value set&lt;/li&gt;
&lt;li&gt;is there a certain pattern in a string&lt;/li&gt;
&lt;li&gt;is the value of an attribute equal to the null value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Expressions are based on constant values and/or attribute values and can be connected via arithmetic operators (+,-,*,/,%). The predicates (Basisprädikate) can be connected via logical operators (&lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
There are also comparison operators for the fundamental datatypes which allow a value comparison (for numbers), a lexicographic comparison (for strings) and a time/date based comparison (for dates and times). The usual operators for these are =, &amp;lt;, &amp;gt; ≤, ≥, &amp;lt;&amp;gt;.
&lt;/p&gt;

&lt;p&gt;
Now lets look at some simple queries (selection σ &amp;amp; projection π). We have the following table /Lecture/s
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;6123&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
To find the name/title of the lectures held by a teacher with the personal number of 6897 we perform this query
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;persNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6897&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which yields
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Usually queries consist of at least these blocks we've just seen: &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt; and that's why they're often refered to as SFW-block (select-from-where).
&lt;/p&gt;

&lt;p&gt;
Now lets perform a query and formulate a string predicate to find out the number of the lecture 'Data Structures':
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nb"&gt;number&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Data Structures'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Which gives 
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number {PK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
As you can see string constants have to be wrapped in single quotes (in contrast to numeric values). Among other reasons this is done to distinguish the values from attribute names.
&lt;/p&gt;

&lt;p&gt;
Let's match a string pattern to find all lectures that are about databases:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;'%Database%'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;6123&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
To find the name/title of the lectures held by a teacher with the personal number of 6897 we perform this query
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;persNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6897&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which yields
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Usually queries consist of at least these blocks we've just seen: &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt; and that's why they're often refered to as SFW-block (select-from-where).
&lt;/p&gt;

&lt;p&gt;
Now lets perform a query and formulate a string predicate to find out the number of the lecture 'Data Structures':
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nb"&gt;number&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Data Structures'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Which gives 
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number {PK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
As you can see string constants have to be wrapped in single quotes (in contrast to numeric values). Among other reasons this is done to distinguish the values from attribute names.
&lt;/p&gt;

&lt;p&gt;
Let's match a string pattern to find all lectures that are about databases:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;'%Database%'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Result:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;6123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
In this query we used &lt;b&gt;wildcard characters&lt;/b&gt; (placeholder symbols) to match a certain pattern. The wildcard character for an arbitrary, single character is &lt;code&gt;_&lt;/code&gt; and for an arbitrary string it is &lt;code&gt;%&lt;/code&gt;. Beware that the keyword &lt;code&gt;like&lt;/code&gt; is required to do a pattern match (else it is just literal string match).
&lt;/p&gt;

&lt;p&gt;
So let's look at queries where we want to select tuples based on wheather or not an attribute value is contained in a set. We therefore modified our original /Lecture/s table:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;credits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
To select all lectures with 3, 5 or 10 credits
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;credits&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
A set of constants can be specified by putting them into parentheses as you can see above. To test weather a value is contained in a set we use the &lt;code&gt;in&lt;/code&gt; resp. &lt;code&gt;not in&lt;/code&gt; operator. The previous query could have been formulated via logical connection like this as well
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;credits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;credits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;credits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which is more cumbersome in this case.
&lt;/p&gt;

&lt;p&gt;
The last simple query we'll look at uses ranges/boundaries to find all tuples with at least 3 and at max 10 credits.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;credits&lt;/span&gt; &lt;span class="k"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; 
&lt;span class="c1"&gt;-- alternatively: where credits &amp;gt;= 3 and credits &amp;lt;= 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which yields the following result relation:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;credits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb9a6fd8" class="outline-3"&gt;
&lt;h3 id="orgb9a6fd8"&gt;Complex Queries (Multiple Tables)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb9a6fd8"&gt;
&lt;p&gt;
Onto some more complex queries where we query against multiple tables (cartesian product). Suppose we have the following table &lt;i&gt;Lecture&lt;/i&gt;
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
and &lt;i&gt;Hears&lt;/i&gt;
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;matrNr&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-right"&gt;123456&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-right"&gt;234876&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
and want to find out the numbers and titles of the lectures that the student with matricle number 134534 attends.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;134534&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This yields
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
As we can see in the query above we specify all the tables that are needed to resolve the query as comma seperated list after the &lt;code&gt;from&lt;/code&gt; keyword. Then the cartesian product of the tables is formed internally, that's why we have to do &lt;code&gt;where Lecture.number = Hears.number&lt;/code&gt; when selecting the tempoarily resulting rows.
&lt;/p&gt;

&lt;p&gt;
Because the temporary resulting relation holds the attribute &lt;i&gt;number&lt;/i&gt; two times (once from &lt;i&gt;Lecture&lt;/i&gt; and once from &lt;i&gt;Hears&lt;/i&gt;) we have to qualify the attribute we want to &lt;code&gt;select&lt;/code&gt; by prepending the attribute name with the table name (&lt;code&gt;select Hears.number&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
It is also possible to provide an alias to tables in the &lt;code&gt;from&lt;/code&gt; clause ala
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;134534&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
to improve readability and shorten long table names.
&lt;/p&gt;

&lt;p&gt;
When targeting the same table two or more times in one query it is &lt;b&gt;required&lt;/b&gt; to provide those aliases to distinguish between the tables:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;matrNr&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;credits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123456&lt;/td&gt;
&lt;td class="org-left"&gt;Archimedes&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;td class="org-left"&gt;Sophokles&lt;/td&gt;
&lt;td class="org-right"&gt;33&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;145698&lt;/td&gt;
&lt;td class="org-left"&gt;Cleopatra&lt;/td&gt;
&lt;td class="org-right"&gt;42&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
We want to find the name and credits of the students that have more credits than "Cleopatra":
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;credits&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Cleopatra'&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;credits&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;credits&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
↓
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;credits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Archimedes&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Back to the previous example where we wantet to find out the numbers and titles of the lectures that the student with matricle number 134534 attends, because this is a use case for theta joins (\(⋈_{\theta}\) - join one &lt;i&gt;some&lt;/i&gt; condition):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt;   &lt;span class="n"&gt;Lecture&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;
       &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;number&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt;  &lt;span class="n"&gt;matrNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;134534&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
To perform a theta join the &lt;code&gt;from&lt;/code&gt; clause is exteneded with the keyword &lt;code&gt;join&lt;/code&gt; between the involved tables, followed by the keyword &lt;code&gt;on&lt;/code&gt; after which the join condition is specified (because we compare with &lt;code&gt;=&lt;/code&gt; in the theta join it is an equijoin btw).
&lt;/p&gt;

&lt;p&gt;
However the most appropiate join in this use case is the &lt;i&gt;natural join&lt;/i&gt; ⊗ because we want to join on attributes that have the same name in both tables (and are foreign resp. primary keys). To do so in SQL we formulate this query:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="nb"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Lectures&lt;/span&gt; &lt;span class="k"&gt;natural&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;Hears&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;matrNr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;134534&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which yields the same old result relation (but with less query syntax):
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
As you see the natural join in SQL is express by replacing the comma between the involved tables in the &lt;code&gt;from&lt;/code&gt; clause with the keyword &lt;code&gt;natural join&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org57f0871" class="outline-3"&gt;
&lt;h3 id="org57f0871"&gt;Aggregation and Grouping&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org57f0871"&gt;
&lt;p&gt;
Often times it is of interest to perform some kind of calculations on the tuples of a table, which means to involve all values of an attribute. Functions that do this are called &lt;i&gt;aggregate functions&lt;/i&gt; and here are some common ones:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;min(A)&lt;/code&gt; → yields smallest value present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max(A)&lt;/code&gt; → yields largest value present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avg(A)&lt;/code&gt; → yields average of all values present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum(A)&lt;/code&gt; → yields sum of all values present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count(A)&lt;/code&gt; → yields amount/count of values present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count(distinct A)&lt;/code&gt; → yields amount/count of unique values present in attribute A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count(*)&lt;/code&gt; → yields amount/count of tuples in the table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Suppose we have the following table &lt;i&gt;Personal&lt;/i&gt; to see aggregate functions in action
&lt;img src="https://schoettkr.github.io/knowledge-database/images/personal-table.png" alt="nil"&gt;
To find out which is the highest and lowest salary(gehalt) in the table we formulate the following query
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="k"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gehalt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;minimum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="k"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gehalt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Personal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
yielding 
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;minimum&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;maximum&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;2084&lt;/td&gt;
&lt;td class="org-right"&gt;5249&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
Since the result of an aggregate function usually operates on &lt;i&gt;multiple&lt;/i&gt; tuples of a relation, the result can only be displayed with results of other aggregate functions rather than other &lt;i&gt;single&lt;/i&gt; attributes (think about it this way, which single attribute would make sense in the row of the result relation we just saw? none).
&lt;/p&gt;

&lt;p&gt;
It is also possible to &lt;b&gt;group&lt;/b&gt; values. Tuple that have the same value for an attribute (or set of attributes) are then &lt;b&gt;grouped&lt;/b&gt; by those same attribute values. Aggregate functions then operate &lt;b&gt;isolated&lt;/b&gt; on those formed groups, which means grouping only makes sense when aggregations are performed subsequently. The schema of the resulting table can only hold the grouped attributes and the result of the attribute functions.
&lt;/p&gt;

&lt;p&gt;
This slide gives a good visualization 
&lt;img src="https://schoettkr.github.io/knowledge-database/images/grouping-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
To &lt;i&gt;filter groups&lt;/i&gt; we can use the &lt;code&gt;having&lt;/code&gt; keyword which acts like a &lt;code&gt;where&lt;/code&gt; clause but for groups and follows the &lt;code&gt;group by&lt;/code&gt; statement.
&lt;img src="https://schoettkr.github.io/knowledge-database/images/grouping-2.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org21fcac5" class="outline-3"&gt;
&lt;h3 id="org21fcac5"&gt;Connecting SFW Statements&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org21fcac5"&gt;
&lt;p&gt;
It is possible to connect whole &lt;code&gt;select&lt;/code&gt; statements with each other in SQL. This functionality corresponds to the operations set &lt;i&gt;union&lt;/i&gt; and set &lt;i&gt;difference&lt;/i&gt; we know from relational algebra. Likewise the data types of the attributes from the tables that should be combined need to be of the same data type (and semantic) in SQL as well.
&lt;/p&gt;

&lt;p&gt;
The operators to perform this set operations
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt; corresponds to the join/union operation ∪ from relational algebra and also removes duplicates&lt;/li&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt;, &lt;code&gt;minus&lt;/code&gt; corresponds to the set difference - from relational algebra&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intersect&lt;/code&gt; corresponds to the intersection ∩ from relational algebra (Schnittmenge)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of combining/connecting SFW statements:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/sfw-connection.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org308998f" class="outline-3"&gt;
&lt;h3 id="org308998f"&gt;Subqueries&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org308998f"&gt;
&lt;p&gt;
It is possible to execute further &lt;code&gt;select&lt;/code&gt; statements &lt;i&gt;inside&lt;/i&gt; a &lt;code&gt;select&lt;/code&gt; statements. There are two possible approaches/semantics (Semantiken) to do that, the &lt;b&gt;value semantic&lt;/b&gt; (slides: Wertsemantik) and the &lt;b&gt;set semantic&lt;/b&gt; (slides: Mengensemantik?!). I'll use the german terms &lt;i&gt;Wertsemantik&lt;/i&gt; and &lt;i&gt;Mengensemantik&lt;/i&gt; because it is not clear to me what the proper english terms would be :o. Subqueries can be nested as desired as long as the semantic is correct (recursion).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org865a140" class="outline-4"&gt;
&lt;h4 id="org865a140"&gt;Wertsemantik&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org865a140"&gt;
&lt;p&gt;
The subquery returns a &lt;b&gt;single value&lt;/b&gt; (doesnt matter if string, number or date). Subqueries that follow Wertsemantik can be used at every place/position where single values may have been used.
&lt;/p&gt;

&lt;p&gt;
Example:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/wertsemantik-1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/wertsemantik-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
↑ then the surrounding/wrapping query is executed which finds the two tuples with a number of "234" in the &lt;i&gt;Hears&lt;/i&gt; table which is then counted and returns the result table 
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;anzahl&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here are some equivalent queries to the one we examined in the pictures above
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- 1&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="k"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;anzahl&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Hört&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Lehrveranstaltung&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;Hört&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nummer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Lehrveranstaltung&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nummer&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;titel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Datenbanken in der Praxis'&lt;/span&gt;

&lt;span class="c1"&gt;-- 2&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="k"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;anzahl&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;Hört&lt;/span&gt; &lt;span class="k"&gt;natural&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;Lehrveranstaltung&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;titel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Datenbanken in der Praxis'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge04a6cb" class="outline-4"&gt;
&lt;h4 id="orge04a6cb"&gt;Mengensemantik&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge04a6cb"&gt;
&lt;p&gt;
The subquery returns a Wertemenge (set of values). To then evaluate the returned result set special language features/constructs are needed.
&lt;/p&gt;

&lt;p&gt;
Example:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mengensemantik-1.png" alt="nil"&gt;
Notice that when the subquery generates a set of values like in the picture above, the &lt;code&gt;=&lt;/code&gt; operator at the &lt;code&gt;where&lt;/code&gt; statement is replaced by the &lt;code&gt;in&lt;/code&gt; set operator because we're dealing with multiple values. This is the procedure of the query above:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mengensemantik-2.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mengensemantik-3.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mengensemantik-4.png" alt="nil"&gt;
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
The subqueries we saw so far were &lt;b&gt;non-correlating&lt;/b&gt;. They worked locally and had only to be evaluated once because their result stayed constant because of the local nature.
&lt;/p&gt;

&lt;p&gt;
But suppose we want to access attribute values of surrounding/wrapping queries. 
This is where &lt;b&gt;correlating subqueries&lt;/b&gt; come into play. It is possible to access wrapping/surrounding tables from the inside of subqueries (the circumstances may require qualification via the table name). The correlation is created as soon as such reference exists. A correlating subquery always refers to the currently viewed tuple of the parent query and therefore has to be computed for &lt;b&gt;every&lt;/b&gt; tuple of the result set (slides: Eine korrelierte Unteranfrage bezieht sich immer auf das aktuell betrachtete Tupel der übergeordneten Anfrage und muss deshalb für jedes Tupel von deren Ergebnismenge neu berechnet werden).
&lt;/p&gt;

&lt;p&gt;
Example:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/correlating-subqueries-1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/correlating-subqueries-2.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb4b38a9" class="outline-3"&gt;
&lt;h3 id="orgb4b38a9"&gt;Set Operations (Mengenoperatoren)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb4b38a9"&gt;
&lt;p&gt;
We already know the specification of constant sets and how to test if an attribute value is contained in such set via &lt;code&gt;where .. in&lt;/code&gt; eg &lt;code&gt;where attribute in ('Chemnitz', 'Leipzig', 'Dresden')&lt;/code&gt;. There are more set operators of which we will introduce some now since they're also helpful in regards to subqueries and can be used to model the quantifiers from relational calculus:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;exists SET&lt;/code&gt;  becomes &lt;code&gt;true&lt;/code&gt; when &lt;code&gt;SET&lt;/code&gt; includes at least one element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMPARISON-OPERATOR all SET&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt; when the comparison operator yields &lt;code&gt;true&lt;/code&gt; for each element in &lt;code&gt;SET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMPARISON-OPERATOR any SET&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt; when the comparison operator yields &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;SET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Examples:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/set-operators-1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/set-operators-2.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/set-operators-3.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-06/</guid><pubDate>Tue, 27 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 05</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-05/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org65e4dd0" class="outline-2"&gt;
&lt;h2 id="org65e4dd0"&gt;Relational Calculus (Relationenkalkül)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org65e4dd0"&gt;
&lt;p&gt;
The expressions in &lt;i&gt;relational algebra&lt;/i&gt; form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate relation results. This way describes they way of &lt;i&gt;how&lt;/i&gt; you come to the relation result.
&lt;/p&gt;

&lt;p&gt;
There is an alternative however to describe a query result without specifying the derivation (Herleitungsvorschrift), which is called &lt;b&gt;relational calculus&lt;/b&gt;. In relational calculus only the requirements of the desired resulting tuples are specified/described but not the way they are retrieved. This way describes &lt;i&gt;what&lt;/i&gt; is contained in the result relation.
&lt;/p&gt;

&lt;p&gt;
A calculus (Kalkül) is a method, that is determined by a set of rules, to deal with certain mathematical problems in a systematic manner and solve them automatically (slides: ist eine durch ein System von Regeln festgelegte Methode, mit deren Hilfe bestimmte mathematische Probleme systematisch behandelt und automatisch gelöst werden können) 
&lt;/p&gt;

&lt;p&gt;
The basis for relational calculus is predicate/quantifier logic  of the first degree (Prädikatenlogik erster Ordnung) and the result of a query is a set of tuples. In relational calculus calculus expressions (Kalkülausdrücke) are used, in particular the &lt;b&gt;tuple calculus&lt;/b&gt; and the &lt;b&gt;domain calculus&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb52943f" class="outline-3"&gt;
&lt;h3 id="orgb52943f"&gt;Tuple Calculus&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb52943f"&gt;
&lt;p&gt;
The query notation for tuple calculus is {t | P(t)} where t is a tuple variable and P is a predicate over t. The result of such query is a set of all tuples for which the evaluation of the predicate P(t) yields &lt;i&gt;true&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Take the following example relation "Student":
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;matrNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;major&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123456&lt;/td&gt;
&lt;td class="org-left"&gt;Archimedes&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;td class="org-left"&gt;Sophokles&lt;/td&gt;
&lt;td class="org-left"&gt;Philosophy&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;145698&lt;/td&gt;
&lt;td class="org-left"&gt;Cleopatra&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Query: {s | s ∈ Student ∧ s.major='Computer Science'}
&lt;/p&gt;

&lt;p&gt;
Result: 
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;matrNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;major&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123456&lt;/td&gt;
&lt;td class="org-left"&gt;Archimedes&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;145698&lt;/td&gt;
&lt;td class="org-left"&gt;Cleopatra&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org8662ab3"&gt;&lt;/a&gt;Tuple Calculus - Atoms and Formulas&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8662ab3"&gt;
&lt;p&gt;
For the construction of formula we define sets of atomic formulas.
&lt;b&gt;Atoms&lt;/b&gt; in tuple calculus:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;t&lt;sub&gt;i&lt;/sub&gt; ∈ R&lt;sub&gt;j&lt;/sub&gt; → the relation R&lt;sub&gt;j&lt;/sub&gt; is assigned as the codomain(Wertebereich) to the tuple variable t&lt;sub&gt;i&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;t&lt;sub&gt;i.A&lt;/sub&gt; Θ t&lt;sub&gt;j.B&lt;/sub&gt; → comparison operation between two attributes A and B which are attributes of the relations that were assigned as codomains to t&lt;sub&gt;i&lt;/sub&gt; and t&lt;sub&gt;j&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;t&lt;sub&gt;i.A&lt;/sub&gt; Θ c → comparison operation between attribute A and constant C&lt;/li&gt;
&lt;li&gt;c Θ t&lt;sub&gt;i.A&lt;/sub&gt; → comparison operation between constant c and attribute A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The comparison operation denoted by Θ encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &amp;lt;, &amp;gt;, ≤, ≥, =, ≠ and =, ≠ for boolean values.
&lt;/p&gt;

&lt;p&gt;
Every atom is a &lt;i&gt;formula&lt;/i&gt;. When F&lt;sub&gt;1&lt;/sub&gt; and F&lt;sub&gt;2&lt;/sub&gt; are formulas then the following constructs are formulas as well:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;F&lt;sub&gt;1&lt;/sub&gt; ∧ F&lt;sub&gt;2&lt;/sub&gt; = Conjunction&lt;/li&gt;
&lt;li&gt;F&lt;sub&gt;1&lt;/sub&gt; ∨ F&lt;sub&gt;2&lt;/sub&gt; = Disjunction&lt;/li&gt;
&lt;li&gt;¬ F&lt;sub&gt;1&lt;/sub&gt;  = Negation&lt;/li&gt;
&lt;li&gt;(F&lt;sub&gt;1&lt;/sub&gt;) = wrapping (Klammerung)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
When F is a formula and t is a tuple variable in F then the following constructs are formulas:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(∃ t)(F) = existential quantifier (Existenzquantifizierung)&lt;/li&gt;
&lt;li&gt;(∀ t)(F) = universal quantifier (Universalquantifizierung)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org281b112"&gt;&lt;/a&gt;Tuple Calculus - Free and Bounded Tuple Variables&lt;br&gt;
&lt;div class="outline-text-5" id="text-org281b112"&gt;
&lt;p&gt;
A tuple variable in an atom (respective in a formula consisting of one atom) is &lt;b&gt;free&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
A tuple variable in a formula that is composed via negation, conjunction or disconjuction of other partial formulas is &lt;b&gt;free&lt;/b&gt; or &lt;b&gt;bound&lt;/b&gt; depending on its state in the other partial formulas. In this case a tuple variable can be free and bound at the same time.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Free&lt;/b&gt; tuple variables t of a formula F get &lt;b&gt;bound&lt;/b&gt; to the respective quantifier F' when they are embedded in one of the following formulas F':
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;F' = (∃ t)(F)&lt;/li&gt;
&lt;li&gt;F' = (∀ t)(F)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Examples:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;F&lt;sub&gt;1&lt;/sub&gt;: s.name = 'Cleopatra'&lt;/li&gt;
&lt;li&gt;F&lt;sub&gt;2&lt;/sub&gt;: (∃ t)(s.matrNr = t.matrNr)&lt;/li&gt;
&lt;li&gt;F&lt;sub&gt;3&lt;/sub&gt;: (∀ s)(s.name = 'Cleopatra')&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org7154054"&gt;&lt;/a&gt;Tuple Calculus - Computing Formulas (Substitution)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org7154054"&gt;
&lt;p&gt;
Given that F(s) is a formula with the tuple variable s ∈ R and a tuple t ∈ R. Then the following happens in each atom of F(S) with a &lt;i&gt;free&lt;/i&gt; s:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;s ∈ R is replaced with true&lt;/li&gt;
&lt;li&gt;s.A Θ u.B is replaced with t.A Θ u.B (A and B are atrtibutes, u is another tuple variable u ≠ s)&lt;/li&gt;
&lt;li&gt;s.A Θ c is replaced with the concrete boolean value of the operation t.A Θ c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
These steps are repeated for further tuple variables if necessary until F(s) only holds (possibly logically connected) boolean constants (true/false) and atoms with bound variables.
&lt;/p&gt;

&lt;p&gt;
Example:
Given tuple variable s and t from a schema R(a,b) and the formula ∀ t(t ∈ R ∧ t.a = s.a ∧ t.b &amp;lt; s.b) the substitution happens/looks like this:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the tuple s = (8, 12) → ∀ t(t ∈ R ∧ t.a = 8 ∧ t.b &amp;lt; 12)&lt;/li&gt;
&lt;li&gt;then the tuple t = (8, 9) → ∀ t(true ∧ 8 = 8 ∧ 9 &amp;lt; 12) → ∀ t(true ∧ true ∧ true) → ∀ t(true)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org4e443e1"&gt;&lt;/a&gt;Tuple Calculus - Computing Formulas for bound Tuple Variables&lt;br&gt;
&lt;div class="outline-text-5" id="text-org4e443e1"&gt;
&lt;p&gt;
Given a tuple variable s ∈ R:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the formula (∃ t)(F) evaluates to &lt;i&gt;true&lt;/i&gt; if F becomes true for at least one substitution of s and the formula evaluates to false otherwise
&lt;ul class="org-ul"&gt;
&lt;li&gt;this means that at least one tuple can be associated with the free tuple variable s for which F becomes true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the formular (∀ t)(F) evaluates to &lt;i&gt;true&lt;/i&gt; if F becomes true for &lt;i&gt;all&lt;/i&gt; substitutions of s
&lt;ul class="org-ul"&gt;
&lt;li&gt;this means that F is true/fulfilled for all tuples that can be assigned to the free tuple variable s&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;Final Formula Computation&lt;/b&gt; = formulas now only hold logically connected boolean values which can be evaluated accordingly.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org31d1e6c"&gt;&lt;/a&gt;Tuple Calculus - Expressions and Queries&lt;br&gt;
&lt;div class="outline-text-5" id="text-org31d1e6c"&gt;
&lt;p&gt;
In general an expression/query of the tuple calculus is of the following form: {t&lt;sub&gt;1.A&lt;/sub&gt;&lt;sub&gt;1&lt;/sub&gt;, t&lt;sub&gt;2.A&lt;/sub&gt;&lt;sub&gt;2&lt;/sub&gt;, …, t&lt;sub&gt;n.A&lt;/sub&gt;&lt;sub&gt;n&lt;/sub&gt; | F(t&lt;sub&gt;1&lt;/sub&gt;, …, t&lt;sub&gt;m&lt;/sub&gt;)}
&lt;/p&gt;

&lt;p&gt;
t&lt;sub&gt;i&lt;/sub&gt; are tuple variables (which in general encompass all tuples of the so called univesere, that's why they are usually assigned to a relation) and A&lt;sub&gt;i&lt;/sub&gt; are attributes of the relation that is assigned to the tuple variable t&lt;sub&gt;i&lt;/sub&gt;, while F(t&lt;sub&gt;1&lt;/sub&gt;, …, t&lt;sub&gt;m&lt;/sub&gt;) is the formula of the tuple calculus.
&lt;/p&gt;

&lt;p&gt;
Taking our previous student relation:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;matrNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;major&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123456&lt;/td&gt;
&lt;td class="org-left"&gt;Archimedes&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;td class="org-left"&gt;Sophokles&lt;/td&gt;
&lt;td class="org-left"&gt;Philosophy&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;145698&lt;/td&gt;
&lt;td class="org-left"&gt;Cleopatra&lt;/td&gt;
&lt;td class="org-left"&gt;Computer Science&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Query: {s.matrNr, s.name | s ∈ Student ∧ s.major='Philosophy'} yields
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;matrNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;134534&lt;/td&gt;
&lt;td class="org-left"&gt;Sophokles&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr&gt;

&lt;p&gt;
Now onto another example. Given the relations teacher
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;persNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;3467&lt;/td&gt;
&lt;td class="org-left"&gt;Ares&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;td class="org-left"&gt;Zeus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;43467&lt;/td&gt;
&lt;td class="org-left"&gt;Hera&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
and lectures
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;43467&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
we want to know the names of the teachers that hold at least one lecture:
{t.name | t ∈ Teacher ∧ (∃ l)(l ∈ lectures ∧ t.persNr = l.persNr)} which leads to this resulting relation
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Zeus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Hera&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr&gt;

&lt;p&gt;
To query the lecture titles of lectures given by Zeus we'd use the following:
{t.title | t ∈ Lectures ∧ (∃ l)(l ∈ teacher ∧ t.persNr = l.persNr ∧ l.name='Zeus') } to get
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr&gt;

&lt;p&gt;
For the next example queries I embed the slides because it is more clearer and not so much overhead.
&lt;img src="https://schoettkr.github.io/knowledge-database/images/tuple-calc-ex1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/tuple-calc-ex2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
One problem with queries of tuple calculus is that they can sometimes produce an infinite result relation, eg { s | ≠(s ∈ Student) }.
&lt;/p&gt;

&lt;p&gt;
The domain of a formula contains all constant values of a formula and all possible attribute values of all tuples in the referenced relations.
&lt;/p&gt;

&lt;p&gt;
A &lt;b&gt;safe query&lt;/b&gt; is a query where the result of the query stems from the domain of the formula → we only use safe queries (all queries we've seen so far are safe).
&lt;/p&gt;

&lt;p&gt;
Also see &lt;a href="https://en.wikipedia.org/wiki/Tuple_relational_calculus"&gt;https://en.wikipedia.org/wiki/Tuple_relational_calculus&lt;/a&gt; for more
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga3de7b9" class="outline-3"&gt;
&lt;h3 id="orga3de7b9"&gt;Domain Calculus&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga3de7b9"&gt;
&lt;p&gt;
The domain relational calculus is also a calculus that serves as a declarative database query language for the relational data model. In DRC queries have this form {d&lt;sub&gt;1&lt;/sub&gt;, d&lt;sub&gt;2&lt;/sub&gt;, …, d&lt;sub&gt;n&lt;/sub&gt; | F(d&lt;sub&gt;1&lt;/sub&gt;, d&lt;sub&gt;2&lt;/sub&gt;, …, d&lt;sub&gt;m&lt;/sub&gt;)} with m ≥ n where d&lt;sub&gt;i&lt;/sub&gt; are domain variables which describe the values of attribute domains and F(d&lt;sub&gt;1&lt;/sub&gt;, d&lt;sub&gt;2&lt;/sub&gt;, …, d&lt;sub&gt;m&lt;/sub&gt;) is the formula. The formula consists, like in the relational calculus (tuple?), of either a an atom, a logical connection of formulas or a formula with a domain variable which is existential quantified or universal quantified.
&lt;/p&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgc13261f"&gt;&lt;/a&gt;Domain Calculus - Atoms and Comparison&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgc13261f"&gt;
&lt;p&gt;
Given the relation R of degree n where every d&lt;sub&gt;i&lt;/sub&gt; is a domain variable, the atom \(R(d_1, d_2, ..., d_n)\) expresses that the codomain (Werteliste) &amp;lt;d&lt;sub&gt;1&lt;/sub&gt;, d&lt;sub&gt;2&lt;/sub&gt;, …, d&lt;sub&gt;n&lt;/sub&gt;&amp;gt; has to be a tuple of the relation R.
&lt;/p&gt;

&lt;p&gt;
Comparisons
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;d&lt;sub&gt;i&lt;/sub&gt; θ d&lt;sub&gt;j&lt;/sub&gt; → comparison operation between two domain variables d&lt;sub&gt;i&lt;/sub&gt; and d&lt;sub&gt;j&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;d&lt;sub&gt;i&lt;/sub&gt; θ c → comparison operation between domain variable d&lt;sub&gt;i&lt;/sub&gt; and constant c&lt;/li&gt;
&lt;li&gt;c θ d&lt;sub&gt;i&lt;/sub&gt; → comparison operation between constant c and domain variable d&lt;sub&gt;i&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The comparison operation denoted by Θ encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &amp;lt;, &amp;gt;, ≤, ≥, =, ≠ and =, ≠ for boolean values (required that the elements of the domain can be compared pairwise).
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org4db64cc"&gt;&lt;/a&gt;Domain Calculus - Example Queries&lt;br&gt;
&lt;div class="outline-text-5" id="text-org4db64cc"&gt;
&lt;p&gt;
Given the relations teacher
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;persNr{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;43467&lt;/td&gt;
&lt;td class="org-left"&gt;Ares&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;td class="org-left"&gt;Zeus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;43424&lt;/td&gt;
&lt;td class="org-left"&gt;Hera&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
and lectures
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;43467&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
&lt;b&gt;1.)&lt;/b&gt; List the lecture titles that are held by teacher with persNr 6897?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The query {b | (∃ a) (∃ c) (Lecture(a,b,c) ∧ c=6897)} yields:&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
&lt;b&gt;2.)&lt;/b&gt; What are the numbers and titles of lectures held by Zeus?
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;The query {a, b | (∃ c) (∃ d) (∃ e) (Lecture(a,b,c) ∧ teacher(d,e) ∧ c=d ∧ e='Zeus')} yields:&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
&lt;b&gt;3.)&lt;/b&gt; What's the title of lectures hold by teacher with persNr6987 with at least 5 Credits?
&lt;/p&gt;

&lt;p&gt;
We now have an additional column in our lecture relation:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;number{PK}&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;credits&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;persNr{FK}&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;123&lt;/td&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;234&lt;/td&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;345&lt;/td&gt;
&lt;td class="org-left"&gt;Database Essentials&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-right"&gt;43467&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;456&lt;/td&gt;
&lt;td class="org-left"&gt;Exercise Data Structures&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;6897&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Alternatively a query can be formulated with a direct specification of constant attribute values: {b | (Lecture(a, b, &lt;i&gt;5&lt;/i&gt;, &lt;i&gt;6897&lt;/i&gt;))} which yields
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Databases in Praxis&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
(slides: alle Variablen, die nicht „links“ auftreten, sind hierbei automatisch existenzquantifiziert)
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5d1b13a" class="outline-2"&gt;
&lt;h2 id="org5d1b13a"&gt;Relational Languages&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5d1b13a"&gt;
&lt;p&gt;
The following query languages possess the same expresiveness (Ausdrucksmächtigkeit):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;relational algebra&lt;/li&gt;
&lt;li&gt;tuple calculus (limited to safe queries)&lt;/li&gt;
&lt;li&gt;domain calculus (limited to safe queries)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Queries can be converted between those languages at any time.
&lt;/p&gt;

&lt;p&gt;
In praxis the &lt;b&gt;relational calculus&lt;/b&gt; is the foundation for "real" query languages of relational DBMS:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;tuple calculus is the foundation of SQL (Structured Query Language)&lt;/li&gt;
&lt;li&gt;domain calculus is the foundation of QBE (Query By Example)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;Relational algebgra&lt;/b&gt; is the foundation for the realisation of queries in the query languages. The sequence of operations describes the path to the result of a query (which can be optimized in some circumstances).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2d083b1" class="outline-2"&gt;
&lt;h2 id="org2d083b1"&gt;Introduction to SQL&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2d083b1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf8ae268" class="outline-4"&gt;
&lt;h4 id="orgf8ae268"&gt;History&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf8ae268"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;1970: Codd presents the relational model&lt;/li&gt;
&lt;li&gt;1974: development of the relational query language SEQUEL (Structured English Query Language)&lt;/li&gt;
&lt;li&gt;1976: further development (Weiterentwicklung) of SEQUEL served as a foundation of the DBMS prototype "System R" by IBM, which was later renamed to SQL (Structured Query Language)&lt;/li&gt;
&lt;li&gt;in the early 80s: a lot of DBMS emerge by different commercial providers → standardization is needed&lt;/li&gt;
&lt;li&gt;1987: first SQL Standard&lt;/li&gt;
&lt;li&gt;1992: big expansion of the standard → SQL 2 (SQL-92)&lt;/li&gt;
&lt;li&gt;since then continuous evolution: SQL-99 → SQL:2003 → SQL:2006 → SQL:2008 → SQL:2011&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5bcc76c" class="outline-4"&gt;
&lt;h4 id="org5bcc76c"&gt;Introduction to SQL - Components&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5bcc76c"&gt;
&lt;p&gt;
There two high level components of SQL:
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Data Definition Language (DDL)&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;defines the database structure&lt;/li&gt;
&lt;li&gt;manages the access rights to the data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
and 
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Data Manipulation Language (DML)&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;used to formulate queries for the data sets&lt;/li&gt;
&lt;li&gt;create, read, update, delete of data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For now we'll focus on the Data Manipulation Language.
&lt;/p&gt;

&lt;p&gt;
SQL does not operate on relations, but rather their physical representation form which are &lt;b&gt;tables&lt;/b&gt;. In tables duplicate entries are possible which we may have to exclude. In contrast to relations there is one more advantage to table which is that they can be sorted.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org317858d" class="outline-4"&gt;
&lt;h4 id="org317858d"&gt;Introduction to SQL - Queries&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org317858d"&gt;
&lt;p&gt;
All queries to a database in SQL are realized via the &lt;code&gt;select&lt;/code&gt; statement.
This is the general construction:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; &lt;code&gt;attribute|expression&lt;/code&gt; → which attributes should the result table contain?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt; &lt;code&gt;list of tables&lt;/code&gt; → which tables are required for the query?&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;where&lt;/code&gt;  &lt;code&gt;condition&lt;/code&gt; ] → which conditions should the result tuples fulfill?&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;group by&lt;/code&gt;  &lt;code&gt;list of attributes&lt;/code&gt; ] → summarize/condense identical attribute values&lt;/li&gt;
&lt;li&gt;[ &lt;code&gt;having&lt;/code&gt;  &lt;code&gt;condition&lt;/code&gt; ] → condition in regards to grouped tables&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
[ &lt;code&gt;order by&lt;/code&gt;  &lt;code&gt;sort&lt;/code&gt; ] → specification of sorting for the resulting table
&lt;/p&gt;

&lt;p&gt;
Now let's look at some simple example queries (mostly π projection and \roh rename at one point):
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
I insert the slides here because they are visually more appealing/clear :D
&lt;/p&gt;

&lt;p&gt;
Three simple queries:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-2.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-3.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Sorting:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-4.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-5.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Simple query with &lt;i&gt;distinct&lt;/i&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/simple-sql-6.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-05/</guid><pubDate>Tue, 20 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 04</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-04/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
Well, to be honest I would have expected that we cover the physical design phase of our database design cycle in this lecture. Turns out we didn't. Did we? I don't know :D ! It seems that lecturers tend to provide some course outline which they then don't (explicitly) follow how you would expect it.
&lt;/p&gt;

&lt;p&gt;
So in this lecture it was all about &lt;b&gt;relational algebra&lt;/b&gt;, which I think can be associated to the logical design phase (remember that the RM &lt;b&gt;relational&lt;/b&gt; model was the central topic there), so yeah there's that :D.
&lt;/p&gt;

&lt;p&gt;
(╯°□°)╯︵ ┻━┻
&lt;/p&gt;

&lt;p&gt;
Nevermind let's go!
&lt;/p&gt;

&lt;p&gt;
By the way put that table down 
&lt;/p&gt;

&lt;p&gt;
┬─┬ノ( º _ ºノ)
&lt;/p&gt;

&lt;p&gt;
Good…
&lt;/p&gt;

&lt;div id="outline-container-org21b51b4" class="outline-2"&gt;
&lt;h2 id="org21b51b4"&gt;Relational Algebra - Fundamental Operations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org21b51b4"&gt;
&lt;p&gt;
Remember from &lt;a href="https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-02/#outline-container-org01e0d8f"&gt;here&lt;/a&gt; (lecture 2) that a data model consists of a structural part, an operatoinal part and integrity rules. Relational algebra which we'll deal with in this lecture belongs to the &lt;b&gt;operational part&lt;/b&gt;, which describes permitted operations on the data and their outcome.
&lt;/p&gt;

&lt;p&gt;
Relational algebra is a formal language with the purpose of extracting information/data out of relations.
&lt;/p&gt;

&lt;p&gt;
A relational expression (relationaler Ausdruck) derives a new relation out of existing or constant base relation(s) (Basisrelation) via a relational operation.
There are different relational operations/operators (there are more than those listed below):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;unary operations: selection, projection, rename&lt;/li&gt;
&lt;li&gt;binary operations: join (Vereinigung), (set) difference (Differenz), cartesian product (Kreuzprodukt)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A set has &lt;b&gt;closure&lt;/b&gt; (Abgeschlossenheit) under an operation if performance of that operation on members of the set always produces a member of the same set; in this case we also say that the set is closed under the operation. In case of relational algebra a operation always creates another relation.
&lt;/p&gt;

&lt;p&gt;
The consequence of closure is that we are able to continue doing operations with the result of an operation ("weiterrechnen"). If X and Y are relational expressions (base expressions (relations) or compound expressions (resulting relations)?) then X ∪ Y, X-Y, X×Y, σ&lt;sub&gt;P&lt;/sub&gt;(X), π&lt;sub&gt;A&lt;/sub&gt;(X) and \roh(X) are also relational expressions/propositions (relationale Ausdrücke).
To specify the evaluation order of relational terms, they may be put into parentheses.
&lt;/p&gt;

&lt;p&gt;
Slides: We won't look at operations to define/change relations (now or for ever ?:D dunno)
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge0f14ce" class="outline-3"&gt;
&lt;h3 id="orge0f14ce"&gt;Selection&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge0f14ce"&gt;
&lt;p&gt;
A selection is visualized as σ&lt;sub&gt;P&lt;/sub&gt;(R) . That fancy little greek letter σ you see there is called sigma. It in fact is a &lt;i&gt;small&lt;/i&gt; sigma (the big sigma is the sum sign!). So to perform a selection we first need \(R\). \(R\) is a &lt;i&gt;relation&lt;/i&gt;. And the subscript parameter \(P\) is a &lt;i&gt;predicate&lt;/i&gt; (logical proposition/expression which refers to attributes of \(R\)). The result of such selection operation is a relation with the same relation schema as \(R\) which holds all tuples from R that fulfill the criteria of the predicate \(P\) (predicate is like a condition/selection criteria).
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;degree&lt;/b&gt; of the resulting relation σ&lt;sub&gt;P&lt;/sub&gt;(R) is equal to the degree of R: \(deg(\sigma_P(R)) = deg(R)\). What is the degree you ask? 
We had this in lecture 3 my friend but I'll copy it from there: &lt;i&gt;"the degree of a relation R describes the amount of attributes resp involved domains"&lt;/i&gt; (Also from wikipedia: The number of attributes constituting a heading is called the degree, which term also applies to tuples and relations. The term n-tuple refers to a tuple of degree n (n ≥ 0).)
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;cardinality&lt;/b&gt; of the resulting relation σ&lt;sub&gt;P&lt;/sub&gt;(R) is smaller or equal to the cardinality of R: \(|\sigma_P(R)| \leq |(R)|\). What is the cardinality you also ask? Well my friend we &lt;i&gt;also&lt;/i&gt; had this in lecture 3, but you're lucky that I'm such a nice fellow copy-and-pasterer :D: &lt;i&gt;"the cardinality of a relation R describes the amount of tuples (rows/elements) in R"&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
Okay suppose we have the following relation &lt;b&gt;R&lt;/b&gt;:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;c&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;d&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;e&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-left"&gt;a2&lt;/td&gt;
&lt;td class="org-right"&gt;13&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;99&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;10&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Now let's do some selections:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;σ&lt;sub&gt;e=5&lt;/sub&gt;(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;c&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;d&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;e&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-left"&gt;a2&lt;/td&gt;
&lt;td class="org-right"&gt;13&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;σ&lt;sub&gt;c&amp;gt;40∧e&amp;lt;7&lt;/sub&gt;(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;c&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;d&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;e&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;σ&lt;sub&gt;b='a3'&lt;/sub&gt;(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;a&lt;/td&gt;
&lt;td class="org-left"&gt;b&lt;/td&gt;
&lt;td class="org-left"&gt;c&lt;/td&gt;
&lt;td class="org-left"&gt;d&lt;/td&gt;
&lt;td class="org-left"&gt;e&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
As you can see the degree is always the same (5) while the cardinality varies (3, 1, 0).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1b65931" class="outline-3"&gt;
&lt;h3 id="org1b65931"&gt;Projection&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1b65931"&gt;
&lt;p&gt;
A projection is visualized as π&lt;sub&gt;A&lt;/sub&gt;(R). I think everybody knows this greek letter π it is called pi for those who don't. So to perform a projection we first need \(R\). \(R\) is a &lt;i&gt;relation&lt;/i&gt;. And the subscript parameter \(A\) is an &lt;i&gt;attribute set&lt;/i&gt; (Attributmenge) that solely holds attributes of R. The result of such projection operation is:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation of all tuples from R, the schema of the resulting relation solely consists of the attributes of A (all tuples but just the specified attributes)&lt;/li&gt;
&lt;li&gt;if A does not contain key attributes (to identify uniquely) the amount of tuples will be reduced because duplicates won't be included&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
The &lt;b&gt;degree&lt;/b&gt; of the resulting relation π&lt;sub&gt;A&lt;/sub&gt;(R) is smaller or equal to the degree of R: \(deg(\pi_A(R)) \leq deg(R)\).
&lt;/p&gt;


&lt;p&gt;
The &lt;b&gt;cardinality&lt;/b&gt; of the resulting relation π&lt;sub&gt;A&lt;/sub&gt;(R) is smaller or equal to the cardinality of R if key attributes aren't included: \(|\pi_A(R)| \leq |(R)|\). When key attributes are kept via A then the cardinality of π&lt;sub&gt;A&lt;/sub&gt;(R) is equal to the cardinality of R: \(|\pi_A(R)| = |(R)|\).
&lt;/p&gt;

&lt;p&gt;
Okay again suppose we have the following relation &lt;b&gt;R&lt;/b&gt;:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;c&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;d&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;e&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-left"&gt;a2&lt;/td&gt;
&lt;td class="org-right"&gt;13&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;99&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;10&lt;/td&gt;
&lt;td class="org-left"&gt;xx&lt;/td&gt;
&lt;td class="org-right"&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Now let's do some projections:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;π{a,b,c}(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-left"&gt;a2&lt;/td&gt;
&lt;td class="org-right"&gt;13&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;99&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;π{b,e}(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;e&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;a1&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;a2&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;b1&lt;/td&gt;
&lt;td class="org-right"&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;π{d}(R)&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;d&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;xxx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
So notice that projection gives us unique attribute combinations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc62dbdf" class="outline-3"&gt;
&lt;h3 id="orgc62dbdf"&gt;Rename&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc62dbdf"&gt;
&lt;p&gt;
A rename is a unary operation (one relation) denoted with this \roh which is callled "roh". It can be used to:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;rename a relation: \roh&lt;sub&gt;S&lt;/sub&gt;(R) = R is renamed to S&lt;/li&gt;
&lt;li&gt;rename an attribute: \roh&lt;sub&gt;b ← a&lt;/sub&gt;(R) = attribute a is renamed to b (of relation R)&lt;/li&gt;
&lt;li&gt;rename all attributes: \roh&lt;sub&gt;(x,y,z,..)&lt;/sub&gt;(R) = all attributes of R are renamed to the names in parens, this case x, y and z&lt;/li&gt;
&lt;li&gt;combined renaming: \roh&lt;sub&gt;S(a,b,c)&lt;/sub&gt;(R) = relation R is renamed to S and all its attributes are renamed to a, b, c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of rename operation:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/rename.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org61e8030" class="outline-3"&gt;
&lt;h3 id="org61e8030"&gt;Join&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org61e8030"&gt;
&lt;p&gt;
To perform a join we need two relations R and S with the same schema (same attribute domains). The attributes of R and S can be named differently though as long as they have the same domain (and of course semantic). A join is visualized like \(R \cup S\). In set theory "∪" denotes the union.
&lt;/p&gt;

&lt;p&gt;
The result of a join is a relation with the schema of R (same as S) with all tuples from R and S. If there are identical tuples in R and S those duplicates are eliminated.
&lt;/p&gt;


&lt;p&gt;
The &lt;b&gt;degree&lt;/b&gt; of the resulting relation R ∪ S is equal to the degree of R: \(deg(R \cup S) = deg(R) = deg(S)\).
&lt;/p&gt;


&lt;p&gt;
The &lt;b&gt;cardinality&lt;/b&gt; of the resulting relation R ∪ S is equal to the cardinality of R plus the cardinality of S if there are no duplicate tuples → \(|R \cup S| = |R| + |S|\). However if there are duplicate tuples then the cardinality of R ∪ S is smaller: \(|R \cup S| &amp;lt; |R| + |S|\).
&lt;/p&gt;

&lt;p&gt;
Example join operation without duplicates:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/join-without-dupl.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example join operation with duplicates:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/join-with-dupl.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge91361e" class="outline-3"&gt;
&lt;h3 id="orge91361e"&gt;Difference&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge91361e"&gt;
&lt;p&gt;
To perform a set difference we need two relations R and S with the same schema (same attribute domains). The attributes of R and S can be named differently though as long as they have the same domain (and of course semantic). A set difference is visualized like \(R - S\). 
The result of a set difference operation are the tuples, which are present in R but are &lt;b&gt;not&lt;/b&gt; in the second relation S.
&lt;/p&gt;

&lt;p&gt;
The degree of \(deg(R-S)\) is equal to \(deg(R)\). 
&lt;/p&gt;

&lt;p&gt;
If there is no overlap between the cardinality of R-S is equal to the cardinality of R: \(|R-S| = |R|\). Think about this makes sense because nothing from R is removed if it not in S. But usually there's some overlap so the cardinality is \(|R-S| &amp;lt; |R|\).
&lt;/p&gt;

&lt;p&gt;
Example set difference with overlap:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/set-with-overlap.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example set difference without overlap:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/set-without-overlap.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc26502d" class="outline-3"&gt;
&lt;h3 id="orgc26502d"&gt;Cartesian Product&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc26502d"&gt;
&lt;p&gt;
The cartesian product (Kreuzprodukt) is also a binary operation which means that it acts on two relations R and S. In contrast to the operations we looked at so far, the cartesian product &lt;i&gt;does not&lt;/i&gt; require the relations to have the same schema. The cartesian product operation is denoted as \(R × S\).
&lt;/p&gt;

&lt;p&gt;
The resulting relation of a cartesian product operation has a schema consisting of the schema of R and S. The tuple set of the resulting relation is a set of every possible combination of tuples from R and S.
&lt;/p&gt;

&lt;p&gt;
The degree is \(deg(R × S) = deg(R) + deg(S)\) and the cardinality \(|R × S| = |R| * |S|\).
&lt;/p&gt;

&lt;p&gt;
Beware that because of the combination of all tuples the resulting relation can get quite big.
&lt;/p&gt;

&lt;p&gt;
Example of a cartesian product operation:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/cartesian-prod.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Extending the Notation&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
It is a somewhat common use case that two relations need to be combined (via cartesian product) and those relations have attributes with the same name in their schema which we need to distinguish after performing the cartesian product operation.
&lt;/p&gt;

&lt;p&gt;
To do so and to avoid cumbersome rename operations we prefix identically named attributes with their origin relation name and a dot ".".
&lt;/p&gt;

&lt;p&gt;
An example of &lt;i&gt;attribue qualification&lt;/i&gt;:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/attribute-quali.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
This should however be used for temporary relation requests only. If it is planned to continue using the resulting/product relation (Produktrelation) we should qualify the attribute names distinctively via explicit renaming.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org485ec51" class="outline-2"&gt;
&lt;h2 id="org485ec51"&gt;A practicle example request en detail&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org485ec51"&gt;
&lt;p&gt;
Take the following Entity-Relationship Model(UML) and the derived Relational Model:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/practicle-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
So, we want to know which lectures the student with matricle number 134534 attended.
To find out we will first formulate the query/request in relational algebra:
&lt;/p&gt;

&lt;p&gt;
\[
\pi[titel](\sigma[matrNr=134534 \wedge Lehrveranstaltung.nummer=Hört.Nummer](Lehrveranstaltung × Hört))
\]
&lt;/p&gt;

&lt;p&gt;
↑ Notice that to improve readability we can put the subscript parameters and subscript attributes in brackets instead
&lt;/p&gt;

&lt;p&gt;
Now let's take a detailed look at the individual steps of what really happens here:
&lt;/p&gt;

&lt;p&gt;
First we create a new (temporary) relation via the cartesian product:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/example-cartesian-product.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Then we select all tuples where the Lehrveranstaltung.nummer(lecture number) matches the Hört.nummer (hears number). This is crucial because the cartesian product operation combines &lt;i&gt;all&lt;/i&gt; tuples and we kind of want to "filter" to where the original tuples match (think about what is done here and why! it is important)
&lt;img src="https://schoettkr.github.io/knowledge-database/images/example-selection-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
and of those we select the tuple(s) where the matrNr is what we search for (134534)
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/example-selection-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The following image shows the resulting relation of which we then &lt;i&gt;project&lt;/i&gt; the attribute that we are interested in (title) to get to our final result relation:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/projection-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf5505d6" class="outline-2"&gt;
&lt;h2 id="orgf5505d6"&gt;Another Example&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf5505d6"&gt;
&lt;p&gt;
Take a look at this new (similar to the previous but different!) model:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/three-relations-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Now we want to know the names of the students that attend the lecture "Datenstrukturen".
&lt;/p&gt;

&lt;p&gt;
This is the according relational algebra formula:
\[
\pi[name](\sigma[titel='Datenstrukturen' \wedge Lehrveranstaltung.nummer=Hört.Nummer \wedge Student.matrNr=Hört.matrNr](Student × Lehrveranstaltung × Hört))
\]
&lt;/p&gt;

&lt;p&gt;
First the cartesian product of the three relations:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/three-relations-cartesian.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Then the selection which is again really crucial (!!!):
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/three-relations-selection.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
And finally the projection to select the attribute of interest 'name':
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/three-relations-projection.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6d8f3df" class="outline-2"&gt;
&lt;h2 id="org6d8f3df"&gt;Relational Algebra - Extending the Fundamental Operations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6d8f3df"&gt;
&lt;p&gt;
The six operations (selection, projection, join, difference, cartesian product) that we covered in the previous sections are the fundamental/base operations (Basisoperationen) of relational algebra.
&lt;/p&gt;

&lt;p&gt;
Now we'll introduce more operations that are for commonly used functionality. All of these are however expressable via the fundamental/base operations as well.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgec8a4de" class="outline-3"&gt;
&lt;h3 id="orgec8a4de"&gt;Theta-Join&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgec8a4de"&gt;
&lt;p&gt;
When we perform the cartesian product operation we almost always perform a corresponding selection with it (/afterwards) because all tuples are combined but we only want those which match on a certain attribue. The motivation behind a &lt;b&gt;Theta-Join&lt;/b&gt; is to combine these two steps into one logical operation.
&lt;/p&gt;

&lt;p&gt;
A theta join is visualized with a bowtie ⋈ and a theta θ. The θ represents a predicate similar to the predicate P in a selection (selection criteria). A theta-join between to relations R and S would look like this R ⋈&lt;sub&gt;θ&lt;/sub&gt; S.
&lt;/p&gt;

&lt;p&gt;
This shows the equivalence of a theta-join to a cartesian product and selection operation: R ⋈&lt;sub&gt;θ&lt;/sub&gt; S = σ&lt;sub&gt;θ&lt;/sub&gt;(R × S)
&lt;/p&gt;

&lt;p&gt;
By the way when the predicate θ only holds equality operators/assignments/conditions the term &lt;i&gt;equi-join&lt;/i&gt; is used for this operation.
&lt;/p&gt;

&lt;p&gt;
The degree of a relation resulting from a theta join is equal to the degree of both relations that are joined: \(deg(R ⋈_{\theta} S) = deg(R) + deg(S)\).
&lt;/p&gt;

&lt;p&gt;
The cardinality of a relation resulting from a theta join is smaller or equal to the cardinality of both relations multiplied with each other: \|R ⋈&lt;sub&gt;θ&lt;/sub&gt; S| ≤ |R| * |S| )\)
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/theta-join-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd09aa5a" class="outline-3"&gt;
&lt;h3 id="orgd09aa5a"&gt;Natural Join&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd09aa5a"&gt;
&lt;p&gt;
While the predicate of a theta-join can be used to compare arbitrary attributes, it is pretty common to join on attribute of the same name which for example represent a primary in one and a foreign key in the other relation.
&lt;/p&gt;

&lt;p&gt;
From SO: 
&lt;/p&gt;

&lt;p&gt;
A &lt;i&gt;theta join&lt;/i&gt; allows for arbitrary comparison relationships (such as ≥).
&lt;/p&gt;

&lt;p&gt;
An &lt;i&gt;equijoin&lt;/i&gt; is a theta join using the equality operator.
&lt;/p&gt;

&lt;p&gt;
A &lt;i&gt;natural join&lt;/i&gt; is an equijoin on attributes that have the same name in each relationship
&lt;/p&gt;

&lt;p&gt;
Back to slides:
"In der Regel wird der Verbund zwischen zwei Relationen aufgrund einer SchlüsselFremdschlüssel - Beziehung hergestellt. Da diese Zuordnung meist aufgrund der Übereinstimmung von Werten getroffen wird und Schlüssel und Fremdschlüssel oft gleich benannt sind, nutzt der Natural Join diese Situation aus und führt die Zuordnung durch."
&lt;/p&gt;

&lt;p&gt;
To perform a natural join we need two relations R and S that are in a key - foreign-key relationship with identically named attributes.
&lt;/p&gt;

&lt;p&gt;
The result of a natural join is a relation consisting of the attributes of R and S. The tuples in that relation are the tuple combinations from R and S that match in &lt;i&gt;all identically named attributes&lt;/i&gt;. All attributes with the same name are only included once in the resulting relation.
&lt;/p&gt;

&lt;p&gt;
A natural join is visualized with this symbol ⊗ (symbol for tensor product) and here is an example of a natural join:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/natural-join-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
This shows the equivalence of a natural-join first to projection on a theta join and then completely in fundamental/base operations:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/natural-join-equivalence.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The degree of a relation resulting from a natural join is equal to the degree of one relation plus the other minus the cardinality of the same named attributes in those:
\(deg(R \otimes S) = \deg(R) + \deg(S) - |C|\)
&lt;/p&gt;

&lt;p&gt;
The cardinality is: \(R \otimes S \leq |R| * |S|\)
&lt;/p&gt;

&lt;p&gt;
Here's an example that visualizes the result equivalence of a natural join:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/natural-join-equivalence-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
And here's an link to a wikipedia section about joins &lt;a href="https://en.wikipedia.org/wiki/Relational_algebra#Natural_join_(%E2%8B%88)"&gt;https://en.wikipedia.org/wiki/Relational_algebra#Natural_join_(⋈)&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb804ff1" class="outline-3"&gt;
&lt;h3 id="orgb804ff1"&gt;Intersection (Schnittmenge)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb804ff1"&gt;
&lt;p&gt;
To perform an intersection operation we need two relations with an identical schema. The attributes can be named differently but need to have the same domain (and semantic).
&lt;/p&gt;

&lt;p&gt;
The intersection operation is visualized with this "∩" (cap; set intersection).
&lt;/p&gt;

&lt;p&gt;
The result of such operation is a relation with the schema of R that holds all tuples which are present in R &lt;i&gt;and&lt;/i&gt; S.
&lt;/p&gt;

&lt;p&gt;
This is the intersection operation in two fundamental operations (difference operation):
R ∩ S = R - (R - S) 
&lt;/p&gt;

&lt;p&gt;
Think about it: (R - S) removes all duplicates between the two relations so the result are only the unique tuples. Those are then removed from the original R relation so that we only have the duplicates which is the intersection (Überschneidung) ^_^
&lt;/p&gt;

&lt;p&gt;
The degree (attribute count) of R ∩ S is equal to \(deg(R) = \deg(S)\).
&lt;/p&gt;

&lt;p&gt;
The cardinality (tuple count) of R ∩ S is less than or equal to the smaller cardinality of R and S. This makes sense because only tuples that are in one relation can be duplicated in the other. So if one relation holds 3 tuples (cardinality = 3) and the other holds 8 (cardinality = 8) then there can only be 3 duplications (=intersections) at max therefore the cardinality would be less than or equal (at max when all are duplicated) to 3: |R ∩ S| ≤ min(|R|, |S|)
&lt;/p&gt;

&lt;p&gt;
Intersection operation example:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/intersection-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org952257a" class="outline-3"&gt;
&lt;h3 id="org952257a"&gt;Division&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org952257a"&gt;
&lt;p&gt;
The division is a binary operation that is written as R ÷ S. The result consists of the restrictions of tuples in R to the attribute names unique to R, i.e., in the header of R but not in the header of S, for which it holds that all their combinations with tuples in S are present in R (from wikipedia).
&lt;/p&gt;

&lt;p&gt;
Slides: To perform a division we need a relation R with an attribute set A and a relation S with an attribute set B. The attribute set B needs to be a subset of A: B \subseteq A. 
Now if we build the difference of A and B: A - B = C we get C which is a set that holds all attributes from A, that are not elements in B.
&lt;/p&gt;

&lt;p&gt;
The &lt;i&gt;division&lt;/i&gt; R ÷ S  returns all tuples from R for which there's a match in each tuple of S. The schema of the resulting relation T is just C.
&lt;/p&gt;

&lt;p&gt;
Degree: \(deg(R \div S) = |C|\)
Cardinality: |R ÷ S| ≤ |R|
&lt;/p&gt;

&lt;p&gt;
Equivalence and example of a division operation:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/division-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org56004c9" class="outline-2"&gt;
&lt;h2 id="org56004c9"&gt;Further Extension of the Algebra&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org56004c9"&gt;
&lt;p&gt;
In the context of database application there's often a wish for operations which exceed the capabilities of the fundamental operations of relational algebra.
&lt;/p&gt;

&lt;p&gt;
For some of this wanted functionality there are extensions of the relational algebra, for example:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;aggregate functions
&lt;ul class="org-ul"&gt;
&lt;li&gt;operate on all values of an attribute of a tuple set, eg sum, min, max, mean&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;grouping functions
&lt;ul class="org-ul"&gt;
&lt;li&gt;create groups of tuples that hold the same value in specific attributes&lt;/li&gt;
&lt;li&gt;aggregate functions then evaluate these groups&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-04/</guid><pubDate>Tue, 06 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 03</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-03/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
As we have learned in the last lecture there are three distinct phases of database design:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;b&gt;Conceptual Design&lt;/b&gt; (Lecture 02)
&lt;ul class="org-ul"&gt;
&lt;li&gt;creation of a semantic data model that describes all important aspects from the requirement analysis&lt;/li&gt;
&lt;li&gt;primarily serves the purpose to clearly (eindeutig) communicate the data that is to be stored and its realationships in a nontechnical way&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Logical Design&lt;/b&gt; (this lecture until ???)
&lt;ul class="org-ul"&gt;
&lt;li&gt;transforms the conceptual model into a concrete data model, which can be implemented in a database system&lt;/li&gt;
&lt;li&gt;the logical design / data model also does not hold cocrete implementation details such as DBMS, programming language(s) or hardware&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Physical Design&lt;/b&gt; (Lecture ???)
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the actual implementation of the logical data model&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In this lecture we turn or focus onto the &lt;b&gt;logical design&lt;/b&gt;
&lt;/p&gt;

&lt;div id="outline-container-orgf03a46e" class="outline-2"&gt;
&lt;h2 id="orgf03a46e"&gt;Logical Data Model&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf03a46e"&gt;
&lt;p&gt;
Which &lt;i&gt;data model&lt;/i&gt; is appropiate for the &lt;i&gt;logical design process&lt;/i&gt;? The &lt;b&gt;relational data model&lt;/b&gt; because it has a simple structure, an elegant theoretical foundation (formal description) and is economically relevant (about ~80% of database systems are based on the relational paradigm despite development/creation of alternatives).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org92f7c8a" class="outline-3"&gt;
&lt;h3 id="org92f7c8a"&gt;Relational Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org92f7c8a"&gt;
&lt;p&gt;
The relational model (RM) was introduced in a paper by E.F. Codd in 1970, which pertains as a milestone to this day. The most know prototype of this theoretical approach was created by IBM in 1975 (System R). The in the process developed query language SEQUEL was later standardized as SQL and is the most common query language for relational DBMS today.
&lt;/p&gt;

&lt;p&gt;
The first commercial systems were released at the end of the 70s for example Orcale (by Orcale Corporation) or DB2 (by IBM). Today there are hundreds of DBMS that are based on the relational data model.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org46e0d01" class="outline-3"&gt;
&lt;h3 id="org46e0d01"&gt;Relational Model - Terms and Definitions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org46e0d01"&gt;
&lt;p&gt;
The relational model is based on the mathematical concept of a (finitary?) relation, which can be represented well as a table consisting of &lt;i&gt;rows&lt;/i&gt; and &lt;i&gt;columns&lt;/i&gt;.
&lt;b&gt;Rows&lt;/b&gt; represent &lt;b&gt;different attributes&lt;/b&gt; of &lt;b&gt;one entity&lt;/b&gt;. &lt;b&gt;Columns&lt;/b&gt; represent the &lt;b&gt;same attribute&lt;/b&gt; of &lt;b&gt;all entities&lt;/b&gt;. An attribute corresponds with the attribute idea in the Entity Relationship Model (conceptual design) and is a property/characteristic of an entity.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;domain&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the domain(Wertebereich, aber Wertebereich ist eig codomain und definitionsmenge ist domain..) of an attribute&lt;/li&gt;
&lt;li&gt;this domain has to be &lt;b&gt;atomic&lt;/b&gt; → cannot hold nested structures and/or sets&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;relation&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation R is a subset of the cartesian product of \(n\) domains \(D_i\):&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
\( R \subseteq D_1 * D_2 ... * D_i ... D_n \)
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;tuple&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an element (row) of a relation is called "tuple"&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;degree&lt;/b&gt; (Grad) 
&lt;ul class="org-ul"&gt;
&lt;li&gt;the degree of a relation R describes the amount of attributes resp involved domains&lt;/li&gt;
&lt;li&gt;symbol: degree(R) / Grad(R)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;cardinality&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the cardinality of a relation R describes the amount of tuples (rows/elements) in R&lt;/li&gt;
&lt;li&gt;symbol: |R|&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/rel-model-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5bc688c" class="outline-3"&gt;
&lt;h3 id="org5bc688c"&gt;Relations and Schemas&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5bc688c"&gt;
&lt;p&gt;
&lt;b&gt;database context&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the mathematical definition of a relation just describes a set of tuples&lt;/li&gt;
&lt;li&gt;an attribute results from the position of the attribute domain when forming the product (Produktbildung)&lt;/li&gt;
&lt;li&gt;since database context attributes shall be comfortably identifiable via their name, we need an additional compononent to describe the relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;relation schema&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;includes the specification of the domains and sets of all domain names/identifiers (attributes) which are uniquely to a relation (umfasst die Spezifikation der Domänen und die Menge aller - innerhalb einer Relation eindeutigen - Domänenbezeichnungen (Attribute))&lt;/li&gt;
&lt;li&gt;describes the creation procedure (Bildungsvorschrift/Schablone) for a relation
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation is a set of tuples that is created with the help of this procedure guide&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;databases usually manage multiple tables, therefore multiple relation schemas have to be described - this is done through &lt;b&gt;database schemas&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;when \(A_1, A_2, ..., A_n\) are named attributes with the domains \(D_1, D_2, ..., D_n\) then the set \({A_1:D_1, A_2:D_2, ..., A_n:D_n}\) is the according relation schema&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;relation&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation R that is defined by a relation schema S is a set of projection (Menge von Abbildungen) of attribute names onto their corresponding domains
&lt;ul class="org-ul"&gt;
&lt;li&gt;that means R is a set of \(n\) tuples \(A_1:d_1, A_2:d_2, ..., A_n:d_n\) with \(d_1 \in D_1, d_2 \in D_2, ..., d_n \in D_n\)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;eg: Buch \(\subseteq\) string(isbn) x string(titel) x decimal(preis)&lt;/li&gt;
&lt;li&gt;in the common use of language the terms "relation" and "relation schema" are often used interchangebly
&lt;ul class="org-ul"&gt;
&lt;li&gt;so the term "relation" may refer to the relation schema, the manifestation (Ausprägung) of a schema or both&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;however it is important to keep both aspects in mind: &lt;b&gt;a relation underlies (unterliegt) a schema and is itself an instance (Ausprägung) of that schema&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;one of Codds requirements was that domains are atomic → the term &lt;b&gt;normalized relation&lt;/b&gt; clarifies this demand and usually "relation" is meant as "normalized relation"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;database schema&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when \(R_1, R_2, ..., R_n\) are differently named relation schemas then the set \(R = {R_1, R_2, ..., R_n}\) represents the relation database schema R&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6f6c9fc" class="outline-3"&gt;
&lt;h3 id="org6f6c9fc"&gt;Relations and Tables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6f6c9fc"&gt;
&lt;p&gt;
Tables are physical representation forms of relation with some differences:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;finiteness&lt;/b&gt; (Endlichkeit)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables are finite (because of limited ressources)&lt;/li&gt;
&lt;li&gt;relations can be infinite (as long as at least one domain is finite)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;order&lt;/b&gt; (Sortierung)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables are always sorted (even when the sorting criteria is not immediately obvious)&lt;/li&gt;
&lt;li&gt;in case of relations only the existence of a tuple is relevant, for existing tuples is doesnt matter at which position they are&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;duplications&lt;/b&gt; (Duplikate)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables may hold entries multiple times / duplicates&lt;/li&gt;
&lt;li&gt;all tuples of a relation are pairwise distinct&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge2ea800" class="outline-3"&gt;
&lt;h3 id="orge2ea800"&gt;Alternative Terms&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge2ea800"&gt;
&lt;p&gt;
Especially when using a concrete DBMS alternative terms than those of the relation model are used that are closer to the physical representation (I also added those somewhere above by myself b4 reading this because it felt more natural :D ):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a "relation" is often called a "table" or a "file"&lt;/li&gt;
&lt;li&gt;a "tuple" is often called a "row" or "data record"&lt;/li&gt;
&lt;li&gt;an "attribute" is often called a "column" or "field"&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd5f3f96" class="outline-3"&gt;
&lt;h3 id="orgd5f3f96"&gt;Relational Keys&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd5f3f96"&gt;
&lt;p&gt;
&lt;b&gt;superkeys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a superkey represents a set of attributes which allows to differentiate all tuples of a relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;candidate keys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a canidate key is a superkey who'se attribute set is minimal → that means no subset of his attributes allows the unique identification of all tuples of a relation (so viel attribute wie nötig um eindeutig zu unterscheiden/identifizieren und mit weniger attributen nicht möglich)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;primary keys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a primary key is a canidate which is used primarily to distingiush tuples of a relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/relational-keys.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org53e7c9c" class="outline-3"&gt;
&lt;h3 id="org53e7c9c"&gt;Relational Model - Relationships&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org53e7c9c"&gt;
&lt;p&gt;
Relations can be associated with each other. To achieve that primary key attributes of the relation which should be associated is added to the relation which realizes that relationship. The primary key which was added to a relation for this purpose is called &lt;b&gt;foreign key&lt;/b&gt;. Therefore &lt;i&gt;every foreign key has to be a primary key somewhere in a relation&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/relationship-rm.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org354266d" class="outline-3"&gt;
&lt;h3 id="org354266d"&gt;Null Values&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org354266d"&gt;
&lt;p&gt;
For some tuples of a relation the concrete value of an attribute may not be known (yet) or it may be inappropiate to have an value existing there. To represent such cases the &lt;b&gt;null value&lt;/b&gt; (null) exists which is a "non-value" alas "unknown value" (which shall not be confused with the value 0).
&lt;/p&gt;

&lt;p&gt;
Null values have to be treated differently than the usual attribute values. There's an trivalent (dreiwertig) logic to deal with them (more on that later).
&lt;/p&gt;

&lt;p&gt;
It should be a goal to minimize the cases where null values are needed although this is often not possible to realize. An excessive use should be avoided, this is especially true when representing relationships.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9a13278" class="outline-2"&gt;
&lt;h2 id="org9a13278"&gt;Logical Design: ERM to RM&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9a13278"&gt;
&lt;p&gt;
The task at hand is to translate the conceptual data model (ERM, entity relationship model) from the conceptual design phase into the logical data model (RM, relational model).
&lt;/p&gt;

&lt;p&gt;
The steps required are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;derive the relations from the attributes, entity types and relationship types of the ERM (ERM to RM)&lt;/li&gt;
&lt;li&gt;normalization of relations&lt;/li&gt;
&lt;li&gt;validation of relations in regards to user transactions&lt;/li&gt;
&lt;li&gt;verification of integrity conditions (Integritätsbedingungen)&lt;/li&gt;
&lt;li&gt;consultation (Rücksprache) with users&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org60eee29" class="outline-3"&gt;
&lt;h3 id="org60eee29"&gt;ERM to RM&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org60eee29"&gt;
&lt;p&gt;
Lets start with the conversion of strong entity types.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org87cd451" class="outline-4"&gt;
&lt;h4 id="org87cd451"&gt;ERM to RM - Strong Enitity Types&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org87cd451"&gt;
&lt;p&gt;
For each strong entity type we create a relation:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;simple attributes are just copied into the relation&lt;/li&gt;
&lt;li&gt;in case of compound attributes only the underlying/simple attributes are copied&lt;/li&gt;
&lt;li&gt;we'll later deal with derived and multivalent (see Lecture 02 for a reminder on this)&lt;/li&gt;
&lt;li&gt;the primary key of the entity type will also be the primary key of the relation 
&lt;ul class="org-ul"&gt;
&lt;li&gt;the primary key is designated via underlining&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of a Student relation: Student( &lt;span class="underline"&gt;matrikelnum&lt;/span&gt; , firstname, lastname, birthdate)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org66b5107" class="outline-4"&gt;
&lt;h4 id="org66b5107"&gt;ERM to RM - Relationship Types&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org66b5107"&gt;
&lt;p&gt;
Create a new relation for each relationship types (not always required as we'll see later why/how):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;copy (if existing) relationship attributes to the new relation&lt;/li&gt;
&lt;li&gt;add the primary keys of the involved entity types and mark them as foreign keys
&lt;ul class="org-ul"&gt;
&lt;li&gt;foreign keys are visualized via a &lt;b&gt;bold font&lt;/b&gt; (in the exam you can draw a rectangle around because bold font is difficult)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;depending on the cardinality of the relationship type mark a &lt;i&gt;subset of the foreign keys&lt;/i&gt; as the primary key of the relationship relation:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;1:1&lt;/code&gt; → one of the two foreign keys becomes the primary key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1:N&lt;/code&gt; → the foreign key which stems from the &lt;code&gt;N&lt;/code&gt; side becomes the primary key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N:M&lt;/code&gt; → both foreign keys have to become primary keys&lt;/li&gt;
&lt;li&gt;complex relationships → sensible identification via complexity reduction (? lol)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In general all relationship types can be expressed like this. The advantages are a simple and uniform procedure/strategy and the prevention of null values. However there are some disadvantages because there needs to be a relation created for each relationship type which can be a lot! Also some integrity conditions regarding cardinality may not be expressable adequately.
&lt;/p&gt;

&lt;p&gt;
So as an alternative relationship types of certain cardinalities can be expressed more efficient and adequately.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org50ea6c2"&gt;&lt;/a&gt;&lt;code&gt;N:M&lt;/code&gt; Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-org50ea6c2"&gt;
&lt;p&gt;
The previous paragraph is not applicable for &lt;code&gt;N:M&lt;/code&gt; relationship types. For those we always need a dedicated relation:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/n-to-m-relation.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
In case of the other cardinalities we can use the alternative approach.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org34372f2"&gt;&lt;/a&gt;&lt;code&gt;1:N&lt;/code&gt; Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-org34372f2"&gt;
&lt;p&gt;
We add the primary key of the entity type from the &lt;code&gt;1&lt;/code&gt; side of the relationship as a foreign key to the entity type from the &lt;code&gt;N&lt;/code&gt; side. If the relationship type has attributes, then those are also added to the entity relation from the &lt;code&gt;N&lt;/code&gt; side of the relationship.
&lt;img src="https://schoettkr.github.io/knowledge-database/images/one-to-n-inline-rel.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
This is however optional and if for example null values are unacceptable then we have to express the relationship type in its own relationship relation.
&lt;/p&gt;

&lt;p&gt;
The above already kind of leads us to &lt;i&gt;optional&lt;/i&gt; and &lt;i&gt;obligatory&lt;/i&gt; participation of entities in relationships. As we've seen above the primary key of the 1-side entity gets added as a foreign key to the n-side entity. This works perfectly as long as the participation of the 1-side entity is &lt;i&gt;obligatory&lt;/i&gt; meaning that a n-side entity always gets a foreign key of a 1-side entity assigned since it is mandatory in that kind of relationship. However there might be other cases where a participation of 1-side entities might be completely &lt;i&gt;optional&lt;/i&gt;. This would then lead to empty tuples / null values in some n-side entities. As already state above (after the picture) if this (null/empty values) are acceptable everything can be done as is, else there has to be created a designated relationship relation.
&lt;/p&gt;

&lt;p style="color:salmon;"&gt;
&lt;i&gt;I find this is kind of hard to explain and therefore I split the general information (paragraphs around the picture) and the thing with the obligatory and optional participation. I advise to take a look at the lecture slides in regards to optional and obligatory participation. Don't know how important it is for the course tho, until now we did not speak about it really (in the tutorium for example).&lt;/i&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org13b8a54"&gt;&lt;/a&gt;&lt;code&gt;1:1&lt;/code&gt; Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-org13b8a54"&gt;
&lt;p&gt;
&lt;b&gt;In case of an &lt;i&gt;obligatory&lt;/i&gt; participation on &lt;i&gt;both&lt;/i&gt; sides of the relationship:&lt;/b&gt;
Since all entities of both entity types participate in the relationship, both entity relations and the relationship attributes could be merged into one relation. Then one of the two primary keys would serve as the primary key for the resulting relation. (&lt;b&gt;Merging&lt;/b&gt;)
&lt;/p&gt;

&lt;p&gt;
However if both entity types are participating in other relationships as well (especially relationships with 1:N or N:M cardinalities) then it is not possible to merge them. In that case we add the primary key of one of the entity relations to the other entity relation as a foreign key (as well as the relationship attributes if existing). So to one relation you add the primary key of the other relation as a foreign key and all the relationship attributes. (&lt;b&gt;Referencing&lt;/b&gt;)
&lt;/p&gt;

&lt;p&gt;
Example of merging the relationship as well as the entity relations:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/merge-relation.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example of referencing (Variante A):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/ref-relation.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example of referencing (Variante B):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/ref-relation-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
\(\hookrightarrow\) in obligatory &lt;code&gt;1:1&lt;/code&gt; the reference can be in either relation (see the above pictures)
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;In case of an &lt;i&gt;obligatory&lt;/i&gt; participation on &lt;i&gt;one&lt;/i&gt; side of the relationship:&lt;/b&gt;
We add the primary key of the entity type that is &lt;i&gt;obligatory participating&lt;/i&gt; &lt;code&gt;(1..1)&lt;/code&gt; in the relationship as a foreign key to the entity type that is &lt;i&gt;optionally participating&lt;/i&gt; (&lt;code&gt;0..1&lt;/code&gt;). If the relationship type has attributes, then those are also added to the entity relation that is optionally participating in the relationship.
&lt;img src="https://schoettkr.github.io/knowledge-database/images/one-to-one-optional.png" alt="nil"&gt;
Think about how this helps or why we do it this way. Look at the picture above, as you can see a faculty is always lead by exactly one professor, but a professor leads either 0 or 1 faculties. So if we would have put the faculty name as a foreign key into the professor relation then there can be null values in the case where a concrete professor entity does not lead a faculty. It is better like we did it! Because a faculty always has a professor that leads it (1..1 → obligatory) there won't be null values in the faculty relation since there &lt;i&gt;has&lt;/i&gt; to be a &lt;code&gt;persNr&lt;/code&gt; of an professor that leads it :) I hope this explanation helps.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;In case of an &lt;i&gt;optional&lt;/i&gt; participation on &lt;i&gt;both&lt;/i&gt; sides of the relationship:&lt;/b&gt;
When null values are not allowed / inacceptable a new relationship relation has to be created. In that relation the primary keys of the entity relations are added as foreign keys as well as potential relationship attributes. One of the foreignkeys also becomes the primary key of newly created relationship entity.
&lt;/p&gt;

&lt;p&gt;
When null values are allowed / acceptable then the primary key of one relation and potential relationship attributes are added to the other entity relation type. Theoretically it doesn't matter which entity relation is linked via it's primary key, however knowledge about the relationships and amount of data (rows for each relation) might help to pick the one where less null values would occur. If there is for example a entity relation type where we have two data sets forest 1 and forest 2 which are optionally managed by one ranger (Förster) at max (&lt;code&gt;0..1&lt;/code&gt;). And we have 500 data sets of rangers which can optionally manage a forest (&lt;code&gt;0..1&lt;/code&gt;) then it would make more sense to add the rangers PK as a foreign key to the forests instead of the other way round, since &lt;code&gt;forestID&lt;/code&gt; as a foreign key in the ranger entity relation will be empty alot!
&lt;/p&gt;

&lt;p&gt;
Another example from the slides:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/one-to-one-both-optional.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-org905e59c" class="outline-4"&gt;
&lt;h4 id="org905e59c"&gt;ERM to RM - Weak Entity Types&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org905e59c"&gt;
&lt;p&gt;
The expression of a weak entity type in the relational model always has to include the relationship to the superior strong entity type (übergeordneter starker Entitytyp). The following steps describe how do this, they are however optimizable:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;create a relation for every weak entity type in the ERM&lt;/li&gt;
&lt;li&gt;add the attributes to the relation in the same manner as you'd do it for strong entity types&lt;/li&gt;
&lt;li&gt;then the primary key of the superior strong entity type is added as a foreign key&lt;/li&gt;
&lt;li&gt;the primary key of this new relation consists of the original primary key of the weak entity type (if existing) and the foreign key which stems from the super strong entity type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/weak-entity-type.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
In case of an obligatory participation of all entities of both sides of a &lt;code&gt;1:1&lt;/code&gt; relationship between a weak and a strong entity type, they entity types can be merged into one relation (as it is with obligatory &lt;code&gt;1:1&lt;/code&gt; between strong ETs):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/weak-entity-merge.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb7006cb" class="outline-4"&gt;
&lt;h4 id="orgb7006cb"&gt;ERM to RM - Multivalent (Mehrwertige) Attributes&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb7006cb"&gt;
&lt;p&gt;
To translate multivalent attribute types into the relational model:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;create a relation \(R\) for the multivalent attribute \(A\) (empty relation with name of the attribute "type")&lt;/li&gt;
&lt;li&gt;add the primary key \(K\) of the entity relation type and \(A\) to \(R\)&lt;/li&gt;
&lt;li&gt;mark \(K\) as a foreign key&lt;/li&gt;
&lt;li&gt;mark \(K\) and \(A\) as primary key of \(R\)
&lt;ul class="org-ul"&gt;
&lt;li&gt;exception: if \(A\) itself serves as a primary key of the original entity type, then \(A\) is the primary key of \(R\)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/multivalent-attr.png" alt="nil"&gt;
&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;
Now remember the steps required to translate from ERM to RM from the beginning of this post:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
"The steps required are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;derive the relations from the attributes, entity types and relationship types of the ERM (ERM to RM)&lt;/li&gt;
&lt;li&gt;normalization of relations&lt;/li&gt;
&lt;li&gt;validation of relations in regards to user transactions&lt;/li&gt;
&lt;li&gt;verification of integrity conditions (Integritätsbedingungen)&lt;/li&gt;
&lt;li&gt;consultation (Rücksprache) with users"&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;
At this point we covered the first step &lt;i&gt;yay&lt;/i&gt;. 
&lt;/p&gt;

&lt;p&gt;
The normalization of relations will be covered latter and now we'll shortly turn to integrity conditions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org81ff871" class="outline-3"&gt;
&lt;h3 id="org81ff871"&gt;Integrity Conditions and Data Integrity&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org81ff871"&gt;
&lt;p&gt;
Integrity conditions/rules describe a set of requirements to guarantee the consistency, the correctness and completeness of data. It is required to document all integrity rules in the logical design phase.
&lt;/p&gt;

&lt;p&gt;
The following kinds of integrity constraints have to be respected:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;entity integrity&lt;/b&gt; → is an integrity rule which states that a primary key should be unique and not null&lt;/li&gt;
&lt;li&gt;&lt;b&gt;referential integrity&lt;/b&gt; → integrity rule that states any foreign-key value can only be null or the value of some existing primary key; it has to be specified what happens when changing operations on PKs and FKs occur&lt;/li&gt;
&lt;li&gt;&lt;b&gt;domain integrity&lt;/b&gt; → the value of an attribute has to be part of the (co)domain (Wertebereich) of its attribute domain&lt;/li&gt;
&lt;li&gt;&lt;b&gt;obligatory data&lt;/b&gt; → for some attributes a concrete value has to be specified for every tuple (eg key attributes)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;cardinality and participation&lt;/b&gt; → rules that describe restrictions of relationships&lt;/li&gt;
&lt;li&gt;&lt;b&gt;other&lt;/b&gt; → rules that describe all other integrity constraints derived from requirements of the real world "problem"&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8eb879e" class="outline-3"&gt;
&lt;h3 id="org8eb879e"&gt;Interim Conclusion (Zwischenfazit)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8eb879e"&gt;
&lt;p&gt;
Since the expressiveness (Ausdruckskraft) of the relational model (logical design) is much lower than the epressiveness of a conceptual model (eg ERM), the conceptual model should always be done and done first! The meaning of things is often times not clear without additional knowledge from the conceptual design.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-03/</guid><pubDate>Tue, 23 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 02</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-02/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org8d91862" class="outline-2"&gt;
&lt;h2 id="org8d91862"&gt;Information Systems&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8d91862"&gt;
&lt;p&gt;
The task of information systems is to save, manage, organize, distribute and steer informations in an organization. The components of such information system are the DB, DBMS, Application Software, Hardware, Developers and Users.
&lt;/p&gt;

&lt;p&gt;
Databases historically developed out of the needs of operational information systems. That's why we look at the &lt;i&gt;database development lifecycle&lt;/i&gt; with the usual requirements of information systems in mind. For smaller DBS and databases for the management of smaller data sets e.g in web development some of the steps can be simplified and/or aggregated(zusammengefasst).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6d08c35" class="outline-2"&gt;
&lt;h2 id="org6d08c35"&gt;DBS Development Lifecycle&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6d08c35"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;consists of &lt;b&gt;planning&lt;/b&gt; and &lt;b&gt;realisation&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-org82d3d3e" class="outline-3"&gt;
&lt;h3 id="org82d3d3e"&gt;Planning&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org82d3d3e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2da4f63" class="outline-4"&gt;
&lt;h4 id="org2da4f63"&gt;Goal Description and System Defintion&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2da4f63"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;What is the purpose of the DBS?&lt;/li&gt;
&lt;li&gt;Which goals should be accomplished by using the DBS?&lt;/li&gt;
&lt;li&gt;Description of individual user viewpoints (application categories)
&lt;ul class="org-ul"&gt;
&lt;li&gt;Which (aspects of) data play a role for the user?&lt;/li&gt;
&lt;li&gt;What does a user do with "his" data?&lt;/li&gt;
&lt;li&gt;Where do needs overlap with other user(roles)?&lt;/li&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/user-viewpoints.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Creation of rules regarding data collection, data formats, documentation and naming (conventions)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1e8bc66" class="outline-4"&gt;
&lt;h4 id="org1e8bc66"&gt;Requirement Specification&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1e8bc66"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in this process data that should be managed by the DBS  is gathered/collected and analyzed&lt;/li&gt;
&lt;li&gt;the specific data and its usage is described for each user view → adequate description (not too much or too less)&lt;/li&gt;
&lt;li&gt;finally the requirements of each view have to be combined
&lt;ul class="org-ul"&gt;
&lt;li&gt;there're two procedures for this (which can be combined):&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orga224544"&gt;&lt;/a&gt;Central integration&lt;br&gt;
&lt;div class="outline-text-5" id="text-orga224544"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;each user views requirements are combined in an aggregate of requirements for the DBS&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org5432f6a"&gt;&lt;/a&gt;View integration&lt;br&gt;
&lt;div class="outline-text-5" id="text-org5432f6a"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the requirements for each user view stay seperated for the time being&lt;/li&gt;
&lt;li&gt;in the next stept a data model is designed for each user view&lt;/li&gt;
&lt;li&gt;the resulting data models are merged into an uniform data model that represents all user requirements of the database.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgad1abcb" class="outline-4"&gt;
&lt;h4 id="orgad1abcb"&gt;Application Design and DB Design*&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org718529f" class="outline-3"&gt;
&lt;h3 id="org718529f"&gt;Realisation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org718529f"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;implementation of DB and application&lt;/li&gt;
&lt;li&gt;data conversion of existing systems if needed&lt;/li&gt;
&lt;li&gt;Test: Validate functionality and fulfillment of requirements&lt;/li&gt;
&lt;li&gt;maintenance of the running sytem and extension via another development cycle if needed&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org53d804b" class="outline-3"&gt;
&lt;h3 id="org53d804b"&gt;∗Database Design&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org53d804b"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1321709" class="outline-4"&gt;
&lt;h4 id="org1321709"&gt;Data model&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1321709"&gt;
&lt;p&gt;
A data model is a collection of concepts to describe data objects and their relationships. A data model usually consists of three components:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;structural part&lt;/b&gt; → describes the structure of the data objects and their relationships&lt;/li&gt;
&lt;li&gt;&lt;b&gt;operational part&lt;/b&gt; → describes allowed operations and their results / impact on the data&lt;/li&gt;
&lt;li&gt;&lt;b&gt;integrity rules&lt;/b&gt; → guarantee that data is correct&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are different types of data models:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;object-based / semantic (eg Entity-Relationship, object-oriented)&lt;/li&gt;
&lt;li&gt;data-based (eg relational, hierarchical, network?!)&lt;/li&gt;
&lt;li&gt;physical (eg realisation and arrange of data in cocrete systems)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are multiple criteria for a optimal data model, the following list is based on the criteria after Fleming &amp;amp; von Halle:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Consistency&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;modeling of data in the way that it is used and organized in the real world (consistency between model and real world)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Simplicity&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;model should be easy to understand for every user&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Expressiveness&lt;/b&gt; (Ausdrucksfähigkeit)
&lt;ul class="org-ul"&gt;
&lt;li&gt;the data model should be able to unambiguously differentiate between different data, relationships and restrictions on the data (via explicit concepts)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Non-redundancy&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the data model should not hold the same information multiple times&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Independence&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the data model should not be bound to a specific application or technology&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Extensibility&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the data model should be easily extensible to accomodate new requirements without greater impact on the current/existing usability&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Visualization Ability&lt;/b&gt; (Visualisierbarkeit)
&lt;ul class="org-ul"&gt;
&lt;li&gt;the data model should be visualizable via an easy to understand notation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8435054" class="outline-4"&gt;
&lt;h4 id="org8435054"&gt;Three phases of database design&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8435054"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;b&gt;Conceptual Design&lt;/b&gt; (This lecture)
&lt;ul class="org-ul"&gt;
&lt;li&gt;creation of a semantic data model that describes all important aspects from the requirement analysis&lt;/li&gt;
&lt;li&gt;primarily serves the purpose to clearly (eindeutig) communicate the data that is to be stored and its realationships in a nontechnical way&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Logical Design&lt;/b&gt; (Lecture 03 until ???)
&lt;ul class="org-ul"&gt;
&lt;li&gt;transforms the conceptual model into a concrete data model, which can be implemented in a database system&lt;/li&gt;
&lt;li&gt;the logical design / data model also does not hold cocrete implementation details such as DBMS, programming language(s) or hardware&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Physical Design&lt;/b&gt; (Lecture ???)
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the actual implementation of the logical data model&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5a7f3c2" class="outline-2"&gt;
&lt;h2 id="org5a7f3c2"&gt;1. Conceptual DB-Design&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5a7f3c2"&gt;
&lt;p&gt;
The &lt;b&gt;Entity-Relationship-Model&lt;/b&gt; (ERM) is the most used data model for the conceptual DB design process. ER-Modelling is a top-down procedure that primarily tries to capture the data objects (entities) and their relationships, which are then described more precisely and detailed in the progression of the modelling process.
&lt;/p&gt;

&lt;p&gt;
There are different ways to display/visualize the concepts on an ER model, of which the &lt;b&gt;Unified Modeling Language&lt;/b&gt; (UML) is the currently most used one for object oriented projects in the sphere of software engineering.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7ad6e8f" class="outline-3"&gt;
&lt;h3 id="org7ad6e8f"&gt;ER-Model (Entity Relationship Model)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7ad6e8f"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9b72720" class="outline-4"&gt;
&lt;h4 id="org9b72720"&gt;Entities&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9b72720"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;entity type&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes a group of objects which have the same attributes/properties and (usually) exist independently of each other (physical or conceptual)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;entity&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;descibres a clearly identifiable object of a certain entity type&lt;/li&gt;
&lt;li&gt;in everyday language the "entity" is also often meant as the entity type because we usually dont deal with single objects&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;visualization&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an entity type is visualized as a rectangle with a name, which is usually a substantive/noun in the singular form (each starting letter of compound words is capitalized)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgab541bd" class="outline-4"&gt;
&lt;h4 id="orgab541bd"&gt;Relationships&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgab541bd"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;relationship&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes a clearly identifiable connection between existing entities&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;relationship type&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the set of "equal" connections/relationships between entity types&lt;/li&gt;
&lt;li&gt;similar to "entity" the term "relation" is often used to describe the relationship type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;visualization&lt;/b&gt;    
&lt;ul class="org-ul"&gt;
&lt;li&gt;each &lt;i&gt;relationship type&lt;/i&gt; is visualized as a line that connects two &lt;i&gt;entity types&lt;/i&gt; and is annotated with a name that describes the relationship type&lt;/li&gt;
&lt;li&gt;the name of a relationship type should be or include a verb&lt;/li&gt;
&lt;li&gt;each starting letter should be capitalized and the names of different relationship types should also be different if possible&lt;/li&gt;
&lt;li&gt;a relationship type is only named in one direction - this is visualized via an arrow that is placed next to the name and points in one direction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of two entity types and one relationship type:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/entity-rel-example.png" alt="nil"&gt;&lt;/li&gt;

&lt;li&gt;&lt;b&gt;complexity/degree of a relationship type&lt;/b&gt; (Grad eines Beziehungstyps)
&lt;ul class="org-ul"&gt;
&lt;li&gt;more than two entity types can be involved in a relationship type&lt;/li&gt;
&lt;li&gt;the amount of involved entity types in a relationship types yields the complexity/degree (Grad) of the relationship type&lt;/li&gt;
&lt;li&gt;a relation with a degree of two is called a &lt;i&gt;binary relationship&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;complex relationships&lt;/b&gt; are relationship types that have a degree that is higher than 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;visualization of complex relationships&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;complex relationships can be visualized with a rhombus (Raute)&lt;/li&gt;
&lt;li&gt;the name of the relationship is written inside the rhombus&lt;/li&gt;
&lt;li&gt;the direction arrow is ommitted&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of a ternary relationship:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/ternary-rel.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of a quarternary relationship:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/quarternary-rel.png" alt="nil"&gt;&lt;/li&gt;

&lt;li&gt;&lt;b&gt;recursive relationship&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;entities of the same type can also be associated with other entities of the same type, this is called a recursive relationship&lt;/li&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/recursive-rel.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;b&gt;role description/designation&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in for example recursive relationships the entities often have different purpose (erfüllen versch Zweck) and this can be visualized by assigning &lt;i&gt;role deschriptions / designation&lt;/i&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/role-des-rec.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;role description may also be useful if multiple relationship types exist between two entity types
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;img src="https://schoettkr.github.io/knowledge-database/images/role-des.png" alt="nil"&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0cbd560" class="outline-4"&gt;
&lt;h4 id="org0cbd560"&gt;Attributes&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0cbd560"&gt;
&lt;p&gt;
An &lt;b&gt;attribute&lt;/b&gt; denotes a propterty/characteristic/trait (Eigenschaft)  of an entity type.
The &lt;b&gt;atrtibute domain&lt;/b&gt; is the set of values in an &lt;i&gt;attribute&lt;/i&gt; for example for the attribute "married" the attribute domain would consist of "yes" and "no" (another example could be age (1-99) or rooms in a hotel (1-200)).
&lt;/p&gt;

&lt;p&gt;
When an entity type shall be visualized with its attributes the rectangle is divided into two parts. In the upper part is the entity name and in the bottom part are the attributes listed.
Attribute names begin with a lowercase letter and each consequential word of compound terms are capitalized:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/attribute-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Usually &lt;i&gt;relationship types&lt;/i&gt; do not have attributes because they just connect entity types. Sometimes though addidtional attributes are required so that a separate &lt;i&gt;entity type&lt;/i&gt; may be created out of the original &lt;i&gt;relationship type&lt;/i&gt;. This newly created (weak) entity type then gets the respective attributes assigned. These attributes are called &lt;b&gt;relationship attributes&lt;/b&gt; (Beziehungsattribute).
To visualize &lt;b&gt;relationship attributes&lt;/b&gt; a virtual entity type without a name is created and connected to the relationship type with a dotted line:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/relationship-attributes.png" alt="nil"&gt;
Be careful, the existence of a lot of relationship attributes may be a sign that a "complete" entity type is required and hidden in the relationship. The likelihood of this increases with an increasing amount of relationship attributes.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgf7a586b"&gt;&lt;/a&gt;Attribute Types&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgf7a586b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;simple/atomic(atomar)&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;attribute consists of a single component&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;compound&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;attribute consists of multiple components&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;monovalent&lt;/b&gt; / &lt;b&gt;univalent&lt;/b&gt; (einwertig)
&lt;ul class="org-ul"&gt;
&lt;li&gt;attribute can only hold one value for an entity of an entity type at the same time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;multivalent&lt;/b&gt; / &lt;b&gt;polyvalent&lt;/b&gt; (mehrwertig)
&lt;ul class="org-ul"&gt;
&lt;li&gt;attribute can hold multiple values for an entity of an entity type at the same time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;derived&lt;/b&gt; (abgeleitet)
&lt;ul class="org-ul"&gt;
&lt;li&gt;values of the attribute are not stored directly/explicitly, instead are computed out of values from one or more  attributes of entities from any attribute type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org4e86836"&gt;&lt;/a&gt;Schlüsselattribute (key attributes)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org4e86836"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;candidate key&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;is the smallest &lt;b&gt;set of attributes&lt;/b&gt; which distinctively identifies each entity of a given entity type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;primary key&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;entity types can have more than one &lt;i&gt;candidate keys&lt;/i&gt;, in this case one of those is marked as a &lt;b&gt;primary key&lt;/b&gt; (by default if only one candidate key is present this becomes the primary key)&lt;/li&gt;
&lt;li&gt;the selection criteria to choose a primary key out of multiple candidate keys consist of the meaning of the key in context of the entity type, its future-proofness and also the length of the key&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;alternative keys&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;sometimes it is useful to have further/other ways to identify an entity type, those attributes may be marked as alternative keys&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org8f1e998"&gt;&lt;/a&gt;Visualizing Attribute Types and Designating Key Attributes&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8f1e998"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the components of compound attributes are indented&lt;/li&gt;
&lt;li&gt;ranges of possible values are denoted via square brackets after the attribute, eg [1..*] for an arbitrary amount&lt;/li&gt;
&lt;li&gt;the designation of &lt;i&gt;derived attributes&lt;/i&gt; is done via a leading slash "/"&lt;/li&gt;
&lt;li&gt;the first attribute(s) designate the primary key of an entity type
&lt;ul class="org-ul"&gt;
&lt;li&gt;those attributes should also be tagged with a trailing "{PPK}" in case of multiple attributes that yield the primary key or respectively "{PK}" if its only one attribute that acts as a primary key&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;alternative keys are tagged with a trailing "{AK}"&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org205dc18"&gt;&lt;/a&gt;Weak and Strong Entity Types&lt;br&gt;
&lt;div class="outline-text-5" id="text-org205dc18"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;weak entity type&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;some entities may not be distinctively distinguishable solely by their attribute values&lt;/li&gt;
&lt;li&gt;a distinct identification is only possible with the help of a relationship to another entity type, that means a &lt;i&gt;weak entity type&lt;/i&gt; is &lt;i&gt;existentially dependent&lt;/i&gt; (existensabhängig) on another entity type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;strong entity type&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;entities of a strong entity type are distinctively distinguishable by their attribute values, that means they are indepenent of the existence of another entity type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9c42ed0" class="outline-4"&gt;
&lt;h4 id="org9c42ed0"&gt;Cardinality&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9c42ed0"&gt;
&lt;p&gt;
The &lt;b&gt;cardinality&lt;/b&gt; describes the maximum amount of relationships, in which an entity of a specific relationship type (steht so in Folien, müsste dies nicht entity type statt relationship type sein?) may be a part of.
&lt;/p&gt;

&lt;p&gt;
In the case of &lt;i&gt;binary relationships&lt;/i&gt; we distringuish between three categories of cardinality: &lt;code&gt;1:1&lt;/code&gt;, &lt;code&gt;1:N&lt;/code&gt; and &lt;code&gt;N:M&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;participation&lt;/b&gt; describes weather all or just a few entities of an entity type are involved in the manifestation (Ausprägung) of a relationship type.
&lt;/p&gt;

&lt;p&gt;
Cardinality and participation are visualized via the "Min..Max-Notation" which specifies the lower and upper limit for both sides of the relationship of the entities.
&lt;/p&gt;

&lt;p&gt;
Note that to determine the cardinality and participation always both sides/directions of a relationship have to be viewed!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2dd04cb" class="outline-4"&gt;
&lt;h4 id="org2dd04cb"&gt;Cardinality of Binary Relationships&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2dd04cb"&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org3eb3d72"&gt;&lt;/a&gt;1:1 Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-org3eb3d72"&gt;
&lt;p&gt;
Each entity out of entity set E&lt;sub&gt;1&lt;/sub&gt; may only be in relation to maximally one entity out of entity set E&lt;sub&gt;2&lt;/sub&gt;. Each entity out of entity set E&lt;sub&gt;2&lt;/sub&gt; may as well only be in relation with one entity from entity set E&lt;sub&gt;1&lt;/sub&gt; at most.
&lt;/p&gt;

&lt;p&gt;
For example one professor leads one faculty at most (or none) and each faculty is lead by exactly one professor (→ &lt;code&gt;1:1&lt;/code&gt;):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/one-to-one-example.png" alt="nil"&gt;
So a professor either leads one at max or no faculty. The professors numbers "0..1" go to the right side of the relationship name. From the view of a faculty, which is always lead by one professor not more and not less the tag "1..1" goes on the left side of the relationship name. So notice that the min-max relationship that is directly besides an entity is the relationship viewed from the other entity!
&lt;/p&gt;

&lt;p&gt;
So if I want to change/add/create the min-max ranges for example for the professors meaning that I let go so many professors that everyone who is left has to lead a faculty. Then I'd have to change the "0" next to faculty to a "1" because 1 professor leads one faculty. It also seems that only the upper range boundary is considered when specifying the cardinality of a relationship (eg 0..1 and 0..1 on both sides would be a 1-to-1 relationship)
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgb7e0558"&gt;&lt;/a&gt;1:N Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgb7e0558"&gt;
&lt;p&gt;
Each entity out of entity set E&lt;sub&gt;1&lt;/sub&gt; may be in a relationship with an arbitrary amount of entities out of entity set E&lt;sub&gt;2&lt;/sub&gt;. Each entity out of entity set E&lt;sub&gt;2&lt;/sub&gt; may only be in a relationship with one entity from entity set E&lt;sub&gt;1&lt;/sub&gt; at most.
&lt;/p&gt;

&lt;p&gt;
For example at a faculty work multiple professors and one professor belongs to exactly one faculty (→ &lt;code&gt;1:N&lt;/code&gt;):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/one-to-n-example.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Another example:
\[\fbox{Person} \xrightarrow[]{\text{0..N    born in    1..1}} \fbox{City}\]
&lt;/p&gt;

&lt;p&gt;
This is read as one person is born in at least one and at max one city (1..1). To see it out of the city's perspective: in a city zero or more ("0..N") persons are/were born.
&lt;/p&gt;

&lt;p&gt;
One more example:
\[\fbox{Person} \xrightarrow[]{\text{0..N    died in    0..1}} \fbox{City}\]
&lt;/p&gt;

&lt;p&gt;
This is read as one person died in either none (person is alive) and at max one city (0..1). To see it out of the city's perspective: in a city zero or more ("0..N") persons have died.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org2f10eed"&gt;&lt;/a&gt;N:M Relationship&lt;br&gt;
&lt;div class="outline-text-5" id="text-org2f10eed"&gt;
&lt;p&gt;
Each entity out of entity set E&lt;sub&gt;1&lt;/sub&gt; may be in a relationship with an arbitrary amount of entities out of entity set E&lt;sub&gt;2&lt;/sub&gt;. Each entity out of entity set E&lt;sub&gt;2&lt;/sub&gt; may also be in a relationship with an arbitrary amount of entities from entity set E&lt;sub&gt;1&lt;/sub&gt;.
&lt;/p&gt;

&lt;p&gt;
For example a student listens to multiple lectures and lectures are heard by multiple students (→ &lt;code&gt;N:M&lt;/code&gt;):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/n-to-mexample.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org53a0e91" class="outline-4"&gt;
&lt;h4 id="org53a0e91"&gt;Cardinality Analysis&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org53a0e91"&gt;
&lt;p&gt;
When modelling segments of the real world one should consider weather the relationships between entity types are of static or dynamic nature and wether the relationships exist on the instance (Instanzebene) or type level (Typebene). Depending on that the cardinality of equal (gleichartigen) relationships between entity types may vary.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgf3cef09"&gt;&lt;/a&gt;Static&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgf3cef09"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;modelling of the current state&lt;/li&gt;
&lt;li&gt;eg over the course of one semester one teacher holds one (or multiple) lectures (1:N relationship)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/static-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org60eaa13"&gt;&lt;/a&gt;Dynamic&lt;br&gt;
&lt;div class="outline-text-5" id="text-org60eaa13"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;modelling of the process (Modellierung des Verlaufs)&lt;/li&gt;
&lt;li&gt;eg over the course of multiple semesters it is possible that multiple/different teachers hold the lecture (N:M relationship)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/dynamic-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org389ad15"&gt;&lt;/a&gt;Instance (level)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org389ad15"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an entity of a entity type represents a concrete und uniquely identifiable object&lt;/li&gt;
&lt;li&gt;eg a customer buys products which are identifiable via their serial number
&lt;ul class="org-ul"&gt;
&lt;li&gt;no other customer is able to buy a product with the same serial number → 1:N relationship&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/instance-example.png" alt="nil"&gt;
(Read: Null bis/oder ein Kunde kauft 0 bis N Produkte. Wenn man es von der anderen Seite aus lesen will also entgegen des Beziehungspfeil, dann muss der Name der Beziehung also das Verb in die passiv Form gewandelt werden → Null bis N Produkte &lt;i&gt;werden&lt;/i&gt; von keinem oder genau einem Kunden &lt;i&gt;gekauft&lt;/i&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org6a0a5ba"&gt;&lt;/a&gt;Type (level)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org6a0a5ba"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an entity of a entity type represents a a type resp. a category of objects&lt;/li&gt;
&lt;li&gt;eg a customer buys products which are only sold as a category of objects for instance a box of matches
&lt;ul class="org-ul"&gt;
&lt;li&gt;other customers could buy the same product (a box of matches) → N:M relationship&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/instance-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c906eb" class="outline-4"&gt;
&lt;h4 id="org8c906eb"&gt;Relationships with a Degree &amp;gt; 2 (Mehrstellige Beziehungen)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8c906eb"&gt;
&lt;p&gt;
To represent relationships where the degree of the cardinality is higher than 2 more letters may be required, eg N:M:P relationship. Take for example the interpretation of ternary relationships:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;1:1:1 → anologous to 1:1 → if a entity is in a relationship it cannot be part of another relationship (with the same relationship type)&lt;/li&gt;
&lt;li&gt;1:1:N → (1x1):N → a combination of entities in a relationship with a cardinality of 1 my be associated with an arbitrary amount of entities from the "N side"; entities from the "N side" that are in a relationship are not allowed to be included in another 1:1 combination&lt;/li&gt;
&lt;li&gt;1:N:M → 1:(N x M) → entities from the "1 side" can be in a relationship with an arbitrary amount of different N:M combinations; N:M combinations may only be in one relationship with an entity from the "1 side"&lt;/li&gt;
&lt;li&gt;N:M:P → no constraints&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
To determine the &lt;i&gt;cardinality&lt;/i&gt; and &lt;i&gt;participation&lt;/i&gt; of a relationship of degree \(n\) the min and max limits of the participating entity types have to be analyzed  (Um Kardinalität und Partizipation einer n-stelligen Beziehung festzustellen, analysiert man für jeden an der Beziehung teilnehmenden Entitytyp die Mindest- und Maximalzahl der Entities die für eine beliebige feste Entitykombination der weiteren (n–1) an der Beziehung teilhabenden Entitytypen auftreten können.)
&lt;/p&gt;

&lt;p&gt;
For example:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/ternary-rel-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-org6a90d8e" class="outline-4"&gt;
&lt;h4 id="org6a90d8e"&gt;Example of ER Modelling Process&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6a90d8e"&gt;
&lt;p&gt;
Task: We want to model a simplified version of a semester and the following points should be expressed:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;lectures and responsible lecturers&lt;/li&gt;
&lt;li&gt;available rooms and their seats&lt;/li&gt;
&lt;li&gt;time and place of lectures&lt;/li&gt;
&lt;li&gt;lectures may be prerequisites of other lectures&lt;/li&gt;
&lt;li&gt;students and their participation in lectures&lt;/li&gt;
&lt;li&gt;students and their participation in exams&lt;/li&gt;
&lt;li&gt;type of, result, room, time and examiner of an exam&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Note that because of too much overhead visualizing this manually I'll just insert pictures of the lecture slides here:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/er-model-1.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/er-model-2.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/er-model-3.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/er-model-4.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org424d10e" class="outline-3"&gt;
&lt;h3 id="org424d10e"&gt;Summary of the Conceptual Database Design Process&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org424d10e"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;identification of entity types&lt;/li&gt;
&lt;li&gt;identification of relationship types&lt;/li&gt;
&lt;li&gt;detailed description of the entity and relatship types via association of attributes&lt;/li&gt;
&lt;li&gt;defintion (Festlegung) of the attribute codomains (Wertebereich)&lt;/li&gt;
&lt;li&gt;definition (Bestimmung) of candidate- and primary keys&lt;/li&gt;
&lt;li&gt;test for redundancies&lt;/li&gt;
&lt;li&gt;validation wether or not the conceptual data model serves (the transactions of) the real world operations → involvement of the users&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd976b07" class="outline-2"&gt;
&lt;h2 id="orgd976b07"&gt;2. Logical DB-Design&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd976b07"&gt;
&lt;p&gt;
→ We will begin to examine the logical database design process in the next lecture (lecture 03).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-02/</guid><pubDate>Tue, 16 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 01</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-01/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org1932274" class="outline-2"&gt;
&lt;h2 id="org1932274"&gt;Organization&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1932274"&gt;
&lt;p&gt;
The "Database Essentials" course does not use the centralized eLearning platform as most other courses do. The lecture slides and exercise materials are instead uploaded here: &lt;a href="https://www.tu-chemnitz.de/informatik/DVS/lehre/DBG/"&gt;https://www.tu-chemnitz.de/informatik/DVS/lehre/DBG/&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
To get the credit points in this course one has first to do succeed in the prerequisites before he's allowed to participate in the written exam at the end of the semester. The prerequisites consist of homework and more details regarding those will follow when the first task is due.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5d28889" class="outline-2"&gt;
&lt;h2 id="org5d28889"&gt;Why do we need databases?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5d28889"&gt;
&lt;p&gt;
The starting point is that most applications require data in some form. Data then again has to be organized somehow. How may data be organized? Well for example in a plain file.
&lt;/p&gt;

&lt;p&gt;
Advantages of a plain file:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;easy and fast to create&lt;/li&gt;
&lt;li&gt;can be opened with many programs&lt;/li&gt;
&lt;li&gt;can be shared easily e.g via email or usb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Seems good right? Wrong. Take the following example:
&lt;/p&gt;

&lt;p&gt;
Assume we have two institutions that belong to one organization. The administrations office (AO) and the personnel department (PD).
&lt;/p&gt;

&lt;p&gt;
AO requires the following data:
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;ID&lt;/td&gt;
&lt;td class="org-left"&gt;7432420&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Name&lt;/td&gt;
&lt;td class="org-left"&gt;Doe, John&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Street&lt;/td&gt;
&lt;td class="org-left"&gt;Milkyway 42&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;City&lt;/td&gt;
&lt;td class="org-left"&gt;Metropolis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;SSN&lt;/td&gt;
&lt;td class="org-left"&gt;f01e37d2-e54b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
PD requires the following data:
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Identifier&lt;/td&gt;
&lt;td class="org-left"&gt;7432420&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Surname&lt;/td&gt;
&lt;td class="org-left"&gt;Doe&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Forename&lt;/td&gt;
&lt;td class="org-left"&gt;John&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address&lt;/td&gt;
&lt;td class="org-left"&gt;Milkyway 42, Metropolis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;IBAN&lt;/td&gt;
&lt;td class="org-left"&gt;TR2000584U51D8302O7L9Q0823&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;BIC&lt;/td&gt;
&lt;td class="org-left"&gt;PWCUSNC1553&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Now let's shine a light on the disadvantages of having the above data stored seperately in plain files.
&lt;/p&gt;

&lt;p&gt;
Redundancy:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;the colored entries are stored doubly across our two files (I still have to figure out how to highlight text in my blogging pipeline sorry :D, but you can see that most information is duplicated e.g the ID or name)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
One consequence of redundancy is that if the data needs to be changed, the changes have to be done in multiple places, which is cumbersome. And if the changes are not applied correctly inconsistencies will occur!
&lt;/p&gt;

&lt;p&gt;
Reduced Cohesiveness:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;it is not clear if data is logically connected (or the same)&lt;/li&gt;
&lt;li&gt;is "ID" for example always the same as "Identifier"? We don't know!&lt;/li&gt;
&lt;li&gt;how is the data connected? Surname + Forename = Name?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Operate on/with the data:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;it is hard to retrieve statistical information about the data because it is unclear where and how it is stored&lt;/li&gt;
&lt;li&gt;bad performance of requests/queries because the data has first to be searched for in all the files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Big data:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;the data may be too large to be stored on a single filesystem (e.g telecommunication data) → how do I find relevant information fast in those data pools?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Concurrency:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Person A opens the file from a network drive, loads the content into memory and starts editing it. Meanwhile Person B does the same. Person A finishes and saves back to the file on the network drive and after that Person B saves as well.&lt;/li&gt;
&lt;li&gt;Because Person B did not have the changes from Person A when he started modifying the data, he overwrites those changes when he saves. This is called a &lt;b&gt;lost update&lt;/b&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Privacy:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;not every user is allowed to have full access to the data → management of individual read and write permissions required&lt;/li&gt;
&lt;li&gt;privacy arrangements depend on the surrounding OS → generally there's no option to restrict access to specific information within a file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Dependencies:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;structure of the data is determined by the application program and not by the data itself (e.g convert between Word &amp;amp; Open Office)&lt;/li&gt;
&lt;li&gt;data is bound to the software&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Data loss:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;plain files usually only offer periodic backups → data losses that occur while editing a file or between saves are not backuped&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Capacity &amp;amp; Performance:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;most filesystems don't offer suited concepts for editing large data pools in a consistent and performant manner&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfe3cc72" class="outline-3"&gt;
&lt;h3 id="orgfe3cc72"&gt;Problem solution&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfe3cc72"&gt;
&lt;p&gt;
A great deal of the above issues lay in the &lt;i&gt;direct access&lt;/i&gt; (via the filesystem) to a &lt;i&gt;inconsistent&lt;/i&gt; or &lt;i&gt;badly structured&lt;/i&gt; data pool in a &lt;i&gt;sequential manner&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Steps to a solution:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;structure the data&lt;/li&gt;
&lt;li&gt;make direkt access to saved data possible (no sequential run-through)&lt;/li&gt;
&lt;li&gt;provide an abstract layer between the data and the access that coordinates the access, optimizes performance and guarantees integrity (indirect access)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is where databases come into play. The abstract layer between the access and the data is called &lt;i&gt;database management system&lt;/i&gt; (DBMS). The DBMS holds the structural and operational components to organize the da. Via the DBMS the creation, access, managment and deletion of/to data is realised.
&lt;/p&gt;

&lt;p&gt;
The &lt;i&gt;database&lt;/i&gt; (DB) is the datapool that is managed by the DBMS. The entity that the DBMS and the DB build together is called &lt;i&gt;database system&lt;/i&gt; (DBS).
However it is pretty common to refer to this DBS as "database".
&lt;/p&gt;

&lt;p&gt;
It is common that different applications interact with the DBMS to access data from the database. The DBMS ensures that each application/accessor has an individual view and access to the data defined by its authentication and access rights.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org95d9bf6" class="outline-3"&gt;
&lt;h3 id="org95d9bf6"&gt;Different Views on a DBS&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org95d9bf6"&gt;
&lt;p&gt;
&lt;b&gt;External view (DB User)&lt;/b&gt; :
Because the task of a DBS is to manage and organize the data for different external applications each external application has its own view of the modeled data.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Conceptual view (DB Designer/Developer)&lt;/b&gt; : This is the essential view of the database. It gives a complete overview of the logical structure of all objects and their relationships that are modelled in the data model.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Internal view (DB-Admin)&lt;/b&gt; :
This is the view of the DBMS on "its" database. Besides the internal data structures, the location, arrangement, encryption and access optimizations can be found here.
&lt;/p&gt;

&lt;p&gt;
As seen above data objects can be described from three different layers of abstraction. The layers build the Three-level architecture (&lt;a href="https://en.wikipedia.org/wiki/ANSI-SPARC_Architecture"&gt;ANSI-SPARC&lt;/a&gt;) of the database system. This separation makes sense because of multiple reasons
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;DB Users shall not be concerned with the database internals and should just care about the usage of the data, which has to be individual adapted to their use case and priviliges.&lt;/li&gt;
&lt;li&gt;DB Admins shall be able to change the hardware as well as the internal structure of the data without affecting external applications / DB Users.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1d2acc9" class="outline-3"&gt;
&lt;h3 id="org1d2acc9"&gt;Three-level architecture&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1d2acc9"&gt;
&lt;p&gt;
The formal description of the database is called the &lt;i&gt;database schema&lt;/i&gt;. The database schema consists of formal descriptions of the components of the three-level architecture.
&lt;/p&gt;

&lt;p&gt;
Usually there is:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;one or more external schemas&lt;/li&gt;
&lt;li&gt;one conceptual schema&lt;/li&gt;
&lt;li&gt;one internal schema&lt;/li&gt;
&lt;li&gt;rules for transforming between the external and the conceptual schema&lt;/li&gt;
&lt;li&gt;rules for transforming between the conceptual and the internal schema&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3b4ffe3" class="outline-4"&gt;
&lt;h4 id="org3b4ffe3"&gt;External Schemas&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3b4ffe3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;external schemas describe the aspects of the conceptual objects, their relations and constraints that are important for the correct data usage in their application&lt;/li&gt;
&lt;li&gt;the access to the database is usually restricted in some way(s)&lt;/li&gt;
&lt;li&gt;data from the conceptual view can be represented differently to the external view (e.g additional constraints)&lt;/li&gt;
&lt;li&gt;this functionality is given by the transformation rules that enable the transformation between objects from the conceptual schema to the external schema and vica versa&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org76fe0b1" class="outline-4"&gt;
&lt;h4 id="org76fe0b1"&gt;Conceptual Schema&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org76fe0b1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;contains all information and properties of objects and their relations that play a role in the data management&lt;/li&gt;
&lt;li&gt;defines aspects of correct data managment (e.g constraints)&lt;/li&gt;
&lt;li&gt;is a central reference point for all applications that use the database (external view)&lt;/li&gt;
&lt;li&gt;changes rather infrequently, e.g only when the business model changes as well&lt;/li&gt;
&lt;li&gt;represents an uniform point of documentation&lt;/li&gt;
&lt;li&gt;controlls the data usage/access from an central point&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge36b954" class="outline-4"&gt;
&lt;h4 id="orge36b954"&gt;Internal Schema&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge36b954"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes how and where data is stored, e.g physical location&lt;/li&gt;
&lt;li&gt;allows creation of additional indices for (for example frequently used) attributes → physical data organization&lt;/li&gt;
&lt;li&gt;defines transformation rules and describes the transformation between objects from the internal view to the conceptual view and vica versa&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Three-level architecture: &lt;img src="https://schoettkr.github.io/knowledge-database/images/three-level-architecture.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1c0f6af" class="outline-3"&gt;
&lt;h3 id="org1c0f6af"&gt;Data independence&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1c0f6af"&gt;
&lt;p&gt;
Each higher level of the data architecture has to be immune to changes of the next lower level of the architecture.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Logical data independence&lt;/b&gt; = the external schemas don't need to be changed when the conceptual schema is modified
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Physical data independence&lt;/b&gt; = the conceptual schema doesn't need to be changed when the internal schema is changed
&lt;/p&gt;

&lt;p&gt;
A prerequisite for this is that the changes can be represented via the transformation rules.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgda1cea1" class="outline-3"&gt;
&lt;h3 id="orgda1cea1"&gt;Advantages of databases&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgda1cea1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;data independence&lt;/li&gt;
&lt;li&gt;reduced redundancy because differenct applications may access the same data&lt;/li&gt;
&lt;li&gt;consistency because of the centralized storage and organization&lt;/li&gt;
&lt;li&gt;integrity (correct values) because of improved control mechanisms&lt;/li&gt;
&lt;li&gt;statistic measures are easier to do because the data is modelled in one data model, which allows flexible connections → queries are more efficient because data is easier to find&lt;/li&gt;
&lt;li&gt;multiple usage and concurrent access is managed by the DBMS to prevent e.g lost updates&lt;/li&gt;
&lt;li&gt;security improvements because data access can be controlled easier&lt;/li&gt;
&lt;li&gt;standards compliance (naming conventions, documentation, access)&lt;/li&gt;
&lt;li&gt;scalability and reduced costs because usually only the hardware has to be upgraded if the requirements change and not the technology of the data consuming applications&lt;/li&gt;
&lt;li&gt;increased productivity because the tools given by a DBMS are usually much more powerful than those of a file system&lt;/li&gt;
&lt;li&gt;improved backup capabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>database</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-01/</guid><pubDate>Wed, 10 Oct 2018 11:28:51 GMT</pubDate></item></channel></rss>