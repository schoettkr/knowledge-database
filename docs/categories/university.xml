<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knowledge Database (Posts about university)</title><link>https://schoettkr.github.io/knowledge-database/</link><description></description><atom:link href="https://schoettkr.github.io/knowledge-database/categories/university.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:schoettkr@gmail.com"&gt;schoettkr&lt;/a&gt; </copyright><lastBuildDate>Tue, 11 Dec 2018 22:27:03 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Algos &amp; Programming - Lecture 19</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-19/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
This lecture directly builds on lecture 18 so make sure to be in the picture about what we did there.
&lt;/p&gt;
&lt;div id="outline-container-orgf863f0a" class="outline-2"&gt;
&lt;h2 id="orgf863f0a"&gt;Text Search&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf863f0a"&gt;
&lt;p&gt;
In lecture 18 we ended with the pseudocode implementation of our search algorithm and now we want to implement it in C. As a refresher here's the pseudocode once again:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// str is file/text buffer and p is search string&lt;/span&gt;
&lt;span class="nl"&gt;Require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;Ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;appearance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;

&lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;SIMPLE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SEARCH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="c1"&gt;// found 1st occ of search string&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;
      &lt;span class="n"&gt;endif&lt;/span&gt;
      &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;
    &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"not found"&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As you can see in the line &lt;code&gt;if j = length(p) then ...&lt;/code&gt;  we also need a function that determines the length of a string. There's one in the standard library but we'll write our own (same as for the &lt;code&gt;presentResult&lt;/code&gt; function in lecture 18!):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now the algorithm in C looks pretty similar to the pseudocode however we have to account for the fact that indices begin at 0 and also do some condition checking:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;tlen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;plen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;plen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tlen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// abort if search string is longer than text&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;tlen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// iterate over chars in text&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;plen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// increment j as long as chars in the search string and text match&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;plen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// when j is equal to plen - 1 all characters matched&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//found the string (1st occurence)&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Let's examine the above implementation/algorithm:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;we have two nested loops
&lt;ul class="org-ul"&gt;
&lt;li&gt;the outer loop runs through all \(n\) elements in our text &lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the inner loop runs through \(m\) elements in the search string &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;our upper boundary is therefore \(\mathcal{O} (m*n)\)&lt;/li&gt;
&lt;li&gt;the lower boundary is \(\mathcal{O} (m)\) (text begins with searchstring)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Let's look at more efficient approaches!
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf0af9dd" class="outline-4"&gt;
&lt;h4 id="orgf0af9dd"&gt;Boyer-Moore Algorithm&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf0af9dd"&gt;
&lt;p&gt;
Wikipedia: The Boyer–Moore string-search algorithm is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature. It was developed by Robert S. Boyer and J Strother Moore in 1977.
&lt;/p&gt;

&lt;p&gt;
The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches.
&lt;/p&gt;

&lt;p&gt;
The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string search algorithms. In general, the algorithm runs faster as the pattern length increases. 
&lt;/p&gt;

&lt;p&gt;
The key features of the algorithm are to &lt;b&gt;match on the tail of the pattern&lt;/b&gt; rather than the head, and to &lt;i&gt;skip along the text in jumps of multiple characters&lt;/i&gt; rather than searching every single character in the text.
&lt;/p&gt;

&lt;p&gt;
The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text. If the characters do not match, there is no need to continue searching backwards along the text. If the character in the text &lt;i&gt;does not match&lt;/i&gt; &lt;b&gt;any&lt;/b&gt; &lt;i&gt;of the characters in the pattern&lt;/i&gt;, then the next character in the text to check is located &lt;code&gt;n&lt;/code&gt; characters farther along the text, where &lt;code&gt;n&lt;/code&gt; is the length of the pattern. 
&lt;/p&gt;

&lt;p&gt;
If the character in the text &lt;b&gt;is&lt;/b&gt; in the pattern, then a &lt;b&gt;partial shift&lt;/b&gt; of the pattern along the text is done &lt;i&gt;to line up along the matching character&lt;/i&gt; and the process is repeated. Jumping along the text to make comparisons rather than checking every character in the text decreases the number of comparisons that have to be made, which is the key to the efficiency of the algorithm.
&lt;/p&gt;

&lt;p&gt;
A shift is calculated by applying two rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org4701525"&gt;&lt;/a&gt;They Bad Character Rule (T=Text, P=Pattern)&lt;br&gt;
&lt;div class="outline-text-5" id="text-org4701525"&gt;
&lt;p&gt;
The bad-character rule considers the character in &lt;code&gt;T&lt;/code&gt; at which the comparison process failed (assuming such a failure occurred). The next occurrence of that character to the left in &lt;code&gt;P&lt;/code&gt; is found, and a shift which brings that occurrence in line with the mismatched occurrence in &lt;code&gt;T&lt;/code&gt; is proposed. If the mismatched character does not occur to the left in &lt;code&gt;P&lt;/code&gt;, a shift is proposed that moves the entirety of &lt;code&gt;P&lt;/code&gt; past the point of mismatch
&lt;/p&gt;

&lt;p&gt;
For the Good Suffix Rule you should study the wikipedia section &lt;a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_Good_Suffix_Rule"&gt;here&lt;/a&gt; as well as the slides :D On slide 35/36 (chapter 10) there is the code for a disttable and the adapted C search code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2948200" class="outline-4"&gt;
&lt;h4 id="org2948200"&gt;Wildcards&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2948200"&gt;
&lt;p&gt;
Let's extend the problem to also allow for wildcards in our search string:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; match exactly &lt;b&gt;one&lt;/b&gt; character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; match &lt;b&gt;one or no&lt;/b&gt; character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; match arbitrary characters (0,1,2,…,)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For this idea we'll use state machines. The search string defines a regular grammar and the state machine gets into an &lt;i&gt;accept&lt;/i&gt; state when a matching (according to the grammmar) character/expression (Ausdruck) is found in the text.
&lt;/p&gt;

&lt;p&gt;
Since every search string can be different the state machine has to generated at run time! It exists of other generic state machines (generische Teilautomaten). From the starting the state the state machine goes into one of the end states:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(part) &lt;b&gt;success&lt;/b&gt; &lt;code&gt;s&lt;/code&gt; when a character is found → accept&lt;/li&gt;
&lt;li&gt;&lt;b&gt;failure&lt;/b&gt; &lt;code&gt;f&lt;/code&gt; when nothing was found&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is how such statement machine would look like for an input of &lt;code&gt;"A"&lt;/code&gt; &lt;b&gt;without&lt;/b&gt; wildcards:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-a.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Now we want to formulate a state machine for the input &lt;code&gt;A?C&lt;/code&gt; (including wildcards):
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Here's the state machine for matchin &lt;code&gt;A!C&lt;/code&gt;:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-3.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
And finally the state machine for matching &lt;code&gt;A*C&lt;/code&gt;:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-4.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
Question/Problem: What happens when there's no normal character after a &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; in our search string (-&amp;gt; instead other wildcards)
&lt;/p&gt;

&lt;p&gt;
Some observations:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a search sequence of &lt;code&gt;!&lt;/code&gt;'s is not critical&lt;/li&gt;
&lt;li&gt;if the search pattern starts with &lt;code&gt;*&lt;/code&gt; or a &lt;code&gt;!&lt;/code&gt;, that wildcard can be skipped&lt;/li&gt;
&lt;li&gt;if the &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; is followed by the end of the text, that wildcard can be skipped&lt;/li&gt;
&lt;li&gt;if a &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; is followed by a &lt;code&gt;?&lt;/code&gt; then the characters can be swapped (so können beide Zeichen getauscht werden)&lt;/li&gt;
&lt;li&gt;if a &lt;code&gt;!&lt;/code&gt; is followed by a &lt;code&gt;*&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; can be ignored&lt;/li&gt;
&lt;li&gt;if a &lt;code&gt;*&lt;/code&gt; is followed by &lt;code&gt;!&lt;/code&gt; or another &lt;code&gt;*&lt;/code&gt; then the second wildcard can be ignored&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
With the observations 2-6 transformation rules can be formulated as an algorithm.
&lt;/p&gt;

&lt;p&gt;
Here is the pseudocode:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;possibly&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;wildcards&lt;/span&gt;
&lt;span class="nl"&gt;Ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt; &lt;span class="n"&gt;sanitized&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;

&lt;span class="n"&gt;repeat&lt;/span&gt; 
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'!'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'!'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;

  &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="n"&gt;substr&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;substr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;substr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;!?&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;replace&lt;/span&gt; &lt;span class="n"&gt;substr&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;?!&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; 
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;*?&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;replace&lt;/span&gt; &lt;span class="n"&gt;substr&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;?*&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;!*&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;*!&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;replace&lt;/span&gt; &lt;span class="n"&gt;substr&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;
&lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Since string manipulation is easier in Python we'll take a look at the implemenation of the transformation rules in Python first:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sanitize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# repeat as often as needed&lt;/span&gt;
	&lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'!'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# delete leading * or !&lt;/span&gt;
	&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'!'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# delete tailing * or !&lt;/span&gt;
	&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'*?'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'!?'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	    &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
	    &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;'?'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="c1"&gt;# *? -&amp;gt; ?* and !? -&amp;gt; ?!&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'!*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'*!'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'**'&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
	    &lt;span class="n"&gt;changed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
	    &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;'*'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="c1"&gt;# !* or *! or ** -&amp;gt; *&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The C implemenation is a bit longer but achieves the same. You can take look at it on page 47/48 (chapter 10).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org861d68f" class="outline-4"&gt;
&lt;h4 id="org861d68f"&gt;Data Structures&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org861d68f"&gt;
&lt;p&gt;
The state machine we constructed has to be generated at run time. A suitable data structure to represent this would be a &lt;b&gt;graph&lt;/b&gt; since state machines are graphs (they consist of vertices and edges). The vertices in a graph are the states in the state machine and the edges are the transitions.
&lt;/p&gt;

&lt;p&gt;
An adjacency matrix is unsuited since vertices and edges need to hold additional information so we use =struct=s with pointers (see Chapter 7, Slide 13).
&lt;/p&gt;

&lt;p&gt;
What do we need to describe a transition?
&lt;/p&gt;

&lt;p&gt;
→ a start and end state&lt;br&gt;
→ a condition
&lt;/p&gt;

&lt;p&gt;
Because we will associate the edges with their origin/start state we only need the target (Wir werden die Ausgangskanten den entsprechenden Zuständen zuordnen, deshalb brauchen wir nur das Ziel).
&lt;/p&gt;

&lt;p&gt;
Also there just 5 conditions in our state machine:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the character is found&lt;/li&gt;
&lt;li&gt;the character is not found&lt;/li&gt;
&lt;li&gt;the end of text is reached&lt;/li&gt;
&lt;li&gt;the end of text is not reached&lt;/li&gt;
&lt;li&gt;neither the character nor the end of text was found&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Accordingly we can define a data structure and constants:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	      &lt;span class="n"&gt;MatchChar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;MatchNotChar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;MatchEOT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;MatchNotEOT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;MatchNotCharNotEOT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;NoEdge&lt;/span&gt; &lt;span class="c1"&gt;// mark edges that are not existing in our state machine&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;match_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;match_t&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;edge_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We describe states with:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;designating wheather it is an end state (either &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;) or another state&lt;/li&gt;
&lt;li&gt;the character that refers to the state&lt;/li&gt;
&lt;li&gt;the transitions from that state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
And because there can only be 3 transitions at max to other states we allow ourselves to possibly waste a bit of memory by allocating an array for exactly 3 edges.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	      &lt;span class="n"&gt;StateDefault&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;StateSuccess&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	      &lt;span class="n"&gt;StateFail&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;statetype_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;statetype_t&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;edge_t&lt;/span&gt; &lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;state_t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Because we only at run-time how large our state machine needs to be (ie how many states it has) we create an anonymous array (that holds the states -&amp;gt; pointer) and store the index of the start state as well:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;state_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;automata_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now the state machine can be created from the search pattern at runtime. For that we also need a success state, a fail state and a state for every non &lt;code&gt;*&lt;/code&gt; character in the search string. For that we allocate memory:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;automata_t&lt;/span&gt; &lt;span class="nf"&gt;init_automata&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// snr = statenumber (?)&lt;/span&gt;
  &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// decrease for each '*'&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;automata_t&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="cm"&gt;/* add the elments / states to the state array&lt;/span&gt;
&lt;span class="cm"&gt;   the success and fail state are always the same therefore we create constant for the indices */&lt;/span&gt;
  &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;S_FAIL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S_SUCC&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="c1"&gt;// Fail&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StateFail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// Success&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_SUCC&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StateSuccess&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_SUCC&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_SUCC&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S_SUCC&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;snr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Let's cover the case of normal characters first. We'd have two edges. One has the character from the search string as a condition, the other has the negation of such as the condition:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// continuing the switch in the code listing above&lt;/span&gt;
&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StateDefault&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchChar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchNotChar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// later conditions marked as NoEdge wont be evaluated/executed&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This is what the above case represents
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-default-case.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Onto the case for the &lt;code&gt;'?'&lt;/code&gt; wildcard character which is similar to the state for a normal character, with the difference that the condition is &lt;i&gt;End-of-Text&lt;/i&gt; (and its negation) because the '?' allows &lt;b&gt;one&lt;/b&gt; arbitrary character:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/state-machine-question-mark.png" alt="nil"&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'?'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StateDefault&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchNotEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NoEdge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// no third edge therefore not needed/used&lt;/span&gt;

  &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now the case for the &lt;code&gt;'!'&lt;/code&gt; wildcard character. The state for &lt;code&gt;'!'&lt;/code&gt; needs 3 edges
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;one edge to the state after the next state (folgezustand des folgezustands) with the condition that the character of the next state is found (represents the optionality)&lt;/li&gt;
&lt;li&gt;one edge to the next state when neither the character of the next state nor EOT is matched (represents arbitrary char)&lt;/li&gt;
&lt;li&gt;one edge for EOT that goes to fail state&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'!'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StateDefault&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// get character from next state&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchChar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;S_FAIL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchNotCharNotEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In contrast to the previous cases, the &lt;code&gt;'*'&lt;/code&gt; character &lt;b&gt;does not&lt;/b&gt; create a new state. Instead the state of the next character is &lt;b&gt;modified&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the condition of the edge to 'fail' is mititgated (abgeschwächt) to EOT&lt;/li&gt;
&lt;li&gt;a loop to itself is added, when neither the original character nor EOT are matched&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="c1"&gt;// no ++snr&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatchNotCharNotEOT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Finally we also need to determine the initial state of our state machine. Since we operated on the search pattern from the tail, the initial state is the state that was generated last.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// switch from above&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// close init_automata function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now the state machine is constructed and can be used
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org7e00e31"&gt;&lt;/a&gt;Executing the State Machine&lt;br&gt;
&lt;div class="outline-text-5" id="text-org7e00e31"&gt;
&lt;p&gt;
Since now we have the function to initialize the state machine, it can be executed when the search is performed. Because of the wildcards the length of the match is not known beforehand, the search needs to return two values (start and end):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;searchresult_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;searchresult_t&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;automata_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When executing the search what basically needs to happen is that it is checked if a condition is true and then a switch to the next state needs to happen. If the state machine gets into the 'fail' or 'success' state the execution ends.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;searchresult_t&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;automata_t&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;tlen&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;searchresult_t&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;tlen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;snr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;StateDefault&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MatchChar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
	    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MatchNotChar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
	    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MatchEOT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
	    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MatchNotEOT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
	    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MatchNotCharNotEOT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
	     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
	  &lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;snr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* next character */&lt;/span&gt;
	    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	  &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="cm"&gt;/* end for iteration over edges */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snr&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;StateSuccess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="cm"&gt;/* end for iteration over text */&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Because of the new return value of the search function, the presentResult function (from last lecture) also needs to be adapted:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;presentResult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;searchresult_t&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prelen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// output beginning&lt;/span&gt;

  &lt;span class="n"&gt;prelen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// beginning of match&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%.*s[%.*s]%.20s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prelen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Finally we can use our algorithm in the following main function:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;automata_t&lt;/span&gt; &lt;span class="n"&gt;automata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;searchresult_t&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* ... error checks and file / memory !&lt;/span&gt;
&lt;span class="cm"&gt;     handling as in simple search ... */&lt;/span&gt;

  &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sanitize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="n"&gt;automata&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;init_automata&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;automata&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;presentResult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;automata&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Final Reflections:
Like the simple search, this algorithm has a complexity of \(\mathcal{O}(m*n)\) where &lt;code&gt;n&lt;/code&gt; is the size of the text and &lt;code&gt;m&lt;/code&gt; the max (expanded) size of the search pattern. In the worst case, when &lt;code&gt;*&lt;/code&gt; occurs in the search pattern, the expanded length/size is the length of the text that is searched the complexity can get to \(\mathcal{O}(n^2)\). That's why in praxis there's usually an agreement upon that searches are performed line by line and that line endings are not matched (or that there's a max expansion length).
Also beware that wildcard search algorithm are often not realized via this algorithm that we looked and instead with recursive functions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-19/</guid><pubDate>Sun, 09 Dec 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 18</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-18/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgeb4d687" class="outline-2"&gt;
&lt;h2 id="orgeb4d687"&gt;Text Search&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgeb4d687"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org289df66" class="outline-3"&gt;
&lt;h3 id="org289df66"&gt;Files&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org289df66"&gt;
&lt;p&gt;
Bigger volumes of data are usually not entered interactively but rather stored in &lt;b&gt;files&lt;/b&gt;. That's why we take a look at files first: A file is a set of data that logically belongs together and is treated as a unit. Files are usually acessed by a &lt;i&gt;file name&lt;/i&gt; that is known to the operating system and get stored on persistant data volumes (eg harddrives).
&lt;/p&gt;

&lt;p&gt;
Files can be organized differently. In the sense of the UNIX philosophy a file is a single set of bytes with an arbitrary size. Such data set resp sequence of bit is also called &lt;b&gt;bitstream&lt;/b&gt; resp. &lt;b&gt;bytestream&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
The input/ouput of the C standard library is adapted to this concept so that there is no differentitation required between input from an input device or a file. To be more precise, the C standard library knows two types of file operations:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;low level file operations&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;files and file/data streams are identified via a &lt;b&gt;handle&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;specific to the particular operating system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;high level file operations&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;files and file/data streams are identified via a &lt;b&gt;file pointer&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;independant of the operating system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For now we'll look at &lt;b&gt;high level file operations&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Files have to be &lt;b&gt;opened&lt;/b&gt;. When opening a file the management/administration information is created (Verwaltungsinformationen). There's a function in the standard library to open files &lt;code&gt;FILE* fopen(char* name, char* mode)&lt;/code&gt; which returns a pointer to the file management structure (Dateiverwaltungsstruktur) or NULL:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ... */&lt;/span&gt;

&lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"myFile.dat"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
A file that is no longer needed should be closed and the management resources shoudl eb released. That is done via &lt;code&gt;int fclose(FILE* stream)&lt;/code&gt; which returns &lt;code&gt;0&lt;/code&gt; when the file was closed successfully.
&lt;/p&gt;

&lt;p&gt;
Here's a list of the possible file access modes which are passed to &lt;code&gt;fopen&lt;/code&gt;:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;"r"&lt;/code&gt; → &lt;b&gt;read&lt;/b&gt;: open file for input operations (reading from the file); the file must exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"w"&lt;/code&gt; → &lt;b&gt;write&lt;/b&gt;: create an empty file for output operations (writing to a file); if a file with the same name already exists, its contents are discarded and the file is treated as a new empty file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"a"&lt;/code&gt; → &lt;b&gt;append&lt;/b&gt;: open file for output at the end of a file; output operations always write data at the end of the file, thus expanding it; repositioning operations (fseek, fsetpos, rewind) are ignored; the file is created if it does not exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"r+"&lt;/code&gt; → &lt;b&gt;read/update&lt;/b&gt;: open a file for update (both for input and output); the file must exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"w+"&lt;/code&gt; → &lt;b&gt;write/update&lt;/b&gt;: create an empty file and open it for update (both for input and output); if a file with the same name already exists its contents are discarded and the file is treated as a new empty file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"a+"&lt;/code&gt; → &lt;b&gt;append/update&lt;/b&gt;: open a file for update (both for input and output) with all output operations writing data at the end of the file; repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file; the file is created if it does not exist&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
With the &lt;i&gt;mode specifiers&lt;/i&gt; above files are opened as &lt;i&gt;text files&lt;/i&gt;. In order to open a file as a &lt;i&gt;binary file&lt;/i&gt; a &lt;code&gt;"b"&lt;/code&gt; character has to be included in the mode string.  This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the plus sign for the mixed modes ("rb+", "wb+", "ab+").
&lt;/p&gt;

&lt;p&gt;
For data input and output, C provides a collection of library functions. These functions enable the transfer of data between the C program and standard input/output devices. C always treats all input-output data, regardless of where they originate or where they go, as a stream of characters. 
The operating system makes the input and output devices available to a C program as if these devices were files. So, essentially, when a C program reads data from the keyboard, it is in effect reading from the file associated with the keyboard device. When a C program sends output data to the console, it is in effect writing to the file associated with the console device.
&lt;/p&gt;

&lt;p&gt;
A stream of characters or text stream, is a sequence of characters divided into lines. Each line consists of various characters followed by a newline character (\n). All input-output functions in C conform to this model.
&lt;/p&gt;

&lt;p&gt;
In order to be able to use the above mentioned input-output functions in your C program, you must begin each C program with a pre-processor directive to include these standard library functions.
&lt;/p&gt;

&lt;p&gt;
This can be done via &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
These are the most common/essential input-output functions:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt; &lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Input&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;formatted&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int fscanf(FILE*, char*, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int fprintf(FILE*, char*, ...)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;characters&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int fgetc(FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int fputc(int, FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;strings&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;char* fgets(char*, int, FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int fputs(char*, FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;binary&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;size_t fread(void*, size_t, size_t, FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;size_t fwrite(void*, size_t, size_t, FILE*)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org77ad400"&gt;&lt;/a&gt;Formatted data input &amp;amp; output&lt;br&gt;
&lt;div class="outline-text-5" id="text-org77ad400"&gt;
&lt;p&gt;
&lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;fprintf&lt;/code&gt; work like &lt;code&gt;scanf&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt; but take a file pointer as an additional first parameter. To use &lt;code&gt;fscanf&lt;/code&gt; the file has (at least) to be opened in read mode ("r", "r+", "w+", "a+"). To use &lt;code&gt;fprintf&lt;/code&gt; the file has (at least) to be opened in write mode ("w", "a", "r+", "w+", "a+"). 
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"out.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"w"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Hello world! The answer is %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org07c317f"&gt;&lt;/a&gt;Characterwise data input &amp;amp; output&lt;br&gt;
&lt;div class="outline-text-5" id="text-org07c317f"&gt;
&lt;p&gt;
The function &lt;code&gt;int fgetc(FILE* stream)&lt;/code&gt; returns the next character of a file &lt;code&gt;stream&lt;/code&gt; as an integer. When there's no character left, the constant &lt;code&gt;EOF&lt;/code&gt; (defined in &lt;code&gt;stdio.h&lt;/code&gt;) is returned (same thing when an error occurs). 
&lt;/p&gt;

&lt;p&gt;
The function &lt;code&gt;int fputc(int c, FILE* stream)&lt;/code&gt; writes the integer coded character &lt;code&gt;c&lt;/code&gt; into the file &lt;code&gt;stream&lt;/code&gt; and returns the number of written characters (= 1). In case of an error it returns &lt;code&gt;EOF&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org318e40c"&gt;&lt;/a&gt;String data input &amp;amp; output&lt;br&gt;
&lt;div class="outline-text-5" id="text-org318e40c"&gt;
&lt;p&gt;
The function &lt;code&gt;char* fgets(char restrict * str, int n, FILE* restrict stream)&lt;/code&gt; reads maximally &lt;code&gt;n-1&lt;/code&gt; characters from the file &lt;code&gt;stream&lt;/code&gt; into a character string that is pointed to by &lt;code&gt;str&lt;/code&gt;. The reading proccess ends with the end of the line/file or when an error occurs. When no error occurs &lt;code&gt;\0&lt;/code&gt; is appended to &lt;code&gt;str&lt;/code&gt; and the return value points to &lt;code&gt;str&lt;/code&gt; (and to &lt;code&gt;NULL&lt;/code&gt; if there was an error). Beware that it is the duty of the programmer to guarantee that &lt;code&gt;str&lt;/code&gt; points to an character array which has a size of at least &lt;code&gt;n&lt;/code&gt; characters.
&lt;/p&gt;

&lt;p&gt;
The function &lt;code&gt;int fputs(char* str, FILE* stream)&lt;/code&gt; writes the (zero-terminated) string &lt;code&gt;str&lt;/code&gt; into the file &lt;code&gt;stream&lt;/code&gt;. It returns a non-negative integer on success and &lt;code&gt;EOF&lt;/code&gt; in case of an error (old C versions used to return &lt;code&gt;0&lt;/code&gt; on success)
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org8d872f6"&gt;&lt;/a&gt;Binary data input &amp;amp; output&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8d872f6"&gt;
&lt;p&gt;
The function &lt;code&gt;size_t fread(void* ptr, size_t size, size_t nitems, FILE* stream)&lt;/code&gt; reads &lt;code&gt;nitems&lt;/code&gt; of size &lt;code&gt;size&lt;/code&gt; from the file &lt;code&gt;stream&lt;/code&gt; and stores them at the address specified by &lt;code&gt;ptr&lt;/code&gt;. It then returns the count of successfully read items/elements (not bytes!). 
&lt;/p&gt;

&lt;p&gt;
The function &lt;code&gt;size_t fwrite(void* ptr, size_t size, size_t nitems, FILE* stream)&lt;/code&gt; writes &lt;code&gt;nitems&lt;/code&gt; from the address &lt;code&gt;ptr&lt;/code&gt; of size &lt;code&gt;size&lt;/code&gt; in the file &lt;code&gt;stream&lt;/code&gt; and also returns the count of successfully written elements/items (not bytes).
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;


&lt;li&gt;&lt;a id="org31cb6ba"&gt;&lt;/a&gt;Standard Data Streams&lt;br&gt;
&lt;div class="outline-text-5" id="text-org31cb6ba"&gt;
&lt;p&gt;
The standard input-output devices or the associated files or text streams, are referred to as:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;stdin&lt;/b&gt; - standard input file, normally connected to the keyboard&lt;/li&gt;
&lt;li&gt;&lt;b&gt;stdout&lt;/b&gt; - standard output file, normally connected to the screen/console&lt;/li&gt;
&lt;li&gt;&lt;b&gt;stderr&lt;/b&gt; - standard error display device file, normally connected to the screen/console&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt; don't need to be opened like other files/streams (and cannot be opened):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"This is usage data.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"This is status data.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;div id="outline-container-org2dcd619" class="outline-4"&gt;
&lt;h4 id="org2dcd619"&gt;Manipulating the File Position Pointer&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2dcd619"&gt;
&lt;p&gt;
See: &lt;a href="https://stackoverflow.com/questions/39687795/what-is-file-position-pointer"&gt;https://stackoverflow.com/questions/39687795/what-is-file-position-pointer&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Usually files are treated as data stream, which are accessed &lt;b&gt;sequentally&lt;/b&gt;. In case of "real files" it is possible to deviate from this sequential access. The following functions may be used to do so:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void rewind(FILE* stream)&lt;/code&gt; → move the read or write position in the file &lt;code&gt;stream&lt;/code&gt; back to the beginning of the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void fseek(FILE* stream, long offset, int whence)&lt;/code&gt; → moves the read or write position in the file &lt;code&gt;stream&lt;/code&gt; to a position which is &lt;code&gt;offset&lt;/code&gt; bytes shifted from &lt;code&gt;whence&lt;/code&gt; (von wo/woher)
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;whence&lt;/code&gt; shall be one of the following constants which are defined in &lt;code&gt;stdio.h&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;SEEK_SET&lt;/code&gt; = offset relative to the beginning of the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEEK_CUR&lt;/code&gt; = offset relative to the current position in the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEEK_END&lt;/code&gt; = offset relative to the end of the file&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long ftell(FILE* stream)&lt;/code&gt; → may be used to get the current position in the file relative to the beginning of the file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Slides 17-19 provide code examples for reading/writing a file.
&lt;/p&gt;

&lt;p&gt;
A few other interesting functions in regards to files are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int feof(FILE* stream)&lt;/code&gt; returns a value ≠ 0 when at the end of the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int ferror(FILE* stream)&lt;/code&gt; returns a value ≠ 0 when an file error has occured before&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int flush(FILE* stream)&lt;/code&gt; forces a physical write (emptying the cache)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int remove(char* name)&lt;/code&gt; deletes the file with a name of &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org521016c" class="outline-4"&gt;
&lt;h4 id="org521016c"&gt;Files in Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org521016c"&gt;
&lt;p&gt;
F21
A file is a data type in Python. A data variable is created via &lt;code&gt;f = open(filename[, mode[, bufsize]])&lt;/code&gt; .
The possible modes are a superset of the modes we know from C and with &lt;code&gt;bufsize&lt;/code&gt; the cache size for the file can be set.
This is the Python 3 &lt;a href="https://docs.python.org/3/library/functions.html#open"&gt;documentation&lt;/a&gt; for &lt;code&gt;open&lt;/code&gt; (which looks kinda different than the slides).
&lt;/p&gt;

&lt;p&gt;
Here are a few common file operations in Python (&lt;code&gt;file&lt;/code&gt; be a data variable):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;S = file.read()&lt;/code&gt; reads the whole file into a single string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S = file.read(N)&lt;/code&gt; reads &lt;code&gt;N&lt;/code&gt; bytes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S = file.readline()&lt;/code&gt; reads the next line (until new line char)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L = file.readlines()&lt;/code&gt; reads the whole file as a list of line strings&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.write(S)&lt;/code&gt; writes the string &lt;code&gt;S&lt;/code&gt; into the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.writeLines(L)&lt;/code&gt; writes all strings in a list &lt;code&gt;L&lt;/code&gt; into the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.close()&lt;/code&gt; closes the file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Using iterations it is easy to work with a whole file in Python:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
And Python provides more modules for file manipulations
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;module &lt;code&gt;os&lt;/code&gt; for low level&lt;/li&gt;
&lt;li&gt;module &lt;code&gt;shelve&lt;/code&gt; and &lt;code&gt;pickle&lt;/code&gt; for high level storage of complex objects&lt;/li&gt;
&lt;li&gt;module &lt;code&gt;dbm&lt;/code&gt; and &lt;code&gt;anydbm&lt;/code&gt; for database interfaces&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgd886a42" class="outline-3"&gt;
&lt;h3 id="orgd886a42"&gt;Simple Search&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd886a42"&gt;
&lt;p&gt;
Now with our newly acquired knowledge about files we can start looking into text search.
&lt;/p&gt;

&lt;p&gt;
Our program should take the following parameters:
&lt;code&gt;./search &amp;lt;searchText&amp;gt; &amp;lt;fileName&amp;gt;&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
And if the search text is found in the file, then the "surrounding" in which it was found should be returned, while the search text is wrapped in brackets to accentuate, eg
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./search &lt;span class="s2"&gt;"example"&lt;/span&gt; lorem.txt

ullamcoprer subsciptit nisl ut aliqup &lt;span class="o"&gt;[&lt;/span&gt;example&lt;span class="o"&gt;]&lt;/span&gt; ea commodano
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
One of the first problems we encounter is that we don't know the size/length of neither a line nor the whole file. Here a few solution approaches:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Approach 1: define a line buffer that is "sufficiently large" for all cases → not safe and not a good approach in general&lt;/li&gt;
&lt;li&gt;Approach 2: don't always read in whole lines → complicates the search if the search text is between two read-in blocks&lt;/li&gt;
&lt;li&gt;Approach 3: determine the file size, dynamically reserve space and read in the whole file → requires a lot of memory storage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We go with approach 3 since it also offers speed advantages.
&lt;/p&gt;

&lt;p&gt;
So let's determine the file size first - how do we do that?
The unix C function &lt;code&gt;int stat(char* name, struct stat* buf)&lt;/code&gt; which writes informations about the file &lt;code&gt;name&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt; is not compatible so we don't use it and instead rely on using a combination of functions from the standard library:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;filesize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;fseek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SEEK_END&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// offset the file position pointer by 0 bytes relative to the eof&lt;/span&gt;
  &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ftell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// get the current position relative to the beginning of the file&lt;/span&gt;
  &lt;span class="n"&gt;rewind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// move the file position pointer back to the beginning of the file&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
By the way &lt;code&gt;size_t&lt;/code&gt; is an OS dependant unsigned integer type that can store the maximum &lt;i&gt;size&lt;/i&gt; of a theoretically possible object of any type (including array) and which is commonly used for array indexing and loop counting (Programs that use other types, such as &lt;code&gt;unsigned int&lt;/code&gt;, for array indexing may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;UINT_MAX&lt;/code&gt; or if it relies on 32-bit modular arithmetic.).
&lt;/p&gt;

&lt;p&gt;
And this will be our main function which uses our &lt;code&gt;filesize&lt;/code&gt; function amongst other things:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// wrong number of params&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// open file&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// cant open file&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filesize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* allocate size+1 (for terminating 0) memory for our file buffer */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// out of memory&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="cm"&gt;/* read one element of size 'size' into our text buffer (the whole file) */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// can't read file&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// set the terminating 0;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// yet to implement!&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;presentResult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// dito!&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This main function does the necessary preparations for the actual search. Besides the search function we also need a function for the presentation/output. We want to output 20 characters before and after the search string:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;presentResult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// pos is the start of match position, str is the file buffer and pattern our search text&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;patlen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prelen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// output beginning&lt;/span&gt;

  &lt;span class="n"&gt;prelen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// beginning of match&lt;/span&gt;
  &lt;span class="n"&gt;patternLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// yet to implement!&lt;/span&gt;

  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;patternLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%.*s[%s]%.20s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prelen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As seen in the code listing above we also need a function to determine the length of a string. There's an function for that in the standard library but we'll use our own:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now we can finally turn our attention to the actual search algorithm. The idea is that we want to test for each position in the text &lt;code&gt;str&lt;/code&gt;, if the searchstring &lt;code&gt;p&lt;/code&gt; begins there. If that is the case, then we want to test the next character and so on..
&lt;/p&gt;

&lt;p&gt;
Here's the pseudocode:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// str is file/text buffer and p is search string&lt;/span&gt;
&lt;span class="nl"&gt;Require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nl"&gt;Ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;appearance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;

&lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;SIMPLE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;SEARCH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="c1"&gt;// found 1st occ of search string&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;
      &lt;span class="n"&gt;endif&lt;/span&gt;
      &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;
    &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"not found"&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
The actual C implemenation is where we'll continue in the next lecture (19), have a nice day (◕‿‿◕)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-18/</guid><pubDate>Thu, 06 Dec 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 17</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-17/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orged82e2d" class="outline-2"&gt;
&lt;h2 id="orged82e2d"&gt;Recursion and Backtracking&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orged82e2d"&gt;
&lt;p&gt;
Recursion was already covered in previous lectures so you can find additional informations in those blog posts. Now we want to discuss one difference between &lt;i&gt;loops&lt;/i&gt; and &lt;i&gt;recursion&lt;/i&gt; and therefore we turn our attention to the datastructure &lt;b&gt;stack&lt;/b&gt; which is used in many CPU's.
The stack is a container for holding data and there are two operations associated with it:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;push&lt;/b&gt; → &lt;code&gt;push(D, S)&lt;/code&gt; adds a data element &lt;code&gt;D&lt;/code&gt; on top of the stack &lt;code&gt;S&lt;/code&gt; (and 'overlays' the other elements in S)
&lt;ul class="org-ul"&gt;
&lt;li&gt;usually returns the modified stack &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;pop&lt;/b&gt; → &lt;code&gt;pop(S)&lt;/code&gt; the topmost and only visible element in &lt;code&gt;S&lt;/code&gt; get's removed from the top of the stack and allows access to next element below it
&lt;ul class="org-ul"&gt;
&lt;li&gt;usually returns the removed element &lt;code&gt;D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A simple hardware implementation is achieved via a &lt;i&gt;stack pointer&lt;/i&gt; that always points to the top of the stack (the topmost element). &lt;a href="http://cryptroix.com/2016/10/16/journey-to-the-stack/"&gt;Here's&lt;/a&gt; an in depth explanation and a shorter post can be found &lt;a href="https://learn1.open.ac.uk/mod/oublog/viewpost.php?post=162710"&gt;here&lt;/a&gt;. 
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/call-stack.png" alt="nil"&gt;
Cite from the second link:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
When a call is made one method of passing arguments to a function is to push the data onto the stack along with the address of the program statement execution must return to when the function has completed its work. This stack is referred to as the &lt;b&gt;call stack&lt;/b&gt; or sometimes the machine stack. A specific CPU register, the &lt;b&gt;stack pointer (SP)&lt;/b&gt;, may be provided to manage it. In this case a call function instruction says: push the return onto the stack and jump to the function address, making that part of the pushing automatic.
&lt;/p&gt;

&lt;p&gt;
In the majority of cases the call stack grows downwards in memory giving local variables a positive offset from the SP. The SP points to the last element put on the stack not the next free space so it is decremented down before data is pushed on. It is usual to discuss the depth of function calls meaning the number of calls made before a return starts the climb back up to calls higher in the calling hierarchy. An upside down stack fits well with this view: 
&lt;/p&gt;

&lt;p&gt;
When called the first action function code takes is to push the old value of another CPU register, the &lt;b&gt;frame pointer (FP)&lt;/b&gt;, onto the stack. The current value of the SP is then stored in the FP allowing modification of the SP to make space on the stack for any additional local variables the function has. 
&lt;/p&gt;

&lt;p&gt;
On a return from a function the value of the SP is restored from the FP and the FP gets its old value back, popped off the stack. Lastly, a return instruction in the machine code tells the CPU to send execution back to the instruction address stored on the stack by the call and currently referenced by the SP. Thus the FP and the SP work together to walk up and down the stack. 
&lt;/p&gt;

&lt;p&gt;
The blocks of memory on the call stack for each individual function call are &lt;b&gt;stack frames&lt;/b&gt;.  Function local variables that cannot be held in registers because they are too big to fit or because those registers may be used by the callee when that function calls another function are put on the stack. Large return items can be passed back on the stack but more usually the return or a reference to it is passed in a CPU register. Thus the availability of this storage space makes nested function calls possible.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;

&lt;div id="outline-container-org05f5507" class="outline-4"&gt;
&lt;h4 id="org05f5507"&gt;Recursion vs Iteration&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org05f5507"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Recursion&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Iteration&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;recursive calls of a subroutine(Unterprogramm)&lt;/td&gt;
&lt;td class="org-left"&gt;execution of a set of instructions of an iteration step&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;parameters of the subroutine are modified and tested for a break condition&lt;/td&gt;
&lt;td class="org-left"&gt;iterations usually limited via counter variable or a set&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;processed elements are stored implicitly on the stack (subroutine params)&lt;/td&gt;
&lt;td class="org-left"&gt;processed elements elements have to be stored explicitly&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;access to elements is limited to current component in the active subroutine&lt;/td&gt;
&lt;td class="org-left"&gt;access to elements is arbitrary&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;corresponds to the function model&lt;/td&gt;
&lt;td class="org-left"&gt;corresponds to the state model&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd8f762a" class="outline-3"&gt;
&lt;h3 id="orgd8f762a"&gt;Design of Recursive Algorithms&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd8f762a"&gt;
&lt;p&gt;
There are at least two cases which have to be handled in every recursive algorithm
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;exit/break from the recursion&lt;/li&gt;
&lt;li&gt;recursive call&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In general there are two approache to craft recursive algorithms:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;abstraction&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;drafting of a specific solution to a specific problem instances → draft more solutions and make use of the ones already existing → recognize similarities → encapsulate/summarize those to a universal solution (&lt;b&gt;abstraction&lt;/b&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;leap of faith&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;assumption that the function/procedure is already working and use that for a smaller subproblem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org53e9706" class="outline-4"&gt;
&lt;h4 id="org53e9706"&gt;Fibonacci Numbers&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org53e9706"&gt;
&lt;p&gt;
We already got to know the Fibonacci Numbers previously:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Computes the n-th fibonacci number&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;b&gt;Regularity&lt;/b&gt; (Regelmäßigkeit):&lt;br&gt;
We can recognize that the next element in the fibonacci sequence is the sum of the previous both fibonacci numbers. So \(a_{n+2} = a_n  + a_{n+1}\). 
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Defaults&lt;/b&gt; (Standardfolge):&lt;br&gt;
We set a&lt;sub&gt;0&lt;/sub&gt; = 0 and a&lt;sub&gt;1&lt;/sub&gt; = 1 and get the following sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
&lt;/p&gt;

&lt;p&gt;
However the fibonacci sequence is an example where recursion should not be used since the call stack will get pretty large and it is totally solvable with iterations.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Computes the n-th fibonacci number&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fnum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fnum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The complexity of this solution with a loop is \(\Theta(n)\), while the complexity of the solution with recursion was \(\Theta(c^n)\) with c &amp;gt; 1.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org496eb95" class="outline-4"&gt;
&lt;h4 id="org496eb95"&gt;Towers of Hanoi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org496eb95"&gt;
&lt;p&gt;
Now we'll turn our attention to a problem which can be well represented with recursion to demonstrate the principle of solutions. The &lt;i&gt;tower of hanoi&lt;/i&gt; is a mathematical game/puzzle consisting of three rods and a number of differently sized disk on one rod which can slide onto any rod under the following rules:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;only one disk can be moved at a time&lt;/li&gt;
&lt;li&gt;each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or an empty rod&lt;/li&gt;
&lt;li&gt;no larger disk may be placed on top of a smaller disk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is the pseudo code to solve the towers of hanoi:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tower&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;place&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nl"&gt;ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tower&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;place&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;obey&lt;/span&gt; &lt;span class="n"&gt;rules&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;MOVE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TOWER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;goal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;
  &lt;span class="n"&gt;MOVE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TOWER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aux_place&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// auxiliary place/Hilfsplatz&lt;/span&gt;
  &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;last_ring&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;goal&lt;/span&gt;
  &lt;span class="n"&gt;MOVE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;TOWER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;goal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Move part of the tower with height n-1 from the start rod to the auxiliary rod (via the goal rod)&lt;/li&gt;
&lt;li&gt;Move the last/bottom disk from the start rod to the goal rod&lt;/li&gt;
&lt;li&gt;Move part of the tower with height n-1 from the auxiliary rod to the goal road (via the start rod)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
→ The minimal number of moves required to solve a Tower of Hanoi puzzle is 2&lt;sup&gt;n&lt;/sup&gt; - 1, where n is the number of disks.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge8dbbac" class="outline-3"&gt;
&lt;h3 id="orge8dbbac"&gt;Backtracking&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge8dbbac"&gt;
&lt;p&gt;
To illustrate an use case for &lt;i&gt;backtracking&lt;/i&gt; we'll turn our attention to the &lt;i&gt;Eight Queens Puzzle&lt;/i&gt; (Damenproblem), which is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general n queens problem of placing n non-attacking queens on an n×n chessboard, for which solutions exist for all natural numbers n with the exception of n=2 and n=3.
&lt;/p&gt;

&lt;p&gt;
A general algorithmic approach to get a solution could look like this:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Put a queen in the the first row and first column&lt;/li&gt;
&lt;li&gt;Put another quuen in the next row and in the first column&lt;/li&gt;
&lt;li&gt;Move the the second queen right until she's in an allowed position (not possible to be attacked)&lt;/li&gt;
&lt;li&gt;Repeat from Step 2 until:
&lt;ul class="org-ul"&gt;
&lt;li&gt;all 8 Queens are placed → Solution&lt;/li&gt;
&lt;li&gt;no valid field can be found in the row for a queen → if this is the case then the &lt;i&gt;previous&lt;/i&gt; queen is treated as invalid as well so that that one is moved right as well (when there is no valid position for the previous queen, then the queen previous to the previous one will be moved in search for a new valid place further to the right and so on…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
This approach where a partial solution is discarded to continue with a previous partial solution is called &lt;b&gt;backtracking&lt;/b&gt;. 
&lt;/p&gt;

&lt;p&gt;
From wikipedia: 
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
&lt;/p&gt;

&lt;p&gt;
The classic textbook example of the use of backtracking is the eight queens puzzle, that asks for all arrangements of eight chess queens on a standard chessboard so that no queen attacks any other. In the common backtracking approach, the partial candidates are arrangements of k queens in the first k rows of the board, all in different rows and columns. Any partial solution that contains two mutually attacking queens can be abandoned.
&lt;/p&gt;

&lt;p&gt;
Backtracking can be applied only for problems which admit the concept of a "partial candidate solution" and a relatively quick test of whether it can possibly be completed to a valid solution. It is useless, for example, for locating a given value in an unordered table. When it is applicable, however, backtracking is often much faster than brute force enumeration of all complete candidates, since it can eliminate a large number of candidates with a single test.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
If the backtracking has to be done until before the first queen then there is no solution. Backtracking is often used together with recursion but is however an indepent principle.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/backtracking.png" alt="nil"&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/backtracking-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The above solution is not the only one. If there's a need for more (or all) solutions, they have to be saved and then backtracking needs to be triggered.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Look at chapter 9 slides 31f. for a pseudo code and C implementation of the 8x8 queens problem&lt;/b&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-17/</guid><pubDate>Sun, 02 Dec 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 15 &amp; 16</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-15-16/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
This blog post contains the material covered in lecture 15 and 16 because it is the same subject and it does not make sense to split it :P.
&lt;/p&gt;

&lt;div id="outline-container-orgd96ab9c" class="outline-2"&gt;
&lt;h2 id="orgd96ab9c"&gt;Complexity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd96ab9c"&gt;
&lt;p&gt;
As you've hopefully already noticed there are algorithms that differ in regards to &lt;i&gt;efficiency&lt;/i&gt;. &lt;b&gt;Algorithmic efficiency&lt;/b&gt; refers to the number of &lt;b&gt;computational resources&lt;/b&gt; (&lt;i&gt;computation time&lt;/i&gt; and &lt;i&gt;memory space&lt;/i&gt;) used by the algorithm.
&lt;/p&gt;

&lt;p&gt;
For maximum efficiency we wish to minimize resource usage. However, different resources such as time and space complexity cannot be compared directly, so which of two algorithms is considered to be more efficient often depends on which measure of efficiency is considered most important.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfe55b46" class="outline-3"&gt;
&lt;h3 id="orgfe55b46"&gt;RAM Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfe55b46"&gt;
&lt;p&gt;
It is impractical to measure the computation time with a stopwatch or operating system functions because then there'd be a lot of other factors involved such as compiler, hardware and operating system.
&lt;/p&gt;

&lt;p&gt;
But to measure the quality of &lt;i&gt;algorithms&lt;/i&gt; (not their implementation) we don't even need a time because we use &lt;i&gt;abstract computer models&lt;/i&gt;. For example the &lt;b&gt;Random Access Machine&lt;/b&gt; (RAM model) which is used for computational complexity analysis.
&lt;/p&gt;

&lt;p&gt;
RAM Components:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;program&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;numbered, finite series of instructions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;storage&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;enumerable (infinite) amount of storage locations(registers) (slides: abzählbar (unendlich) viele Speicherstellen (Register))&lt;/li&gt;
&lt;li&gt;arbitrarily accessible&lt;/li&gt;
&lt;li&gt;every register can store an arbitrary integer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;in-/output&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;continuous sequences (bänder, ribbons)&lt;/li&gt;
&lt;li&gt;either input (read) or output (write) in the given situation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;central processing unit
&lt;ul class="org-ul"&gt;
&lt;li&gt;instruction counter that holds the number of the instruction that is to be executed&lt;/li&gt;
&lt;li&gt;accumulator = target register of computations, address 0&lt;/li&gt;
&lt;li&gt;arithmetic logic unit = enginge / functional unit for execution of operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/random-access-machine.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The "common/usual" instructions are available in a RAM:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;basic arithmetic operations: + - * / mod&lt;/li&gt;
&lt;li&gt;comparisons: &amp;gt; &amp;lt; = ≥ ≤&lt;/li&gt;
&lt;li&gt;branching/conditions: if&lt;/li&gt;
&lt;li&gt;jumps : GOTO (loops are branches with jumps btw)&lt;/li&gt;
&lt;li&gt;loading/storing: LOAD, STORE&lt;/li&gt;
&lt;li&gt;in-/output: READ, WRITE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Operands:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;registers (can be chosen arbitrarily), also indirectly&lt;/li&gt;
&lt;li&gt;accumulator (implicit)&lt;/li&gt;
&lt;li&gt;input sequence and output sequence (not arbitrarily ~ nicht wahlfrei)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
For the RAM there are two models of measuring the time cost:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;uniform cost measure: every instruction has a time cost of 1 time unit (eg Takt/clock signal or millisecond ..)
&lt;ul class="org-ul"&gt;
&lt;li&gt;since every instruction has the same length/duration the instrucion &lt;b&gt;executions&lt;/b&gt; are determining the cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;logarithmic time cost measure: the length of the numbers that have to be processed determine the time
&lt;ul class="org-ul"&gt;
&lt;li&gt;length l(x) of x ∈ G:  l(0) = 1, l(x) = (log&lt;sub&gt;2&lt;/sub&gt; |x|) + 1&lt;/li&gt;
&lt;li&gt;the logarithmic time costs of an instruction are equal to the sum of the length of the numbers that have to be processed&lt;/li&gt;
&lt;li&gt;the logarithmic time cost measure should be usend when the size/length of the numbers is of critical significance&lt;/li&gt;
&lt;li&gt;in addition to the instruction executions the size of the operands is of importance in regards to the cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Instructions that are executed in a loop are counted repeatedly and since the execution of instructions (and loop iterations) often depends on the input size n we measure the amount of instructions that are executed with T&lt;sub&gt;A&lt;/sub&gt;(n), for example:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Algorithm&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;T&lt;sub&gt;A&lt;/sub&gt;(n)&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;optimal for&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;A&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;1000 * n&lt;/td&gt;
&lt;td class="org-left"&gt;n ≥ 101&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;200*n*log n&lt;/td&gt;
&lt;td class="org-left"&gt;never&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;A&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;10 * n&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;10 ≤ n ≤ 100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;A&lt;sub&gt;4&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;1 ≤ n ≤ 9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgea74082"&gt;&lt;/a&gt;Run-time Analysis&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgea74082"&gt;
&lt;p&gt;
Even for constant \(n\) is T&lt;sub&gt;A&lt;/sub&gt; not always the same:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;worst case analysis
&lt;ul class="org-ul"&gt;
&lt;li&gt;for every n define the runtime as T(n) = max(t(Input)), ∀ |Input| = n&lt;/li&gt;
&lt;li&gt;guaranteed boundaries for every input&lt;/li&gt;
&lt;li&gt;used as standard&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;average case analysis
&lt;ul class="org-ul"&gt;
&lt;li&gt;for every n define the runtime as T(n) = \(\bar{t}\)(Input) ∀ |Input| = n&lt;/li&gt;
&lt;li&gt;depends on the definition of average → distribution of inputs&lt;/li&gt;
&lt;li&gt;rarely used (hard to determine the average)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;best case analysis
&lt;ul class="org-ul"&gt;
&lt;li&gt;for every n define the runtime as T(n) = min(t(Input)), ∀ |Input| = n&lt;/li&gt;
&lt;li&gt;looks for minimal runtime&lt;/li&gt;
&lt;li&gt;shows design mistakes (Entwurfsfehler)&lt;/li&gt;
&lt;li&gt;has no real significance (easy to cheat)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In general the analysis of T&lt;sub&gt;A&lt;/sub&gt; is rather hard that's why &lt;i&gt;order of magnitudes&lt;/i&gt; (Größenordnungen) are used more commonly. We know such from real life eg: v&lt;sub&gt;Laufen&lt;/sub&gt; &amp;lt; v&lt;sub&gt;Rad&lt;/sub&gt; &amp;lt; v&lt;sub&gt;Auto&lt;/sub&gt; &amp;lt; v&lt;sub&gt;Flugzeug&lt;/sub&gt; 
&lt;/p&gt;

&lt;p&gt;
Note: I skipped the slides on "big A notation" here because I fail to see the relevance of it and cant find anything about in the internet (slides 14-15, chapter 8).
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge232fb0" class="outline-2"&gt;
&lt;h2 id="orge232fb0"&gt;Big O Notation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge232fb0"&gt;
&lt;p&gt;
Often times the &lt;b&gt;growth rate&lt;/b&gt; of algorithms/function is of interest. The &lt;b&gt;big-O notation&lt;/b&gt; is commonly used to describe how a function grows. A common goal is to find algorithms/functions that are still efficient for large problem instances (inputs) and if that is the case we usually say that they scale good. Two functions eg \(f(n)\) and \(g(n)\) have the same growth rate when the ratio for a sufficient amount of \(n\) is limited by the same constant upper and lower boundaries (slides: Zwei Funktionen f(n) und g(n) haben das gleiche Wachstumsverhalten, falls für genügend große n das Verhältnis der beiden nach oben und unten durch Konstanten beschränkt ist), which means that \(c &amp;lt; \frac{f(n)}{g(n)} and \frac{g(n)}{f(n)}\) needs to be true.
For example:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;\(f_1(n)=n^2\) and \(f_2(n)=5*n^2-7*n\) have the &lt;b&gt;same grow&lt;/b&gt; because for all \(n &amp;gt; 2\) the following applies: \(\frac{1}{5} &amp;lt; \frac{(5n^2-7n)}{n^2} &amp;lt; 5\) and \(\frac{1}{5} &amp;lt; \frac{n^2}{(5n^2-7n)} &amp;lt; 5\)&lt;/li&gt;
&lt;li&gt;\(f_1(n)=n^2\) and \(f_2(n)=n^3\) do &lt;b&gt;not have the same grow&lt;/b&gt; because for all sufficient large \(n\) (hinreichend groß) the following applies \(\frac{n^3}{n^2} = n &amp;gt; c\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The big O notation (big O refers to the greek letter omikron) is also called &lt;b&gt;Landau Notation&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Big O Notation can also be used to state which function dominates the growth. For two monotone function f(n) and g(n) the function f(n) dominates the function g(n) if \(g(n) \in \mathcal{O}(f(n))\). The notation \(dom(f(n),g(n))\) yields the dominating function. For example
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;dom(n&lt;sup&gt;3&lt;/sup&gt;, n&lt;sup&gt;2&lt;/sup&gt;) = n&lt;sup&gt;3&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;dom(2&lt;sup&gt;n&lt;/sup&gt;, n&lt;sup&gt;k&lt;/sup&gt;) = 2&lt;sup&gt;n&lt;/sup&gt; (for constant k &amp;gt; 1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are also some computation rules (Rechenregeln) when it comes to big O:
\[
\mathcal{O}(f(n)) + \mathcal{O}(g(n)) = \mathcal{O}(f(n) + g(n))\\
\mathcal{O}(f(n) + g(n)) = \mathcal{O}(dom(f(n), g(n)))\\
\mathcal{O}(f(n)) * \mathcal{O}(g(n)) = \mathcal{O}(f(n) * g(n))
\]
&lt;/p&gt;

&lt;p&gt;
These are some common types/classes of functions in regards to big O:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Notation&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Term&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Typical Algorithms/Operations&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;O(1)&lt;/td&gt;
&lt;td class="org-left"&gt;constant&lt;/td&gt;
&lt;td class="org-left"&gt;addition, comparisons, recursive call&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(log n)&lt;/td&gt;
&lt;td class="org-left"&gt;logarithmic&lt;/td&gt;
&lt;td class="org-left"&gt;search in a sorted sequence&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n)&lt;/td&gt;
&lt;td class="org-left"&gt;linear&lt;/td&gt;
&lt;td class="org-left"&gt;modifying each element of a set&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n * log n)&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt;good sorting algorithm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n * log n)&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt;good sorting algorithms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n * log&lt;sup&gt;2&lt;/sup&gt; n)&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt;good sorting algorithms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;…&lt;/td&gt;
&lt;td class="org-left"&gt;….&lt;/td&gt;
&lt;td class="org-left"&gt;…&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td class="org-left"&gt;quadratic&lt;/td&gt;
&lt;td class="org-left"&gt;primitive sorting algorithms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(n&lt;sup&gt;k&lt;/sup&gt;), k &amp;gt;= 2&lt;/td&gt;
&lt;td class="org-left"&gt;polynomial&lt;/td&gt;
&lt;td class="org-left"&gt;primitive sorting algorithms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;…&lt;/td&gt;
&lt;td class="org-left"&gt;…&lt;/td&gt;
&lt;td class="org-left"&gt;…&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(2&lt;sup&gt;n&lt;/sup&gt;)&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt;trying combinations&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;O(k&lt;sup&gt;n&lt;/sup&gt;), k &amp;gt; 1&lt;/td&gt;
&lt;td class="org-left"&gt;exponential&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The O(n)-notation depends on the size of the input, that is the storage space in bits or words. 
&lt;/p&gt;

&lt;p&gt;
In addition to the most common big O notation there are several related notations to describe other kinds of bounds on asymptotic growth rates:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;big Omega notation \(\Omega(f(n)) = {g(n) \exists c &amp;gt; 0, \exists n_0 &amp;gt;0, \forall n &amp;gt; n_0, g(n) \geq c * f(n)}\) → lower boundary / "mindestens"&lt;/li&gt;
&lt;li&gt;big Theta notation \(\Theta(f(n)) = \mathcal{O}(f(n)) \cap \Omega(f(n))\) → exactly / "genau"&lt;/li&gt;
&lt;li&gt;little o notation \(o(f(n)) = {g(n) | \forall c &amp;gt; 0, \exists n_0 &amp;gt; 0, \forall n &amp;gt; n_0, g(n) \leq c*f(n)}\) → at max / "weniger"&lt;/li&gt;
&lt;li&gt;little omega notation \(o(f(n)) = {g(n) | \forall c &amp;gt; 0, \exists n_0 &amp;gt; 0, \forall n &amp;gt; n_0, g(n) \geq c*f(n)}\) →  "mehr"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
What followed in the slides are some example computation times for different complexities and algorithms.
&lt;/p&gt;

&lt;p&gt;
Take for example the algorithm to search the minimum in a sequence:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;sequence&lt;/span&gt; &lt;span class="n"&gt;a_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="n"&gt;a_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nl"&gt;ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_1&lt;/span&gt;&lt;span class="p"&gt;,...,&lt;/span&gt; &lt;span class="n"&gt;a_n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;a_1&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a_i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;a_i&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In the above example the complexities are \(\mathcal{O}(n)\), Ω (n) and Θ (n).
&lt;/p&gt;

&lt;p&gt;
Take a look at the lecture slides (chapter 8) from slide 26 to see some more examples.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1c4b604" class="outline-4"&gt;
&lt;h4 id="org1c4b604"&gt;Better Sorting&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1c4b604"&gt;
&lt;p&gt;
The sorting algorithms we saw so far (bubble sort and insertion sort) have a complexity in \(\mathcal{O}(n^2)\). Quicksort and Mergesort are generally better sorting algorithms. Let's look at quicksort:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;e_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="n"&gt;e_n&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nl"&gt;ensure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;e_i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;e_&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// sorted sequence condition &lt;/span&gt;

&lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;QSORT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;

  &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="s"&gt;"pivot"&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;

  &lt;span class="n"&gt;less&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="n"&gt;greater&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;"pivot"&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;append&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
      &lt;span class="n"&gt;append&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;greater&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;concatenate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QSORT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QSORT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Because of the built-in list type a quicksort implementation in Python is pretty easy:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;[]:&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
	&lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
	&lt;span class="n"&gt;less&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
	&lt;span class="n"&gt;greater&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
	&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]:&lt;/span&gt;
	    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
[2, 7, 8, 9, 54]

&lt;/pre&gt;

&lt;p&gt;
The depth of the recursion in quick sort is not set in stone. How does the worse case look? The pivot element is always the smallest or largest element in the list so the recursion depth is n - 1 (why?). On each recursion call \(i = |array| - 1\) elements are handled  which results in a recursion depth of n - recursion depth. 
In the worst case the complexity would be Θ(n&lt;sup&gt;2&lt;/sup&gt;) so it wouldn't &lt;b&gt;always&lt;/b&gt; be better than eg bubble sort! In such situation it makes sense to look at the average case (see slide 35 for that).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgde57488" class="outline-4"&gt;
&lt;h4 id="orgde57488"&gt;Space Complexity (Storage/Memory)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgde57488"&gt;
&lt;p&gt;
The required memory space is another critical resource in addition to the computation time. To measure this the same complexity measures are used. Let's look at the required storage space complexity for quicksort:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;new arrays are created on each recursion&lt;/li&gt;
&lt;li&gt;the required storage space is \(n\) in every recursion depth&lt;/li&gt;
&lt;li&gt;the maximum recursion depth is \(n-1\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
→ storage complexity of quicksort is \(\mathcal{O}(n^2)\).
&lt;/p&gt;

&lt;p&gt;
However a storage complexity of \(\mathcal{O}(n)\) is achievable via a smart quicksort implementation by using &lt;i&gt;in place&lt;/i&gt; mutations. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-15-16/</guid><pubDate>Sun, 25 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 14</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-14/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org6e8cbea" class="outline-2"&gt;
&lt;h2 id="org6e8cbea"&gt;Design and Correctness of Algorithms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6e8cbea"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org53555a0" class="outline-3"&gt;
&lt;h3 id="org53555a0"&gt;Pseudocode&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org53555a0"&gt;
&lt;p&gt;
As we've learnt in the last lecture &lt;i&gt;pseudocode&lt;/i&gt; is one of the most popular semiformal specification languages.
&lt;/p&gt;

&lt;p&gt;
Pseudocode generally defines a set of instructions, there are no strict rules on how pseudocode needs to look like, therefore there are many forms of it, which is okay as long as it is intuitively readable.
&lt;/p&gt;

&lt;p&gt;
Example pseudocode for the Euclidian Algorithm:
&lt;/p&gt;

&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;Require:&lt;/b&gt; A, B ∈ N, A &amp;gt; 0 ∩ B &amp;gt; 0&lt;br&gt;
&lt;b&gt;Ensure:&lt;/b&gt; a = b = gcd(A, B)&lt;br&gt;
a ← A; b ← B&lt;br&gt;
&lt;b&gt;while&lt;/b&gt; a ≠ b &lt;b&gt;do&lt;/b&gt;&lt;br&gt;
   &lt;b&gt;if&lt;/b&gt; a &amp;lt; b &lt;b&gt;then&lt;/b&gt;&lt;br&gt;
      b ← b - a&lt;br&gt;
   &lt;b&gt;else&lt;/b&gt;&lt;br&gt;
      a ← a - b&lt;br&gt;
   &lt;b&gt;end if&lt;/b&gt;&lt;br&gt;
&lt;b&gt;end while&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
The slides note at this point that in the future we'll often look at algorithms in pseudo code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9ee54eb" class="outline-3"&gt;
&lt;h3 id="org9ee54eb"&gt;Correctness&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9ee54eb"&gt;
&lt;p&gt;
When you find an approach for a problem / an algorithm, the &lt;i&gt;correctness&lt;/i&gt; has to be validated.
&lt;/p&gt;

&lt;p&gt;
It is advised to verify the correctness of the idea first and then the correctness of the concrete algorithm.
The correctness of an idea cannot be verified formally, but the following things should be pondered:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;does the idea work &lt;i&gt;in general&lt;/i&gt; or just for a &lt;i&gt;specific case&lt;/i&gt;?&lt;/li&gt;
&lt;li&gt;are there &lt;i&gt;special cases&lt;/i&gt; in which the idea does not work out? are these relevant?&lt;/li&gt;
&lt;li&gt;try finding an &lt;i&gt;counter-example&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;what about &lt;i&gt;extreme cases&lt;/i&gt;?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
What follows on slides 25-30 are some example problems and ideas to solve them, take a look there if you want.
&lt;/p&gt;

&lt;p&gt;
As stated before the correctness of the concrete algorithm also has to be validated. There are in general two ways to do this:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Exhaustive Testing&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;verify that there is no incorrect behaviour in the implementation of the algorithm by testing/executing it with all possible data inputs/combinations&lt;/li&gt;
&lt;li&gt;Problems:
&lt;ul class="org-ul"&gt;
&lt;li&gt;usually this is &lt;i&gt;impossible&lt;/i&gt; since the possible data combinations are really large or even infinite&lt;/li&gt;
&lt;li&gt;&lt;i&gt;partial testing&lt;/i&gt; may boost the confidence in regards to the correctness of a program/algorithm, but does not replace a proof&lt;/li&gt;
&lt;li&gt;a good selection of test cases is difficult&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Correctness Proof&lt;/b&gt; (Korrektheitsbeweis)
&lt;ul class="org-ul"&gt;
&lt;li&gt;verify correct behaviour via mathematical methods/proofs&lt;/li&gt;
&lt;li&gt;Problems:
&lt;ul class="org-ul"&gt;
&lt;li&gt;are difficult or impossible on the level of implementation because of lacking formalization&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
To proof the correctness it can be performed on a more &lt;i&gt;abstract level&lt;/i&gt; instead. Mistakes are then however possible when performing the concrete implementation. We'll continue to look at proofs and not tests.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org35c579b" class="outline-3"&gt;
&lt;h3 id="org35c579b"&gt;Proofs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org35c579b"&gt;
&lt;p&gt;
Slides: Informale Definition = Ein Beweis ist eine Herleitung einer Aussage aus bereits bewiesenen Aussagen und/oder Grundannahmen (Axiomen)
&lt;/p&gt;

&lt;p&gt;
We know a few different (but still combinable) methods for proofs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;deduction&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;classical proof via combination of premises&lt;/li&gt;
&lt;li&gt;eg: all humans are mortal(premise 1) &amp;amp; all kings are humans (premise 2) → all kings are mortal (conclusion/deduction)&lt;/li&gt;
&lt;li&gt;the correctness of the premises has to be given axiomatically or already been proven&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;complete case analysis/differentiation&lt;/b&gt; (vollständige Fallunterscheidung)
&lt;ul class="org-ul"&gt;
&lt;li&gt;when there are a finite amount of cases/variants then each one can be inspected individually&lt;/li&gt;
&lt;li&gt;if a statement is true for &lt;i&gt;every&lt;/i&gt; case/variant then the statement is true as a whole&lt;/li&gt;
&lt;li&gt;eg: "all odd integers in the intervall [2&lt;sup&gt;1&lt;/sup&gt;, 2&lt;sup&gt;3&lt;/sup&gt;] are prime numbers" (statement) → 3 is prime, 5 is prime, 7 is prime → statement is true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;complete /transfinite induction&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;base cases (Induktionsanker/-anfang IA) show that a statement is valid for a special (smallest/first) case (often \(n = 0\) or \(n = 1\))&lt;/li&gt;
&lt;li&gt;step case / inductive step (Induktionsschritt)
&lt;ul class="org-ul"&gt;
&lt;li&gt;assume that the statement holds true for \(n=k\) (Induktionsvoraussetzung IV) and prove that then the statements holds for \(n=k+1\); proof that the &lt;i&gt;induction hypothesis&lt;/i&gt; follows from the &lt;i&gt;induction requirement&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;Induktionsschluss → inference (Folgerung) that the statement holds for all cases starting at the first&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;indirect proof&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;assume the opposite of the hypothesis/statement and find a disproof via axioms and proven concepts → inference that the assumption is wrong and therefore the hypothesis/statment is true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb6ea655" class="outline-3"&gt;
&lt;h3 id="orgb6ea655"&gt;Proofs of Algorithms&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb6ea655"&gt;
&lt;p&gt;
To prove an algorithm you have to ask two questions. 1) What is there to be proven (Specification)? 2.) What is already known?
&lt;/p&gt;

&lt;p&gt;
A distinction is made between 2 kinds of "correctness":
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;partial correctness&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an algorithm is &lt;i&gt;partially correct&lt;/i&gt; if an answer is returned that this answer will be correct (slides: ein Algorithmus is partiell korrekt, wenn er für eine spezifizerte erfüllte Vorbedingung Q bei einer eventuellen/möglichen Terminierung eine spezifizerte Nachbedingung R erreicht, dh R is nach Ausführung erfüllt)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;total correctness&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;total correctness requires additionally to partial correctness that the algorithm &lt;b&gt;terminates&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
So, &lt;i&gt;if&lt;/i&gt; a partial correct algorithm terminates he yields a correct result and a total correct algorithm yields the correct result after a finite amount of time. 
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbcd9ec5" class="outline-4"&gt;
&lt;h4 id="orgbcd9ec5"&gt;Proving Sort Algorithms&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgbcd9ec5"&gt;
&lt;p&gt;
We already got to know a sorting algorithm in one of the first lectures (bubble sort). The correctness of a solution to the problem of sorting can be expressed independently from the algorithm: Input = sequence of elements (e&lt;sub&gt;1&lt;/sub&gt;, e&lt;sub&gt;2&lt;/sub&gt;, …, e&lt;sub&gt;n&lt;/sub&gt;) → Output = permutation (e'&lt;sub&gt;1&lt;/sub&gt;, e'&lt;sub&gt;2&lt;/sub&gt;, …, e'&lt;sub&gt;n&lt;/sub&gt;) of (e&lt;sub&gt;1&lt;/sub&gt;, e&lt;sub&gt;2&lt;/sub&gt;, …, e&lt;sub&gt;n&lt;/sub&gt;) so that e'&lt;sub&gt;1&lt;/sub&gt; ≤ e'&lt;sub&gt;2&lt;/sub&gt; ≤ … ≤ e'&lt;sub&gt;n&lt;/sub&gt;
&lt;/p&gt;

&lt;p&gt;
The bubble sort algorithm would look like this in pseudocode:
&lt;/p&gt;

&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;Require:&lt;/b&gt; e&lt;sub&gt;1&lt;/sub&gt;, …, e&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;
&lt;b&gt;Ensure:&lt;/b&gt; ∀ i ∈ {1, n-1}, e&lt;sub&gt;i&lt;/sub&gt; ≤ e&lt;sub&gt;i+1&lt;/sub&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;repeat&lt;/b&gt;&lt;br&gt;
  &lt;i&gt;changed&lt;/i&gt; ← false&lt;br&gt;
  &lt;b&gt;for&lt;/b&gt; &lt;i&gt;i&lt;/i&gt; ← 1, …, &lt;i&gt;n&lt;/i&gt;-1 &lt;b&gt;do&lt;/b&gt;&lt;br&gt;
   &lt;b&gt;if&lt;/b&gt; e&lt;sub&gt;i&lt;/sub&gt; &amp;gt; e&lt;sub&gt;i+1&lt;/sub&gt; &lt;b&gt;then&lt;/b&gt;&lt;br&gt;
    SWAP(e&lt;sub&gt;i&lt;/sub&gt;, e&lt;sub&gt;i+1&lt;/sub&gt;)&lt;br&gt;
    &lt;i&gt;changed&lt;/i&gt; ← true&lt;br&gt;
   &lt;b&gt;end if&lt;/b&gt;&lt;br&gt;
  &lt;b&gt;end for&lt;/b&gt;&lt;br&gt;
&lt;b&gt;until&lt;/b&gt; &lt;i&gt;changed&lt;/i&gt; = false&lt;br&gt;
 
Proving the &lt;i&gt;partial correctness&lt;/i&gt; is simple: If this algorithm terminates &lt;i&gt;changed&lt;/i&gt; has to be &lt;i&gt;false&lt;/i&gt; which implicates that for no i ∈ {1, …, n-1} this e&lt;sub&gt;i&lt;/sub&gt; &amp;gt; e&lt;sub&gt;i+1&lt;/sub&gt; can be true which in reverse means that ∀ i ∈ {1, …, n-1}, e&lt;sub&gt;i&lt;/sub&gt; ≤ e&lt;sub&gt;i+1&lt;/sub&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://en.wikipedia.org/wiki/Insertion_sort"&gt;&lt;i&gt;Insertion Sort&lt;/i&gt;&lt;/a&gt; is an alternative algorithm to solve the sorting problem. This is the corresponding pseudocode:
&lt;/p&gt;

&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;Require:&lt;/b&gt; e&lt;sub&gt;1&lt;/sub&gt;, …, e&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;
&lt;b&gt;Ensure:&lt;/b&gt; ∀ i ∈ {1, n-1}, e&lt;sub&gt;i&lt;/sub&gt; ≤ e&lt;sub&gt;i+1&lt;/sub&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;for&lt;/b&gt; j ← 2, …, n &lt;b&gt;do&lt;/b&gt;&lt;br&gt;
  &lt;i&gt;key&lt;/i&gt; ← e&lt;sub&gt;j&lt;/sub&gt;&lt;br&gt;
  &lt;i&gt;i&lt;/i&gt; ← j-1&lt;br&gt;
  &lt;b&gt;while&lt;/b&gt; (&lt;i&gt;i&lt;/i&gt; &amp;gt; 0) ∧ (e&lt;sub&gt;i&lt;/sub&gt; &amp;gt; key) &lt;b&gt;do&lt;/b&gt;&lt;br&gt;
   e&lt;sub&gt;i+1&lt;/sub&gt; ← e&lt;sub&gt;i&lt;/sub&gt;           ; move all elements that are greater than &lt;i&gt;key&lt;/i&gt; right&lt;br&gt;
   i ← i-1&lt;br&gt;
  &lt;b&gt;end while&lt;/b&gt;&lt;br&gt;
  e&lt;sub&gt;i&lt;/sub&gt;+1 ← key          ; fill the gap with &lt;i&gt;key&lt;/i&gt;&lt;br&gt;
&lt;b&gt;end for&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
Take a look at slides 47 - 50 (chapter 7) for details on how to prove the correctness of insertion sort with lemmas.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org77d2b4b" class="outline-3"&gt;
&lt;h3 id="org77d2b4b"&gt;Soundness (Korrektheitskalküle)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org77d2b4b"&gt;
&lt;p&gt;
Proofs like the one we saw for bubble sort are &lt;i&gt;ad hoc&lt;/i&gt;. There are/is a special logic/calculus (Kalküle → formales System zum Ziehen logischer Schlüsse) in regards to the correctness of programs, for example the &lt;b&gt;FLoyd-Hoare logic&lt;/b&gt; (Hoare-Kalkül) or the &lt;b&gt;wp-Kalkül&lt;/b&gt; (Edsger Dijkstra).
&lt;/p&gt;

&lt;p&gt;
These logics/calculus use triples: {Precondition} Code {Postcondition}. There are axiomatic rules: \frac{premise}{consequence}
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org89042db" class="outline-3"&gt;
&lt;h3 id="org89042db"&gt;Termination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org89042db"&gt;
&lt;p&gt;
&lt;b&gt;Partial Correctness&lt;/b&gt; is proven under the assumption that the code &lt;i&gt;terminates&lt;/i&gt;. Therefore termination has to be proven to prove &lt;b&gt;total correctness&lt;/b&gt;. This is especially critical when dealing with recursion (abort after finite steps and reach the recursion base) and loops (loop condition has to evaluate to false after finite steps and the loop body also has to terminate in each iteration).
&lt;/p&gt;

&lt;p&gt;
To prove termination of a loop a &lt;b&gt;termination function&lt;/b&gt; τ (Tau) has to be specified:
\[ \tau : V \rightarrow \mathbb{N} \]
&lt;/p&gt;

&lt;p&gt;
The termination function has to have the following characteristics:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;its values are natural numbers (including 0)&lt;/li&gt;
&lt;li&gt;each iteration resp. execution of the loop body &lt;b&gt;reduces&lt;/b&gt; its value (strictly monotonically decreasing)&lt;/li&gt;
&lt;li&gt;the loop condition is &lt;i&gt;false&lt;/i&gt; when τ = 0&lt;/li&gt;
&lt;li&gt;τ is the upper boundary for the loop iterations that are left&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
If a termination function is known a &lt;b&gt;termination rule&lt;/b&gt; can be used:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/termination-rule.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
So &lt;b&gt;if&lt;/b&gt; a termination function is &lt;i&gt;strictly monotonically decreasing&lt;/i&gt; &lt;b&gt;and&lt;/b&gt; the value 0 leads to the end of the loop &lt;b&gt;and&lt;/b&gt; the loop body terminates, &lt;b&gt;then&lt;/b&gt; the loop &lt;b&gt;terminates&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
So this has to be shown:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;strictly monotonically decrease of τ&lt;/li&gt;
&lt;li&gt;the implication that the loop condition B is not met at the lowest τ&lt;/li&gt;
&lt;li&gt;the termination of the body P&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Example of a termination function for a loop that calculates the square of a nonnegative integer:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* { Input: 0 &amp;lt;= a} */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* { Output: x = a^2} */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Pick the termination function τ = a - y
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;τ is decremented in each iteration, since 'y' is incremented and 'a' is constant&lt;/li&gt;
&lt;li&gt;if τ = 0 then y = a therefore the loop condition y != a evaluates to &lt;i&gt;false&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;the loop body does not contain recursions, gotos or other loops, termination is therefore trivial&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
→ The loop terminates!
&lt;/p&gt;

&lt;p&gt;
To prove the termination of recursions the same procedure as with loops can be applied. A termination function τ is created that gets smaller with increasing recursion depth. The following has to apply:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;the values are natural numbers (incl 0)&lt;/li&gt;
&lt;li&gt;the value of τ decreases with each method call (recursion)&lt;/li&gt;
&lt;li&gt;discontinuation is forced at τ = 0 (or earlier)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Fibonacci Example */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
However proving termination is not always possible (eg golbachs conjecture for expressing integers as sum of primes)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-14/</guid><pubDate>Fri, 23 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 13</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-13/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org8c4d7fa" class="outline-2"&gt;
&lt;h2 id="org8c4d7fa"&gt;Design and Correctness of Algorithms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8c4d7fa"&gt;
&lt;p&gt;
The first slides of this lecture chapter is just some meta information about the right mindset to create algorithms, which I find to be trivial, that's why I don't repeat that here (slides 1-5).
&lt;/p&gt;

&lt;p&gt;
We usually create a model for a problem (Modellierung) to abstract and reduce it. Especially mathematical concepts are suited as modeling approaches (Modellierungsansätze):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;sets, multisets&lt;/li&gt;
&lt;li&gt;permutations&lt;/li&gt;
&lt;li&gt;trees/hierarchies&lt;/li&gt;
&lt;li&gt;graphs&lt;/li&gt;
&lt;li&gt;points (geometry)&lt;/li&gt;
&lt;li&gt;polygons&lt;/li&gt;
&lt;li&gt;strings&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga3744c0" class="outline-3"&gt;
&lt;h3 id="orga3744c0"&gt;Excourse: Graphs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga3744c0"&gt;
&lt;p&gt;
Graphs are often used for modelling. A graph is a ordered pair \((V,E)\), where \(V\) is a set of nodes/vertices (Knoten) \(V = {v_1, v_2, v_3,.., v_n}\) and \(E\) is a set of edges (Kanten/Linien) \(E = {e_1, e_2, .., e_m}\). Depending on the type of graph, \(E\) is:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in &lt;b&gt;undirected*/*simple&lt;/b&gt; (ungerichtete) graphs &lt;b&gt;without multiple edges&lt;/b&gt; \(E\) is a &lt;b&gt;2-element subset&lt;/b&gt; of \(V\)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;directed&lt;/b&gt; (gerichteten) graphs &lt;b&gt;without multiple edges&lt;/b&gt; \(E\) is a &lt;b&gt;subset&lt;/b&gt; of all pairs/2-tuples (i,j) which result from the cartesian product of \(V * V\)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;undirected&lt;/b&gt; graphs with "zusammengefassten" &lt;b&gt;multiple edges&lt;/b&gt; (=Multigraph) \(E\) is a &lt;b&gt;multiset&lt;/b&gt; (Menge die Duplikate erlaubt) "über die Menge \(W\)" of all &lt;b&gt;2-element subsets&lt;/b&gt; of \(V\) (?weighted graph?)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;directed&lt;/b&gt; graphs with "zusammengefassten" &lt;b&gt;multiple edges&lt;/b&gt; (=Multigraph) \(E\) is a &lt;b&gt;multiset&lt;/b&gt;  "über dem kartesischen Produkt \(V * V\)" (?weighted graph?)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;hypergraphs&lt;/b&gt; \(E\) is a subset of the power set of \(V\)&lt;/li&gt;
&lt;li&gt;wiki: in gerichteten Graphen mit eigenständigen Mehrfachkanten eine beliebige Menge, deren Elemente mit Hilfe von zwei Funktionen {\displaystyle \mathrm {src} ,\mathrm {tgt} : E→ V} {\mathrm  {src}},{\mathrm  {tgt}}: E→ V die den Elementen einen Quell- bzw. Zielknoten zuordnen, als Kanten angesehen werden (so ein Graph ist dasselbe wie ein Funktor {\displaystyle G: {\mathcal {G}}→ \mathbf {Set} } G: {\mathcal  G}→ {\mathbf  {Set}}, wobei {\displaystyle {\mathcal {G}}} {\mathcal  G} die recht überschaubare Kategorie {\displaystyle {\mathcal {G}}=\{V{\stackrel {\mathrm {src} }{\longleftarrow }}E{\stackrel {\mathrm {tgt} }{\longrightarrow }}V\}} {\mathcal  G}=\{V{\stackrel  {{\mathrm  {src}}}\longleftarrow }E{\stackrel  {{\mathrm  {tgt}}}\longrightarrow }V\} mit zwei Objekten und zwei ausgezeichneten Pfeilen ist)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Slides: Kanten können Werte (Gewichte) zugewiesen werden, w : E → R. In diesem Fall spricht man von einem gewichteten Graph.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;i&gt;gerichteter&lt;/i&gt; Graph hat Pfeile an Kanten die die Richtung angeben&lt;/li&gt;
&lt;li&gt;&lt;i&gt;gewichteter&lt;/i&gt; Graph hat Werte an Kanten stehen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Two blog posts on graphs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8"&gt;https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38"&gt;https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The model of the graph is seperate of any concrete data structures. C for example does not have a built-in data type for graphs so you might need to implement one yourself. Furthermore just because a problem was modeled with a specific approach/model does not mean that a respective data structure is always needed to implement the approach.
&lt;/p&gt;

&lt;p&gt;
However if you find yourself in the need of such data structure there are a multitude of approaches to implement it such. Here are two:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;via &lt;b&gt;adjacency matrix&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;a square matrix to represent a finite graph&lt;/li&gt;
&lt;li&gt;the elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph&lt;/li&gt;
&lt;li&gt;in 2d array each element &lt;code&gt;a_{i,j}&lt;/code&gt; holds information weather or not an edge connects the vertices &lt;code&gt;v_i&lt;/code&gt; and &lt;code&gt;v_j&lt;/code&gt; or which weight the edge has:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// -&amp;gt; edge between verticle 0 and verticle 1 exists&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;via &lt;b&gt;structs and pointers&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;vertices can be modelled as structs and edges as pointers inside of those:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;node_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Since graph theory is a relatively old field of mathematics there are a lot of theorems, laws and standard algorithms for solving certain problems.
&lt;/p&gt;

&lt;p style="color:red;"&gt;
TODO check those code examples
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org38e59ea" class="outline-3"&gt;
&lt;h3 id="org38e59ea"&gt;Specification&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org38e59ea"&gt;
&lt;p style="color:red;"&gt;
TODO check those code examples
&lt;/p&gt;

&lt;p&gt;
An algorithm has to be described somehow. One variant to do so would be in a concrete programming language. The problem with that is that different programming languages know different concepts and no programming language knows all concepts. C for example does not know data types and operations for mathematical sets by itself. Set operations in C could therefore look a bit unclear and obfuscate (verschleiern) the underlying algorithm which is the real point of interest.
&lt;/p&gt;

&lt;p&gt;
A solution to this is writing algorithms in a &lt;i&gt;specification&lt;/i&gt; (Spezifikationsprachen) of which there are many (natural languages are too inprecise btw) when the algorithm itself is the point of interest. 
&lt;/p&gt;

&lt;p&gt;
There are &lt;b&gt;formal&lt;/b&gt; and &lt;b&gt;semiformal&lt;/b&gt; specification languages. The former are automatically processable for example theorem proofs, however these are often hard to read. The latter serve the purpose of communicating about algorithms.
&lt;/p&gt;

&lt;p&gt;
We'll use the probably most popular semiformal specification language for imperative algorithms which is &lt;b&gt;pseudocode&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
And this (pseudocode) is where we will continue in the next lecture. Cya :)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-13/</guid><pubDate>Sun, 18 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 12</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org9e75314" class="outline-2"&gt;
&lt;h2 id="org9e75314"&gt;Bit Operators&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e75314"&gt;
&lt;p&gt;
In this lecture we started by covering bit operators. I've also written about those &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-03/"&gt;here&lt;/a&gt;. To keep it short (look at the link for more detailed explainations):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; bitwise &lt;b&gt;and&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; bitwise &lt;b&gt;or&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; bitwise &lt;b&gt;not&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; bitwise &lt;b&gt;xor&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bitwise-op.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Then there are the bitshift operators as well:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;8 &amp;lt;&amp;lt; n&lt;/code&gt; leftshift which is like multiplication with 2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;8 &amp;gt;&amp;gt; n&lt;/code&gt; rightshift which is like division with 2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are more operators in C. Some of them offer a shorter/more concise notation. The lecturer calls them "Faulheitsoperatoren" (lazy operators) I don't like that term because it can get mixed with "lazy evaluation" (which is called short circuit evaluatoin to be precise) rather easily. So I'll now just go over the operators we covered in the lecture next.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2bceece" class="outline-2"&gt;
&lt;h2 id="org2bceece"&gt;Comma Operator&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2bceece"&gt;
&lt;p&gt;
The wikipedia page on this operator is very well written, I have copied the valuable information to here:
&lt;/p&gt;

&lt;p&gt;
In the C and C++ programming languages, the comma operator (represented by the token &lt;code&gt;,&lt;/code&gt;) is a &lt;b&gt;binary operator&lt;/b&gt; that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).
&lt;/p&gt;

&lt;p&gt;
The use of the comma token as an operator is distinct from its use in function calls and definitions, variable declarations, enum declarations, and similar constructs, where it acts as a separator.
&lt;/p&gt;

&lt;p&gt;
The comma operator separates expressions (which have value) in a way analogous to how the semicolon terminates statements, and sequences of expressions are enclosed in parentheses analogously to how sequences of statements are enclosed in braces: &lt;code&gt;(a, b, c)&lt;/code&gt; is a sequence of expressions, separated by commas, which evaluates to the last expression &lt;code&gt;c&lt;/code&gt; while &lt;code&gt;{a; b; c;}&lt;/code&gt; is a sequence of statements, and does not evaluate to any value. A comma can only occur between two expressions – commas separate expressions – unlike the semicolon, which occurs at the end of a (non-block) statement – semicolons terminate statements.
&lt;/p&gt;

&lt;p&gt;
The comma operator has the lowest precedence of any C operator, and acts as a sequence point. In a combination of commas and semicolons, semicolons have lower precedence than commas, as semicolons separate statements but commas occur within statements, which accords with their use as ordinary punctuation: &lt;code&gt;a, b; c, d&lt;/code&gt; is grouped as &lt;code&gt;(a, b); (c, d)&lt;/code&gt; because these are two separate statements.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Commas act as separators in this line, not as an operator.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=0&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of b into i.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=2&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// parens are required here because '=' has higher precedence than ',' it would get treated as (int i = a), (int b); without the parens which would be a redeclaration of b with no linkage          &lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of a into i. Equivalent to (i = a), b;&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=1&lt;/span&gt;
&lt;span class="cm"&gt; *  (The curly braces on the second line are needed to&lt;/span&gt;
&lt;span class="cm"&gt; *   avoid a compiler error.  The second 'b' declared&lt;/span&gt;
&lt;span class="cm"&gt; *   is given no initial value.)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Increases value of a by 2, then assigns value of resulting operation a+b into i .&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=3, b=2, c=3, i=5&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Increases value of a by 2, then stores value of a to i, and discards unused&lt;/span&gt;
&lt;span class="cm"&gt; *  values of resulting operation a + b . Equivalent to (i = (a += 2)), a + b; &lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=3, b=2, c=3, i=3&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of a into i;  the following 'b' and 'c'&lt;/span&gt;
&lt;span class="cm"&gt; *  are not part of the initializer but declarators for&lt;/span&gt;
&lt;span class="cm"&gt; *  second instances of those variables.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=1&lt;/span&gt;
&lt;span class="cm"&gt; *  (The curly braces on the second line are needed to&lt;/span&gt;
&lt;span class="cm"&gt; *   avoid a compiler error.  The second 'b' and second&lt;/span&gt;
&lt;span class="cm"&gt; *   'c' declared are given no initial value.)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;     
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of c into i, discarding the unused a and b values.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=3&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 6, not 4, since comma operator sequence points following the keyword &lt;/span&gt;
&lt;span class="cm"&gt; *  'return' are considered a single expression evaluating to rvalue of final &lt;/span&gt;
&lt;span class="cm"&gt; *  subexpression c=6 .&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 3, not 1, for same reason as previous example, that is return expressions must be fully evaluated before the function can return.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 3, not 1, still for same reason as above. This example works as it does&lt;/span&gt;
&lt;span class="cm"&gt; *  because return is a keyword, not a function call. Even though compilers will &lt;/span&gt;
&lt;span class="cm"&gt; *  allow for the construct return(value), the parentheses are only relative to "value"&lt;/span&gt;
&lt;span class="cm"&gt; *  and have no special effect on the return keyword.&lt;/span&gt;
&lt;span class="cm"&gt; *  Return simply gets an expression and here the expression is "(1), 2, 3".&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;Use cases&lt;/b&gt;: The comma operator has relatively limited use cases. Because it discards its first operand, it is generally only useful where the first operand has desirable side effects. Further, because it is rarely used outside of specific idioms, and easily mistaken with other commas or the semicolon, it is potentially confusing and error-prone. Nevertheless, there are certain circumstances where it is commonly used, notably in for loops and in SFINAE. For embedded systems which may have limited debugging capabilities, the comma operator can be used in combination with a macro to seamlessly override a function call, to insert code just before the function call.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;For Loops&lt;/i&gt;:
&lt;/p&gt;

&lt;p&gt;
The most common use is to allow multiple assignment statements without using a block statement, primarily in the initialization and the increment expressions of a for loop. This is the only idiomatic use in elementary C programming. In the following example, the order of the loop's initializers is significant:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// reverse print char array&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rev&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Outside of for loop initializers (which have a special use of semicolons), the comma might be used synonymously with the semicolon, particularly when the statements in question function similarly to a loop increment (e.g. at the end of a while loop):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Two statements on one line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
However, as this usage achieves the same thing as the semicolon in a visually different way, this is of dubious usefulness and might confuse readers.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Condition&lt;/i&gt;:
&lt;/p&gt;

&lt;p&gt;
The comma can be used within a condition (of an if, while, do while, or for) to allow auxiliary computations, particularly calling a function and using the result, with block scoping:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;// statements involving x and y&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;i&gt;Complex return&lt;/i&gt;:
The comma can be used in return statements, to assign to a global variable or out parameter (passed by reference). This idiom suggests that the assignments are part of the return, rather than auxiliary assignments in a block that terminates with the actual return. For example, in setting a global error number:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;failure&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This can be written more verbosely as:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;failure&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;i&gt;Avoid a block&lt;/i&gt;:
For brevity, the comma can be used to avoid a block and associated braces, as in:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
instead of:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9b592ea" class="outline-2"&gt;
&lt;h2 id="org9b592ea"&gt;Increment and Decrement Operator&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9b592ea"&gt;
&lt;p&gt;
Next up are &lt;code&gt;++&lt;/code&gt; increment and &lt;code&gt;--&lt;/code&gt; decrement operators which are unary operators that add or subtract one, to or from their operand. C like languages offer two versions (pre and post) of each operator with slighltly different semantics. Now guess what I've also written a bit about them &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/"&gt;here&lt;/a&gt; xD but that was a bit superficial so we'll repeat now.
&lt;/p&gt;

&lt;p&gt;
The increment operator increases, and the decrement operator decreases, the value of its operand by 1. The operand must have an arithmetic or pointer data type, and must refer to a modifiable data object. Pointers values are increased (or decreased) by an amount that makes them point to the next (or previous) element adjacent in memory → so eg incrementing a pointer via &lt;code&gt;++&lt;/code&gt; will increment it to point to the next element which would really be an incrementation of 8 when the base handled base type is a char for example.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;pre-increment&lt;/b&gt; and &lt;b&gt;pre-decrement&lt;/b&gt; operators increment (or decrement) their operand by 1, and the value of the expression is the resulting incremented (or decremented) value.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;post-increment&lt;/b&gt; and &lt;b&gt;post-decrement&lt;/b&gt; operators increase (or decrease) the value of their operand by 1, but the value of the expression is the operand's original value prior to the increment (or decrement) operation.
&lt;/p&gt;

&lt;p&gt;
Since the increment/decrement operator modifies its operand, use of such an operand more than once within the same expression can produce undefined results. For example, in expressions such as &lt;code&gt;x - ++x&lt;/code&gt;, it is not clear in what sequence the subtraction and increment operations should be performed. Such expressions generally invoke undefined behavior, and should be avoided.
&lt;/p&gt;

&lt;p&gt;
This example visualizes the difference between the post and prefix operators:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Increment operators&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 2, y is also 2&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 3, y is 2&lt;/span&gt;

&lt;span class="c1"&gt;// Decrement operators&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 2, y is 3&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 1, y is also 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
If these shorthand operators are just used for their side effect (which is de-/in-crementing the variable for example in the third for loop statement) then it does not matter which variant post or pre is used.
&lt;/p&gt;

&lt;p&gt;
Easy peazy my friend :D 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org72e4534" class="outline-2"&gt;
&lt;h2 id="org72e4534"&gt;Compound Assignment Operators&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org72e4534"&gt;
&lt;p&gt;
The next type of operators we cover are called &lt;b&gt;compound assignment operators&lt;/b&gt; ('Selbstzuweisungsoperatoren' in script). The following table visualizes their effects:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Operator name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Syntax&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Addition assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a += b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a + b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Subtraction assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a -= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a - b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Multiplication assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a *= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a * b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Division assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a /= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a / b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Modulo assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a %= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a % b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise AND assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;amp;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;amp; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise OR assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a ❘= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a ❘ b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise XOR assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a ^= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a ^ b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise leftshift assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;lt;&amp;lt;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;lt;&amp;lt; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise rightshift assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;gt;&amp;gt;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;gt;&amp;gt; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Be careful, while &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; are somewhat common to see, the others might be confusing and it is okay to not use them as much.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbfaa6b9" class="outline-2"&gt;
&lt;h2 id="orgbfaa6b9"&gt;Operator Precedence and Associativity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbfaa6b9"&gt;
&lt;p&gt;
When multiple operators are used in an expression, the evaluation order depends on the &lt;i&gt;precedence&lt;/i&gt; and / associativity/ of the operators.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;order of operations&lt;/b&gt; (or &lt;b&gt;operator precedence&lt;/b&gt;) is a collection of rules that reflect conventions about which procedures to perform first in order to evaluate a given mathematical expression.
&lt;/p&gt;

&lt;p&gt;
For example, in mathematics and most computer languages, multiplication is granted a higher precedence than addition, and it has been this way since the introduction of modern algebraic notation. Thus, the expression &lt;code&gt;2 + 3 × 4&lt;/code&gt; is interpreted to have the value &lt;code&gt;2 + (3 × 4) = 14&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Skript: Operatoren mit höherer Priorität werden zuerst ausgewertet
&lt;/p&gt;


&lt;p&gt;
The &lt;b&gt;associativity&lt;/b&gt; of an operator is a property that determines how operators of the same precedence are grouped in the absence of parentheses. If an operand is both preceded and followed by operators, and those operators have equal precedence, then the operand may be used as input to two different operations (i.e. the two operations indicated by the two operators). The choice of which operations to apply the operand to, is determined by the &lt;i&gt;"associativity"&lt;/i&gt; of the operators.
&lt;/p&gt;

&lt;p&gt;
Operators may be &lt;b&gt;associative&lt;/b&gt; (meaning the operations can be grouped arbitrarily), &lt;b&gt;left-associative&lt;/b&gt; (meaning the operations are grouped from the left), &lt;b&gt;right-associative&lt;/b&gt; (meaning the operations are grouped from the right) or &lt;b&gt;non-associative&lt;/b&gt; (meaning operations cannot be chained, often because the output type is incompatible with the input types).
&lt;/p&gt;

&lt;p&gt;
The associativity and precedence of an operator is a part of the definition of the programming language; different programming languages may have different associativity and precedence for the same type of operator.
&lt;/p&gt;

&lt;p&gt;
Consider the expression &lt;code&gt;a ~ b ~ c&lt;/code&gt;. If the operator &lt;code&gt;~&lt;/code&gt; has left associativity, this expression would be interpreted as &lt;code&gt;(a ~ b) ~ c&lt;/code&gt;. If the operator has right associativity, the expression would be interpreted as &lt;code&gt;a ~ (b ~ c)&lt;/code&gt;. If the operator is non-associative, the expression might be a syntax error, or it might have some special meaning. 
&lt;/p&gt;

&lt;p&gt;
Some mathematical operators have inherent associativity. For example, subtraction and division, as used in conventional math notation, are inherently left-associative. Addition and multiplication, by contrast, are both left and right associative eg &lt;code&gt;(a * b) * c = a * (b * c))&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Skript: Assoziativität bestimmt die Richtung der Auswertung
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C++#Compound_assignment_operators"&gt;Wiki C Precedence / Associativity Table&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Table and notes below from &lt;a href="https://en.cppreference.com/w/c/language/operator_precedence"&gt;cppreference.com&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/c-table.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression &lt;code&gt;*p++&lt;/code&gt; is parsed as &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;(*p)++&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression &lt;code&gt;a=b=c&lt;/code&gt; is parsed as &lt;code&gt;a=(b=c)&lt;/code&gt;, and not as &lt;code&gt;(a=b)=c&lt;/code&gt; because of &lt;i&gt;right-to-left associativity&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Precedence and associativity are independent from order of evaluation.
&lt;/p&gt;

&lt;p&gt;
The C language standard doesn't specify operator precedence. It specifies the language grammar, and the precedence table is derived from it to simplify understanding. There is a part of the grammar that cannot be represented by a precedence table: an assignment-expression is not allowed as the right hand operand of a conditional operator, so &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed, and therefore relative precedence of conditional and assignment operators cannot be described easily.
&lt;/p&gt;

&lt;p&gt;
However, many C compilers use non-standard expression grammar where &lt;code&gt;?:&lt;/code&gt; is designated higher precedence than &lt;code&gt;=&lt;/code&gt;, which parses that expression as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, which then fails to compile due to semantic constraints: &lt;code&gt;?:&lt;/code&gt; is never lvalue and &lt;code&gt;=&lt;/code&gt; requires a modifiable lvalue on the left. This is the table presented on this page.
&lt;/p&gt;

&lt;p&gt;
Note that this is different in C++, where the conditional operator has the same precedence as assignment.
&lt;/p&gt;

&lt;p&gt;
Associativity specification is redundant for unary operators and is only shown for completeness: &lt;i&gt;unary prefix&lt;/i&gt; operators always associate right-to-left eg &lt;code&gt;sizeof ++*p&lt;/code&gt; is
 &lt;code&gt;sizeof(++(*p))&lt;/code&gt; and &lt;i&gt;unary postfix&lt;/i&gt; operators always associate left-to-right
 eg &lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Remeber when in doubt use parentheses as it improves readability as well!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgae52c08" class="outline-2"&gt;
&lt;h2 id="orgae52c08"&gt;Abstract Machines (Automaten)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgae52c08"&gt;
&lt;p&gt;
The next part of the chapter dealt with abstract machines. The slides are hard to convert to a blog format and it did not seem to be important for the course so I'll just skip over some stuff here. You should still take a look &lt;a href="https://osg.informatik.tu-chemnitz.de/lehre/aup/aup-06-Logik-handout_de.pdf"&gt;here&lt;/a&gt; (lecture slides 06: slide 40).
&lt;/p&gt;

&lt;p&gt;
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types – deterministic finite state machines and non-deterministic finite state machines. A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.
&lt;/p&gt;

&lt;p&gt;
Slides: Ein endlicher (deterministischer) Automat (EA, Zustandsmaschine, finite state machine ➡ FSM, auch: finite state automata) ist ein Modell zur Beschreibung von Abläufen (z.B. in Computern). Ein EA besteht aus einer Menge von &lt;i&gt;Zuständen&lt;/i&gt; S (states) und &lt;i&gt;Zustandsübergängen&lt;/i&gt; T : S × Γ → S (Transitionen, transitions). Ein EA startet in einem &lt;i&gt;Startzustand&lt;/i&gt;. Er „verarbeitet“ eine Sequenz von &lt;i&gt;Zeichen&lt;/i&gt; oder &lt;i&gt;Ereignissen&lt;/i&gt; Γ. Dabei bestimmt das nächste Zeichen/Ereignis, in welchen Zustand der EA wechselt. Ein EA kann einen oder mehrere &lt;i&gt;Endzustände&lt;/i&gt; (accepting states) besitzen. Wird ein solcher Zustand erreicht, ist die Abarbeitung beendet.
&lt;/p&gt;

&lt;p&gt;
Transitions (Zustandsveränderungen) in a state machine (endlichem Automaten) can lead to &lt;i&gt;actions&lt;/i&gt; or &lt;i&gt;output&lt;/i&gt;.
Transducers (Transduktor, ein spezieller endlicher Automat der im Ggsatz zu einem Akzeptor eine Ausgabe erzeugt, überführt/übersetzt eine Quellsprache in eine Zielsprache) generate output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.
&lt;/p&gt;

&lt;p&gt;
In control applications, two types are distinguished:
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Moore machine&lt;/b&gt;:
&lt;/p&gt;

&lt;p&gt;
The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: "command&lt;sub&gt;open&lt;/sub&gt;" and "command&lt;sub&gt;close&lt;/sub&gt;", which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: "door is open" or "door is closed". Slides: Aktion/Ausgabe ist an die Ankunft in einem bestimmten Zustand gebunden
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/moore.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;Mealy machine&lt;/b&gt;:
&lt;/p&gt;

&lt;p&gt;
The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in the picture below shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): "start motor to close the door if command&lt;sub&gt;close&lt;/sub&gt; arrives" and "start motor in the other direction to open the door if command&lt;sub&gt;open&lt;/sub&gt; arrives". The "opening" and "closing" intermediate states are not shown. Slides: Aktion/Ausgabe ist an einen bestimmten Übergang gebunden
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mealy.png" alt="nil"&gt;
&lt;/p&gt;



&lt;p&gt;
Finite state machines are closely related to regular grammars because to every regular grammar there exists at least one FSM which accepts all expressions of that language (slides: Jede Folge von zulässigen Eingabesymbolen bzw. -ereignissen, die in einen Endzustand führen, entspricht einer formalen Sprache, die durch eine reguläre Grammatik beschrieben werden kann).
&lt;/p&gt;

&lt;p&gt;
However a FSM is not sufficient for context free languages.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/</guid><pubDate>Thu, 15 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 11</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org35c18e5" class="outline-2"&gt;
&lt;h2 id="org35c18e5"&gt;Logic and Abstract Machines (Automaten)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35c18e5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc02a1f6" class="outline-3"&gt;
&lt;h3 id="orgc02a1f6"&gt;Boolean Algebra&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc02a1f6"&gt;
&lt;p&gt;
Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively.
&lt;b&gt;Propositional logic&lt;/b&gt; (Aussagenlogik) is a branch of logic which deals with propositions (which can be true or false) and argument flow. Compound propositions are formed by connecting propositions by logical connectives. The propositions without logical connectives are called atomic propositions. 
&lt;/p&gt;

&lt;p&gt;
Principles:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;principle of bivalence&lt;/b&gt; (Zweiwertigkeit) → every proposition (Aussage) is either true (truthy) or false (falsy)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle/law of excluded third/middle&lt;/b&gt; → for any proposition, either that proposition is true or its negation is true - no third possibility is given&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle/law of noncontradiction&lt;/b&gt; → no proposition can be true and false at the same time&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle of extensionality&lt;/b&gt; → the truth value of a composite proposition (Aussageverknüpfung) only depends on the truth value of its components&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
F 3./4.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbcbba1b" class="outline-4"&gt;
&lt;h4 id="orgbcbba1b"&gt;Logical Composition&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgbcbba1b"&gt;
&lt;p&gt;
The following logical compositions (Verknüpfungsfunktionen) will be inserted as pictures from the lecture slides because it is pretty time-consuming to port it over.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/logical-comp-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/logical-comp-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
A set of logical compositions that is able to express all other compositions is called &lt;b&gt;logically/functionally complete&lt;/b&gt; (logisch vollständig)
&lt;/p&gt;

&lt;p&gt;
More laws and rules from lecture slides:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bool-law-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bool-law-2.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3cb7059" class="outline-4"&gt;
&lt;h4 id="org3cb7059"&gt;Normal Form&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3cb7059"&gt;
&lt;p&gt;
Normal forms can help with unifying boolean expressions/propositions which can get unclearly fast (unübersichtlich):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;disjunctive normal form&lt;/b&gt; → is a standardization (or normalization) of a logical formula which is a disjunction of conjunctive clauses; it can also be described as an &lt;b&gt;OR&lt;/b&gt; of &lt;b&gt;ANDs&lt;/b&gt; or a sum of products
&lt;ul class="org-ul"&gt;
&lt;li&gt;slides: Eine boolsche Funktion ist in disjunktiver Normalform (DNF), wenn sie eine Disjunktion (Oder) von Konjunktionsstermen (Und) ist, wobei die Konjunktionsterme nur (ggf. negierten) Funktionsparameter enthält&lt;/li&gt;
&lt;li&gt;\(y = \vee_i (\wedge_j [\neg] x_{i,j}) \)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;conjunctive normal form&lt;/b&gt; → is a conjunction of one or more clauses, where a clause is a disjunction of literals; otherwise put, it is an &lt;b&gt;AND&lt;/b&gt; of &lt;b&gt;ORs&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;slides: Eine boolsche Funktion ist in konjunktiver Normalform (KNF), wenn sie eine Konjunktion (Und) von Disjunktionstermen (Oder) ist, wobei die Disjunktionsterme nur (ggf. negierten) Funktionsparameter enthält&lt;/li&gt;
&lt;li&gt;\(y = \wedge_i (\vee_j  [\neg] x_{i,j}) \)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are different ways to create normal forms eg conversions via boolean algebra or by using truth tables:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/normalform.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
At this point the Karnaugh-Veitch Diagram for optimization purposes was mentioned which I'm skipping here. Take a look at slide 13 if you want (I don't lol).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc3eee68" class="outline-2"&gt;
&lt;h2 id="orgc3eee68"&gt;Logic in C&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc3eee68"&gt;
&lt;p&gt;
C uses logical (boolean) propositions/expressions and knows an according type. However since that type is so close to integer, it was not made explicitly available before C99. Since C99 however there is &lt;code&gt;_Bool&lt;/code&gt;. Via including &lt;code&gt;stdbool.h&lt;/code&gt; the type &lt;code&gt;bool&lt;/code&gt; is available which is a synonym for &lt;code&gt;_Bool&lt;/code&gt; and can hold the values &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
But remember that everywhere were a boolean type is required there can always be an integer. If so &lt;code&gt;0&lt;/code&gt; is always interpreted as &lt;code&gt;false&lt;/code&gt; and &lt;i&gt;every other&lt;/i&gt; value as &lt;code&gt;true&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The logic/boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in C do so called &lt;b&gt;short-circuit evaluation&lt;/b&gt; from left to right which means the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression: when the first argument of the &lt;b&gt;AND&lt;/b&gt; function evaluates to &lt;code&gt;false&lt;/code&gt;, the overall value must be &lt;code&gt;false&lt;/code&gt;; and when the first argument of the &lt;b&gt;OR&lt;/b&gt; function evaluates to &lt;code&gt;true&lt;/code&gt;, the overall value must be &lt;code&gt;true&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Short-circuit operators are, in effect, control structures rather than simple arithmetic operators, as they are not strict. In imperative language terms (notably C and C++), where side effects are important, short-circuit operators introduce a sequence point – they completely evaluate the first argument, including any side effects, before (optionally) processing the second argument (es ist eine gängige Programmiertechnik, links im Kurzschlussoperator eine Bedingung abzusichern, die rechts zu einem Laufzeitfehler führen würde)
&lt;/p&gt;

&lt;p&gt;
Bad code example from the lecture slides follows, BRACE YOURSELF:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* shortcut .c -- partial evaluation */&lt;/span&gt;
&lt;span class="cp"&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d. value : %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Some imho more practical pseudo examples could look like this:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;firedMissles&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CanFireMissiles&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;FireMissiles&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="cm"&gt;/* or */&lt;/span&gt;

&lt;span class="n"&gt;isFileReady&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;getFileReady&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
C also provides a &lt;i&gt;conditional operator&lt;/i&gt;. If any operator is used on three operands or variable is also known as &lt;i&gt;Ternary Operator&lt;/i&gt;. It can be represented with &lt;code&gt;"? : "&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The ternary operator is used to execute code based on the result of a binary condition.
&lt;/p&gt;

&lt;p&gt;
It takes in a binary condition as input, which makes it similar to an 'if-else' control flow block. It also, however, returns a value, behaving similar to a function (functional model).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;binaryCondition&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;valueReturnedIfTrue&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;valueReturnedIfFalse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The ternary cannot be used to execute code. It must be either returned in a function, or set equal to a variable with the same data type as the returned values:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findMaximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;//if a &amp;gt; b, it returns a, if not it returns b&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;a&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Some interesting notes and observations about the ternary operator can be found &lt;a href="https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/"&gt;here&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The next lecture topic was the switch-case. I already covered that in &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/#org48e22fb"&gt;this CS01 post&lt;/a&gt; and the rules from C++ apply to C aswell (other way round technically :D). Remember that "switch case" works with constant values as its cases and is used to "jump" to a specific statement from where execution will be continued until you &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;! so following cases would be executed as well (avoid this and rather group cases together. It is also important to know that cases inside a switch are like "goto" labels and share scope, thats why often times people wrap the cases code inside "{}" to create case specific code and dont "skip" initialization of variables).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/</guid><pubDate>Sun, 11 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 10</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org3412ab9" class="outline-2"&gt;
&lt;h2 id="org3412ab9"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3412ab9"&gt;
&lt;p&gt;
How does the compiler know whether a program is "correct" (in the sense of compilable) or not?
We basically distinguish between &lt;b&gt;grammar&lt;/b&gt; and &lt;b&gt;semantics&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Grammar&lt;/b&gt; (like we know it from school) consists of  &lt;i&gt;morphology&lt;/i&gt; (Formenlehre v Wörtern) and syntax (Sätze). In the realm of programming morphology practically doesn't matter therefore &lt;i&gt;grammar&lt;/i&gt; and &lt;i&gt;syntax&lt;/i&gt; are mostly used interchangeably.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;semantics&lt;/b&gt; (&lt;i&gt;meaning of a sentence&lt;/i&gt;) do not matter to the compiler.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc7b3af8" class="outline-2"&gt;
&lt;h2 id="orgc7b3af8"&gt;Syntax&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc7b3af8"&gt;
&lt;p&gt;
The &lt;b&gt;syntax&lt;/b&gt; of a language is a &lt;i&gt;set of rules&lt;/i&gt; after which &lt;i&gt;expressions&lt;/i&gt; are built. This is true for natural languages like English and for formal languages likes C or Python, as well as mathematical logic or description languages etc.
&lt;/p&gt;

&lt;p&gt;
Expressions in the above definition might be phrases, formulas are program/code statements.
&lt;/p&gt;

&lt;p&gt;
Often times the better you understand the semantics the harder it gets to recognize the syntax (for example in my motherlanguage I don't think about the SPO-rule for subject-predicate-object at all).
&lt;/p&gt;

&lt;p&gt;
Every formal language consists of &lt;b&gt;symbols/tokens&lt;/b&gt;. A symbol is the &lt;b&gt;smallest&lt;/b&gt; observable unit in a language (kleinste Einheit der Betrachtung innerhalb der Sprache). Symbols can be single tokens, combinations of such or whole words.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Every finite, non-empty set \(\sum\) of symbols is called &lt;b&gt;alphabet&lt;/b&gt;.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
With the elements in \(\sum\) we can build &lt;b&gt;expression&lt;/b&gt;. The "empty expression" is represented as \(\epsilon\)  (epsilon).
&lt;/p&gt;

&lt;p&gt;
The set \(\sum = {0,1,2,3,4,5,6,7,8,9}\) for example is sufficient to build all natural numbers in the decimal system.
&lt;/p&gt;

&lt;p&gt;
/The set of all strings(combinations) (Zeichenketten) the symbols from \(\sum\) can build is called &lt;b&gt;Kleene star&lt;/b&gt; \(\sum *\) of \(\sum\) (Kleenesche Hülle).
&lt;/p&gt;

&lt;p&gt;
For example:
\[ \sum = \{a,b\} \Rightarrow \sum * = \{\epsilon, a, b, aa, bb, ab, ba, aaa, aab, aba,baa, ...\} \]
&lt;/p&gt;

&lt;p&gt;
The set of all strings without the empty string is represented as \(sum +\) Kleene Plus.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Each subset \(L \subseteq \sum*\) is also a &lt;b&gt;formal language&lt;/b&gt;&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
In the following context we focus on formal languages and "languages" then refers to such.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5262b4a" class="outline-2"&gt;
&lt;h2 id="org5262b4a"&gt;Formal languages and generative/formal grammar&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5262b4a"&gt;
&lt;p&gt;
How can the syntax of a language be described? Which expressions/strings in a language are valid and which aren't? An enumeration of valid expressions is usually unpractical because the quantity of expressions is often times enormously big or infinite. 
&lt;/p&gt;

&lt;p&gt;
A solution to this is to &lt;i&gt;describe&lt;/i&gt; how valid expressions can/may be &lt;b&gt;generated&lt;/b&gt;. These "rules" are called &lt;b&gt;generative/formal grammar&lt;/b&gt;. From wikipedia: "In formal language theory, a grammar (when the context is not given, often called a formal grammar for clarity) is a set of production rules for strings in a formal language. The rules describe how to form strings from the language's alphabet that are valid according to the language's syntax. A grammar does not describe the meaning of the strings or what can be done with them in whatever context—only their form."
&lt;/p&gt;

&lt;p&gt;
For generative grammar of a language \(L\) a second alphabet \(V\) of variables is used in addition to the alphabet \(\sum\).
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;elements of \(\sum\) are called &lt;b&gt;terminal symbols&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;elementary symbols of a language&lt;/li&gt;
&lt;li&gt;cannot be replaced/reproduced via production rules&lt;/li&gt;
&lt;li&gt;eg: "for", "if"&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;elements of \(V\) are called &lt;b&gt;nonterminal symbols&lt;/b&gt; (in some literature it is N instead of V)
&lt;ul class="org-ul"&gt;
&lt;li&gt;are reproducable/replacable via production rules&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
When speaking about those elements in an abstract way usually lower case letters (a,b,c..) are used for elements of \(\sum\) and uppercase letters for elements of \(V\).
&lt;/p&gt;

&lt;p&gt;
A grammar is defined by production rules (or just 'productions') that specify which symbols may replace which other symbols; these rules may be used to generate strings, or to parse them. Each such rule has a head, or left-hand side, which consists of the string that may be replaced, and a body, or right-hand side, which consists of a string that may replace it. Rules are often written in the form head → body; e.g., the rule a → b specifies that a can be replaced by b.
&lt;/p&gt;

&lt;p&gt;
To generate an expression we begin with a &lt;b&gt;start symbol&lt;/b&gt; \(S \in V\).
&lt;/p&gt;

&lt;p&gt;
Then depending on the nature of the rules \(P\) we distinguish between different kind of grammars (a regular grammar is a left or a right regular grammar):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a left regular grammar  is a formal grammar (V, Σ, P, S), such that all rules in P obey the forms:
&lt;ul class="org-ul"&gt;
&lt;li&gt;A → a - where A is a non-terminal in V and a is a terminal in Σ&lt;/li&gt;
&lt;li&gt;A → Ba - where A and B are in V and a is in Σ&lt;/li&gt;
&lt;li&gt;A → ε - where A is in N and ε is the empty string.&lt;/li&gt;
&lt;li&gt;so only &lt;b&gt;one nonterminal symbol&lt;/b&gt; on the &lt;i&gt;left side&lt;/i&gt; and on the &lt;i&gt;right side&lt;/i&gt; &lt;b&gt;one terminal symbol&lt;/b&gt; that &lt;i&gt;may be&lt;/i&gt; &lt;b&gt;preceeded&lt;/b&gt; by &lt;i&gt;one nonterminal symbol max&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;a &lt;b&gt;right regular grammar&lt;/b&gt; is a formal grammar (V, Σ, P, S) such that all the production rules in P are of one of the following forms:
&lt;ul class="org-ul"&gt;
&lt;li&gt;B → a - where B is a non-terminal in V and a is a terminal in Σ&lt;/li&gt;
&lt;li&gt;B → aC - where B and C are non-terminals in V and a is in Σ&lt;/li&gt;
&lt;li&gt;B → ε - where B is in V and ε denotes the empty string, i.e. the string of length 0.&lt;/li&gt;
&lt;li&gt;so only &lt;b&gt;one nonterminal symbol&lt;/b&gt; on the &lt;i&gt;left side&lt;/i&gt; and on the &lt;i&gt;right side&lt;/i&gt; &lt;b&gt;one terminal symbol&lt;/b&gt; that &lt;i&gt;may be&lt;/i&gt; &lt;b&gt;followed&lt;/b&gt; by &lt;i&gt;one nonterminal symbol max&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Types of grammars:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;regular grammar&lt;/b&gt; (reguläre Grammatik) → either &lt;i&gt;all&lt;/i&gt; rules of P are of left regular grammar nature &lt;i&gt;or&lt;/i&gt; right regular grammar nature (not both/mixed)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;context-free grammar&lt;/b&gt; (kontextfreie Grammatik) → a context-free grammar is a grammar in which the left-hand side of each production rule consists of &lt;i&gt;only a single nonterminal symbol&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;context-sensitive grammar&lt;/b&gt; (kontextbehaftet/sensitive Grammatik) → a context-sensitive grammar is a formal grammar in which the left-hand sides and right-hand sides of any production rules may be surrounded by a context of &lt;b&gt;the same&lt;/b&gt; terminal and nonterminal symbols &lt;code&gt;αAβ → αγβ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;unrestricted grammar&lt;/b&gt; (allgemeine Grammatik)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
After the american linguist Noam Chomsky those grammars build the so called &lt;b&gt;Chomsky-Hierarchy&lt;/b&gt; in which they're also called as:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Type-0 grammars&lt;/b&gt; → &lt;i&gt;unrestricted grammars&lt;/i&gt; (allgemeine Grammatiken)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-1 grammars&lt;/b&gt; → &lt;i&gt;context-sensitive grammars&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-2 grammars&lt;/b&gt; → &lt;i&gt;context-free grammars&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-3 grammars&lt;/b&gt; → &lt;i&gt;regular grammars&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Each n-1 grammar can "do everything and more" that a grammar of type n can do (a type 1 grammar can do everything a type 2 grammar can and so on; Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69566a8" class="outline-2"&gt;
&lt;h2 id="org69566a8"&gt;Syntax Diagrams&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org69566a8"&gt;
&lt;p&gt;
How may we describe the rules of grammars? For the following we limit us to (maximal) contrext free grammars. To describe grammar rules there exist two main approaches:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;syntax diagrams&lt;/li&gt;
&lt;li&gt;(extended) Backus-Naur form&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:red;"&gt;
I was told that these were asked in last years exam
&lt;/p&gt;

&lt;p&gt;
Syntax diagrams consist of of:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;boxes with round corners → terminal symbols (lowercase, see above)&lt;/li&gt;
&lt;li&gt;boxes with straight corners → nonterminal symbols (uppercase, see above)&lt;/li&gt;
&lt;li&gt;connections via lines and arrows&lt;/li&gt;
&lt;li&gt;each walkable way (in arrow direction) is valid a expression (Jeder (in Pfeilrichtung) begehbare Weg ist ein valider Ausdruck)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Components:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-intro.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
An example of a (simplified) function declaration in C in a syntax diagram:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-func-decl.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example of a syntax diagram for a while loop in python:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-python.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org94ed424" class="outline-2"&gt;
&lt;h2 id="org94ed424"&gt;Backus-Naur Form&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org94ed424"&gt;
&lt;p&gt;
While syntax diagrams are easy to read, they're quite cumbersome and take a lot of space. A more compact alternative is the Backus-Naur form (BNF).
&lt;/p&gt;

&lt;p&gt;
BNF uses meta symbols:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;::=&lt;/code&gt; definition symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; alternative symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; nonterminal brackets which convert any sequence of letters, digits and spaces into a nonterminal symbol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
All symbols which are neither meta symbols nor nonterminalsymbols are terminal symbols.
&lt;/p&gt;

&lt;p&gt;
BNF is directly translatable into context-free grammar, but needs (for example for loops) syntactic helper variables.
&lt;/p&gt;

&lt;p&gt;
That's why there's also the Extended Backus-Naur form (EBNF) which is like BNF plus:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[ ... ]&lt;/code&gt; → description of &lt;b&gt;optional parts&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ ... }&lt;/code&gt; → description of &lt;b&gt;repetitions&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are also some syntactic differences:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;arbitrary paren placement (Klammerung)&lt;/li&gt;
&lt;li&gt;definition symbol is &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;terminal symbols are wrapped in &lt;code&gt;""&lt;/code&gt; or &lt;code&gt;''&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;nonterminal symbols arent specially marked
&lt;ul class="org-ul"&gt;
&lt;li&gt;there also might be whitespaces in nonterminal symbol identifiers, the sequence is then separated via commas eg &lt;code&gt;signed integer = sign, integer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;expressions end with semicolons &lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;specific repetitions via &lt;code&gt;4 * (...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;comments via &lt;code&gt;(* This is a comment*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A (E)BNF defintion or a syntax diagram is &lt;b&gt;complete&lt;/b&gt; (vollständig) if a rule exist on the left side for every nonterminal symbol on the right hand rule side.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7d07cca" class="outline-2"&gt;
&lt;h2 id="org7d07cca"&gt;Regular Grammar in Action&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7d07cca"&gt;
&lt;p&gt;
Now we'll introduce &lt;b&gt;regular expressions&lt;/b&gt; which are a compact notation for regular grammars.
&lt;/p&gt;

&lt;p&gt;
String searching or pattern matching in (certain) files is such a common task that "tools" using regular expression exist to help with it (for example grep, sed, awk, perl, Python, C#.. provide ways to pattern match with regular expressions).
&lt;/p&gt;

&lt;p&gt;
Since the 1980s, different syntaxes for writing regular expressions exist, one being the POSIX standard and another, widely used, being the Perl syntax.
&lt;/p&gt;

&lt;p&gt;
Because there is only a limited amount of symbols/characters/tokens (Zeichen) available regular expressions differentiate between regular("normal") (terminal)symbols and meta characters, with a special meaning. Common but not all meta characters are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; matches the starting position within the string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; dot wildcard matches any single character (newlines sometimes excluded tho)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ ]&lt;/code&gt; a bracket expression matches a single character that is contained within the brackets eg &lt;code&gt;[abc]&lt;/code&gt; matches "a", "b", or "c"
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[^ ]&lt;/code&gt; matches a single character that is &lt;i&gt;not&lt;/i&gt; contained within the brackets&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
= &lt;code&gt;$&lt;/code&gt; matches the ending position of the string or the position just before a string-ending newline (in line-based tools, it matches the ending position of any line)
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; matches the preceding element &lt;i&gt;zero or more&lt;/i&gt; times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; matches the preceding element &lt;i&gt;one or more&lt;/i&gt; times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; matches the preceding element at least &lt;code&gt;n&lt;/code&gt; and not more than &lt;code&gt;m&lt;/code&gt; times (eg &lt;code&gt;a{1,3}&lt;/code&gt; matches only &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;aa&lt;/code&gt; and &lt;code&gt;aaa&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt; escapes the previous meta character&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are also character classes which are the most basic regex concept after a literal match. It makes one small sequence of characters match a larget set of characters (eg in ASCII [a-z] for lowercase letters). Some examples of POSIX character classes:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[:alpha:]&lt;/code&gt; for alphabetic characters (A-Z, a-z)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:digit:]&lt;/code&gt; for digits (0-9)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alnum:]&lt;/code&gt; for alphanumeric characters (A-Z,a-z,0-9)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:blank:]&lt;/code&gt; for space and tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:print:]&lt;/code&gt; visible characters and the space character (printable characters)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example usage of grep which finds all defintions of &lt;code&gt;time_t&lt;/code&gt; in header files (option -E stands for extended-regexp):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep −E &lt;span class="s2"&gt;"typedef ([_[:alpha:]][_[:alnum:]]*[[:blank:]]+)+time_t;"&lt;/span&gt; *.h &lt;span class="c1"&gt;# (copied from slides doesnt work for me :D)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc58be84" class="outline-2"&gt;
&lt;h2 id="orgc58be84"&gt;Compiler&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc58be84"&gt;
&lt;p&gt;
A modern compiler uses multiple formal grammars for different purposes:
&lt;/p&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgb26bd0f"&gt;&lt;/a&gt;Lexical Analysis&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgb26bd0f"&gt;
&lt;p&gt;
Lexical Analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning). 
&lt;/p&gt;

&lt;p&gt;
Lexical analysis is the first phase of a compiler. It takes the modified source code from language preprocessors that are written in the form of sentences. The lexical analyzer breaks these syntaxes into a series of tokens, by removing any whitespace (in C, not in python because they belong to the syntax) or comments in the source code.
&lt;/p&gt;

&lt;p&gt;
If the lexical analyzer finds a token invalid, it generates an error. The lexical analyzer works closely with the syntax analyzer. It reads character streams from the source code, checks for legal tokens, and passes the data to the syntax analyzer when it demands.
&lt;/p&gt;

&lt;p&gt;
This is often done via a lexical specification that is defined using regular expressions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org837dc09"&gt;&lt;/a&gt;Syntax Analysis&lt;br&gt;
&lt;div class="outline-text-5" id="text-org837dc09"&gt;
&lt;p&gt;
Syntax analysis or parsing is the second phase of a compiler. We have seen that a lexical analyzer can identify tokens with the help of regular expressions and pattern rules. But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses &lt;i&gt;context-free grammar&lt;/i&gt; (CFG), which is recognized by push-down automata.
&lt;/p&gt;

&lt;p&gt;
CFG, on the other hand, is a superset of Regular Grammar. This implies that every Regular Grammar is also context-free, but there exists some problems, which are beyond the scope of Regular Grammar. CFG is a helpful tool in describing the syntax of programming languages (take a look at &lt;a href="https://www.tutorialspoint.com/compiler_design/compiler_design_syntax_analysis.htm"&gt;this&lt;/a&gt; resource which is pretty good and also has some more explanations for terminal symbols etc). 
&lt;/p&gt;

&lt;p&gt;
A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a parse tree.
&lt;/p&gt;

&lt;p&gt;
This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.
&lt;/p&gt;

&lt;p&gt;
Parsers are expected to parse the whole code even if some errors exist in the program. 
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Limitations of syntax analyzers&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
Syntax analyzers receive their inputs, in the form of tokens, from lexical analyzers. Lexical analyzers are responsible for the validity of a token supplied by the syntax analyzer. Syntax analyzers have the following drawbacks:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;it cannot determine if a token is valid&lt;/li&gt;
&lt;li&gt;it cannot determine if a token is declared before it is being used&lt;/li&gt;
&lt;li&gt;it cannot determine if a token is initialized before it is being used&lt;/li&gt;
&lt;li&gt;it cannot determine if an operation performed on a token type is valid or not&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
These tasks are accomplished by the &lt;i&gt;semantic analyzer&lt;/i&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org8e4d771"&gt;&lt;/a&gt;Semantic Analyzer&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8e4d771"&gt;
&lt;p&gt;
A parser constructs parse trees as seen in the section about the parser / syntax analyzer above.
&lt;/p&gt;

&lt;p&gt;
The plain parse-tree constructed in that phase is generally of no use for a compiler, as it does not carry any information of how to evaluate the tree. The productions of context-free grammar, which makes the rules of the language, do not accommodate how to interpret them.
&lt;/p&gt;

&lt;p&gt;
Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.
&lt;/p&gt;

&lt;p&gt;
For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"value"&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The code above should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Scope resolution&lt;/li&gt;
&lt;li&gt;Type checking&lt;/li&gt;
&lt;li&gt;Array-bound checking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
From the lecture slides: "usually context-sensitive language is used to perform semantic analysis"
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div id="outline-container-org7d80d47" class="outline-2"&gt;
&lt;h2 id="org7d80d47"&gt;Excourse: General Difference between Expressions and Statements&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7d80d47"&gt;
&lt;p&gt;
A statement is like an instruction that the runtime performs. Programs consist of statements. Without statements, there is nothing to do. 
&lt;/p&gt;

&lt;p&gt;
An expression is a piece of code that can be 'evaluated', meaning it can be reduced to a value. 
&lt;/p&gt;

&lt;p&gt;
The two concepts are not related, or even similar. They may coincide with the same piece of code, but they do very different things. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;x = 1&lt;/code&gt; is not a statement. &lt;code&gt;'x = 1'&lt;/code&gt; is an &lt;i&gt;expression&lt;/i&gt; that evaluates to 1, with the side effect of assigning the value 1 to x. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;x = 1;&lt;/code&gt; is a &lt;i&gt;statement&lt;/i&gt; (note the semi-colon at the end) that performs this assignment. 
&lt;/p&gt;

&lt;p&gt;
In many languages (Java, C, JavaScript), it's easy to distinguish statements. Statements usually end with a semi-colon. Statements can't be evaluated, they just do something. 
&lt;/p&gt;

&lt;p&gt;
Expressions are harder to distinguish: The following statement consists of 9 expressions: &lt;code&gt;f[x] = 2*x+1;&lt;/code&gt;
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x]&lt;/code&gt; binary postfix operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; literal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2*x&lt;/code&gt; binary operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; literal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2*x+1&lt;/code&gt; binary operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x] = 2*x+1&lt;/code&gt; assignment operation&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
In some languages there is no distinction between expressions and staments. In Lisp for example all code and data are written as expressions. When an expression is evaluated, it produces a value.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
Sources: &lt;a href="https://www.tutorialspoint.com"&gt;https://www.tutorialspoint.com&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/</guid><pubDate>Thu, 08 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 09</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org80666c1" class="outline-2"&gt;
&lt;h2 id="org80666c1"&gt;Complex Types in Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org80666c1"&gt;
&lt;p&gt;
There are built-in types in Python which offer similar functionality to the complex types in C and more.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9f298c6" class="outline-3"&gt;
&lt;h3 id="org9f298c6"&gt;Python Strings&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9f298c6"&gt;
&lt;p&gt;
Strings are character sequences of a fixed length and are to be precise &lt;b&gt;not&lt;/b&gt; a complex type (why?).
String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).
&lt;/p&gt;

&lt;p&gt;
Python strings are "immutable" which means they cannot be changed after they are created. Since strings can't be changed, we construct &lt;b&gt;new&lt;/b&gt; strings as we go to represent computed values. So for example the expression &lt;code&gt;'hello' + 'there'&lt;/code&gt; takes in the 2 strings &lt;code&gt;'hello'&lt;/code&gt; and &lt;code&gt;'there'&lt;/code&gt; and builds a new string &lt;code&gt;'hellothere'&lt;/code&gt;. The resulting string has a different &lt;code&gt;id()&lt;/code&gt; because a new object is created and the others may then be garbage collected.
&lt;/p&gt;

&lt;p&gt;
Python string also recognize escape sequences similarly to C for example &lt;code&gt;'\n'&lt;/code&gt;  is recognized as a ASCII Linefeed. To prevent parsing of those one may use a &lt;i&gt;raw string&lt;/i&gt; by prepending and &lt;code&gt;r&lt;/code&gt; or &lt;code&gt;R&lt;/code&gt; to the string:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"H&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;i"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;"H\ni"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Hello"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;" World"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
H
i
H\ni
Id of Hello 139710321381872
Id of Hello World 139710321440048

&lt;/pre&gt;

&lt;p&gt;
Individual characters of a string can be accessed via &lt;code&gt;[]&lt;/code&gt; bracket notation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2c8ba19" class="outline-3"&gt;
&lt;h3 id="org2c8ba19"&gt;Python Lists&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2c8ba19"&gt;
&lt;p&gt;
Python has a great built-in list type named "list". List literals are written within square brackets &lt;code&gt;[ ]&lt;/code&gt;. Lists work similarly to strings - use the &lt;code&gt;len()&lt;/code&gt; function and square brackets [ ] to access data, with the first element at index &lt;code&gt;0&lt;/code&gt;. To access elements from the back use negative indices.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'red'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'green'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'red'&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Assignment with an &lt;code&gt;=&lt;/code&gt; on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.
&lt;/p&gt;

&lt;p&gt;
The "empty list" is just an empty pair of brackets &lt;code&gt;[ ]&lt;/code&gt;. The &lt;code&gt;+&lt;/code&gt; works to append two lists, so &lt;code&gt;[1, 2] + [3, 4]&lt;/code&gt; yields &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; (this is just like &lt;code&gt;+&lt;/code&gt; with strings).
&lt;/p&gt;

&lt;p&gt;
Lists in Python can (in contrast to arrays in C) hold values of different types.
&lt;/p&gt;

&lt;p&gt;
Python lists are also &lt;i&gt;mutable&lt;/i&gt;. In fact there are a lot of &lt;i&gt;methods&lt;/i&gt; to modify lists eg &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5896b74" class="outline-3"&gt;
&lt;h3 id="org5896b74"&gt;Python Tuples&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5896b74"&gt;
&lt;p&gt;
Tuples in Python are similar to lists with the difference that they are &lt;b&gt;immutable&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.
&lt;/p&gt;

&lt;p&gt;
Creating a tuple is as simple as putting different comma-separated values. Optionally you can put these comma-separated values between parentheses also. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tup1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'physics'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'chemistry'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1997&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"b"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"c"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The empty tuple is written as two parens containing nothing &lt;code&gt;tup1 = ()&lt;/code&gt;. To write a tuple containing a single value you have to include a comma, even though there is only one value &lt;code&gt;(77,)&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Like string indices, tuple indices start at 0, and they can be sliced, concatenated, and so on.
&lt;/p&gt;

&lt;p&gt;
However if tuples are eg concatenated via &lt;code&gt;+&lt;/code&gt; a new tuple is created:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
tuple:  (1, 2) with id:  140056518200328
tuple:  (1, 2, 3, 4) with id:  140056518172568

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org80a4df1" class="outline-3"&gt;
&lt;h3 id="org80a4df1"&gt;Python Sets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org80a4df1"&gt;
&lt;p&gt;
Since Python 2.6 there are set types (Mengentypen). 
A Set in Python is a data structure equivalent to sets in mathematics. It may consist of various elements; the order of elements in a set is undefined. You can add and delete elements of a set, you can iterate the elements of the set, you can perform standard operations on sets (union, intersection, difference). Besides that, you can check if an element belongs to a set.
&lt;/p&gt;

&lt;p&gt;
Unlike arrays, where the elements are stored as ordered list, the order of elements in a set is undefined (moreover, the set elements are usually not stored in order of appearance in the set; this allows checking if an element belongs to a set faster than just going through all the elements of the set).
&lt;/p&gt;

&lt;p&gt;
Any immutable data type can be an element of a set: a number, a string, a tuple. Mutable (changeable) data types cannot be elements of the set. In particular, lists cannot be an element of a set (but tuple can), and another set cannot be an element of a set. The requirement of immutability follows from the way how do computers represent sets in memory.
&lt;/p&gt;

&lt;p&gt;
Sets unlike lists or tuples can't have multiple occurrences of the same element → &lt;code&gt;set('a','b','c','a','b','c')&lt;/code&gt; → &lt;code&gt;{'a','b','c'}&lt;/code&gt; no values are duplicated.
&lt;/p&gt;

&lt;p&gt;
To create a set the &lt;code&gt;set()&lt;/code&gt; is called which constructs a Python set from the given iterable and returns it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# empty set&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="c1"&gt;# from string&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Python'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# from tuple&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;# from list&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="c1"&gt;# from range&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
set()
{'t', 'y', 'h', 'o', 'n', 'P'}
{'e', 'u', 'o', 'a', 'i'}
{'e', 'u', 'o', 'a', 'i'}
{0, 1, 2, 3, 4}

&lt;/pre&gt;

&lt;p&gt;
Sets are implemented in a way, which doesn't allow mutable objects. The following example demonstrates that we cannot include, for example, lists as elements:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="c1"&gt;# valid set of tuples&lt;/span&gt;

&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="c1"&gt;# -&amp;gt; TypeError: unhashable type: 'list'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Although sets can't contain mutable objects, sets are mutable themselves. Elements may for example added via the &lt;code&gt;add&lt;/code&gt; method (&lt;code&gt;cities.add("Tokyo")&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Frozensets are like sets except that they cannot be changed so they are immutable:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;frozenset&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;"Frankfurt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Basel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Freiburg"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Strasbourg"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# AttributeError: 'frozenset' object  has no attribute 'add'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There's also a simplified shorter notation to construct sets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Madrid"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;class 'set'&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
The known operations from set theory are also available via Python Sets (following part in German xD):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;len(s)&lt;/code&gt; gibt Mächtigkeit der Menge &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 | s2&lt;/code&gt; gibt Vereinigungsmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 &amp;amp; s2&lt;/code&gt; gibt Schnittmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 - s2&lt;/code&gt; gibt Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 ^ s2&lt;/code&gt; gibt symmetrische Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org89f6671" class="outline-3"&gt;
&lt;h3 id="org89f6671"&gt;Python Dictionaries&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org89f6671"&gt;
&lt;p&gt;
A dictionary is a collection which is unordered, changeable (mutable) and indexed. In Python dictionaries are written with curly brackets, and they have keys and values.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can access the items of a dictionary by referring to its key name, inside square brackets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
value
Mustang
1964

&lt;/pre&gt;

&lt;p&gt;
More on dictionaries and how to work with them / their methods &lt;a href="https://www.w3schools.com/python/python_dictionaries.asp"&gt;here&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb2c2bcc" class="outline-2"&gt;
&lt;h2 id="orgb2c2bcc"&gt;Loops and Iterations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb2c2bcc"&gt;
&lt;p&gt;
In C there are three types of loops:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;while loop&lt;/li&gt;
&lt;li&gt;do while loop&lt;/li&gt;
&lt;li&gt;for loop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
All of these loops use conditions are able to simulate one another. Which one to use is often a matter of personal taste.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org184bfcc" class="outline-3"&gt;
&lt;h3 id="org184bfcc"&gt;While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org184bfcc"&gt;
&lt;p&gt;
The while loop executes as long as a conditions is true resp. until a condition is false. This is the procedure:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Check if condition &lt;code&gt;while (expression/Condition)&lt;/code&gt; evaluates to true (nonzero)&lt;/li&gt;
&lt;li&gt;If yes: execute body of the loop and jump to 1.&lt;/li&gt;
&lt;li&gt;If no: resume program execution after the loop&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Program to find factorial of a number&lt;/span&gt;
&lt;span class="c1"&gt;// For a positive integer n, factorial = 1*2*3...n&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// printf("Enter an integer: ");&lt;/span&gt;
    &lt;span class="c1"&gt;// scanf("%d",&amp;amp;number); // cannot read from stdio in my blog :)&lt;/span&gt;
    &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// loop terminates when number is less than or equal to 0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// factorial = factorial*number;&lt;/span&gt;
	&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

	&lt;span class="c1"&gt;// alternatively: factorial *= number--;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Factorial= %lld"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Factorial= 120

&lt;/pre&gt;

&lt;p&gt;
Loops can be used to fill fields of an array:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// constant for array size&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Element %d of arr: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Element 0 of arr: 0
Element 1 of arr: 1
Element 2 of arr: 4
Element 3 of arr: 9
Element 4 of arr: 16
Element 5 of arr: 25
Element 6 of arr: 36
Element 7 of arr: 49
Element 8 of arr: 64
Element 9 of arr: 81
Element 10 of arr: 100
Element 11 of arr: 121
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5a72cc7" class="outline-3"&gt;
&lt;h3 id="org5a72cc7"&gt;Do While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5a72cc7"&gt;
&lt;p&gt;
The do while loop is similar to the while loop with the difference being that the do while loop checks the condition &lt;b&gt;after&lt;/b&gt; it has run, therefore it always runs at least one time.
The syntax is
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// notice the semicolon!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org312c1c8" class="outline-3"&gt;
&lt;h3 id="org312c1c8"&gt;For Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org312c1c8"&gt;
&lt;p&gt;
A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;mutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eg&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;decrement&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// "conditon" and "mutation" are expressions (see C standard) but that is how they're used commonly&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Here is the flow of control in a 'for' loop :
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the init step is executed first, and only once
&lt;ul class="org-ul"&gt;
&lt;li&gt;this step allows you to declare and initialize any loop control variables&lt;/li&gt;
&lt;li&gt;you are not required to put a statement here, as long as a semicolon appears&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;next, the condition is evaluated
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the body of the loop is executed&lt;/li&gt;
&lt;li&gt;if it is false, the body of the loop does not execute and the flow of control jumps to the next statement just after the 'for' loop&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;after the body of the 'for' loop executes, the flow of control jumps back up to the mutation statement
&lt;ul class="org-ul"&gt;
&lt;li&gt;this statement allows you to update any loop control variables&lt;/li&gt;
&lt;li&gt;This statement can be left blank, as long as a semicolon appears after the condition&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the condition is now evaluated again 
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the loop executes and the process repeats itself (body of loop, then mutation step, and then again condition)&lt;/li&gt;
&lt;li&gt;after the condition becomes false, the 'for' loop terminates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Omitting expressions:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// omitting initalization&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d. argument: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;


  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;;)&lt;/span&gt; &lt;span class="c1"&gt;// endless loop&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The answer is 42&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 


  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// never reached&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Dont forget it is possible to have more complex conditions and multiple assignments!
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d, %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2, 1
3, 2
4, 3
5, 4

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7aba6ab" class="outline-3"&gt;
&lt;h3 id="org7aba6ab"&gt;&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7aba6ab"&gt;
&lt;p&gt;
Loops run as long as the loop condition evaluates to true. There are however two ways to modify the control flow from &lt;i&gt;inside the function body&lt;/i&gt;:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; stops execution of the loop regardless of the loop condition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; immediately starts the next evaluation of first the loop condition and possibly the next loop iteration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; should be used sparsely - an excessive use might be an indicator for insufficient program logic.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* reciprocal .c -- calculate reciprocal value of array elements */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* a negative value indicates end of list */&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.5&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.1415&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.33333&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.7182&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;42.23&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// notice the condition!&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d value : %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0 value : 1.000000
1 value : 2.000000
2 value : 0.318319
3 value : 3.000030
4 value : 0.000000
5 value : 0.367891
6 value : 0.023680

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8e0127e" class="outline-2"&gt;
&lt;h2 id="org8e0127e"&gt;Loops in Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e0127e"&gt;
&lt;p&gt;
There are two types of loops in Python &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;.
The &lt;code&gt;while&lt;/code&gt; loops are similar to their pendants in C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"i ="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
i = 5
i = 4
i = 3
i = 2
i = 1

&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are also available in Python with the same semantic as in C.
&lt;/p&gt;

&lt;p&gt;
In addition to what we know from C in Python there can be an optional &lt;code&gt;else&lt;/code&gt; branch after a loop which is executed &lt;b&gt;after the loop finished&lt;/b&gt; if it was &lt;b&gt;not canceled&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"1. Loop finished execution"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"------------"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"2. Loop finished execution"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# not executed because loop doesnt finish naturally but is canceled&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0
1
2
1. Loop finished execution
------------
0
1
2

&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;else&lt;/code&gt; can also be used with the for loop in Python!
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;for&lt;/code&gt; loop in Python iterates over a given &lt;i&gt;sequence&lt;/i&gt; or &lt;i&gt;set&lt;/i&gt; (an iterable type!):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ITERABLE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
In the example above the elements of &lt;code&gt;ITERABLE&lt;/code&gt; are assigned to &lt;code&gt;i&lt;/code&gt; one by one per iteration.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'John'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'Paul'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'George'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'Pete'&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
 &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
John
Paul
George
Pete

&lt;/pre&gt;

&lt;p&gt;
This also works for mixed types:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Alpha'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
AlphaAlpha
96
0.4
(1, 2, 3, 1, 2, 3)

&lt;/pre&gt;

&lt;p&gt;
To "mimic" the C for loop we can iterate over a &lt;i&gt;sequence&lt;/i&gt; of numbers using the &lt;code&gt;range&lt;/code&gt; function:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# range([start,] stop [, step]) # generate from 'start' up to and NOT INCLUDING 'stop' and increment by 'step'&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"------------"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0
2
4
------------
0
1
2

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90be5d3" class="outline-2"&gt;
&lt;h2 id="org90be5d3"&gt;Iterators and Loop Functions in C&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org90be5d3"&gt;
&lt;p&gt;
Code sample of an iterator with C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"John"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Paul"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"George"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Ringo"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// so the iterator can be used multiple times -&amp;gt; first ALWAYS returns first element&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// set index to 0 when arrived at last element delmiited via NULL&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%s "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
John Paul George Ringo

&lt;/pre&gt;

&lt;p&gt;
Iterators like those above are more common in C++ where they are more elegant (also in C there are prettier ways to do this).
&lt;/p&gt;

&lt;p&gt;
Until now we used loops with assignments (state model). It is also possible to have loops in the functional model where they are realized via recursion:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Ctuhlu!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// i-- would NOT work because i is evaluated -&amp;gt; 3 and passed to the function and THEN decremented -&amp;gt; endless loop&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Ctuhlu!
Ctuhlu!
Ctuhlu!

&lt;/pre&gt;

&lt;p&gt;
It is also possible to separate the loop body from the "loop mechanic" → &lt;i&gt;generic loop function&lt;/i&gt;. To do so we use a &lt;i&gt;pointer to functions&lt;/i&gt;.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;functionPointer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// functions are passed by pointer (efficiency) need to be wrapped in () else it would be interpreted as "void*" return type (pointer to void) instead&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;functionPointer&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loopBody&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d^2 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loopBody&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0^2 = 0
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25

&lt;/pre&gt;

&lt;p&gt;
In Python such things are achievable more easily via &lt;a href="https://www.programiz.com/python-programming/anonymous-function"&gt;lambda functions&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org54d7fb9" class="outline-2"&gt;
&lt;h2 id="org54d7fb9"&gt;Equivalence&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org54d7fb9"&gt;
&lt;p&gt;
Generally every loop in a program can be translated into a recursive function and each (trivially) recursive function can be computed via loops. To be precise: &lt;i&gt;primitive-recursive functions&lt;/i&gt; can be computed with &lt;i&gt;a priori limited&lt;/i&gt; loops, for the so called &lt;i&gt;μ-recursive functions&lt;/i&gt; (&lt;i&gt;my&lt;/i&gt; "müh" xD as i like to call it). The ACKERMANN-Function for example is not trivially recursive.
&lt;/p&gt;

&lt;p&gt;
So for the most practical use cases loops and recursion are equipotent (gleichmächtig). However loops are usually more clearer (übersichtlicher), but there are also cases where recursion are the handier solution.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</guid><pubDate>Sun, 04 Nov 2018 23:00:00 GMT</pubDate></item></channel></rss>