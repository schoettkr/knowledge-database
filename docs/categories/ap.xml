<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knowledge Database (Posts about A&amp;P)</title><link>https://schoettkr.github.io/knowledge-database/</link><description></description><atom:link href="https://schoettkr.github.io/knowledge-database/categories/ap.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:schoettkr@gmail.com"&gt;schoettkr&lt;/a&gt; </copyright><lastBuildDate>Mon, 26 Nov 2018 14:47:58 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Algos &amp; Programming - Lecture 14</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-14/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org193541e" class="outline-2"&gt;
&lt;h2 id="org193541e"&gt;Design and Correctness of Algorithms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org193541e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org035cf35" class="outline-3"&gt;
&lt;h3 id="org035cf35"&gt;Pseudocode&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org035cf35"&gt;
&lt;p&gt;
As we've learnt in the last lecture &lt;i&gt;pseudocode&lt;/i&gt; is one of the most popular semiformal specification languages.
&lt;/p&gt;

&lt;p&gt;
Pseudocode generally defines a set of instructions, there are no strict rules on how pseudocode needs to look like, therefore there are many forms of it, which is okay as long as it is intuitively readable.
&lt;/p&gt;

&lt;p&gt;
Example pseudocode for the Euclidian Algorithm:
&lt;/p&gt;

&lt;p style="background:lightgrey;"&gt;
&lt;b&gt;Require:&lt;/b&gt; A, B ∈ N, A &amp;gt; 0 ∩ B &amp;gt; 0&lt;br&gt;
&lt;b&gt;Ensure:&lt;/b&gt; a = b = gcd(A, B)&lt;br&gt;
a ← A; b ← B&lt;br&gt;
&lt;b&gt;while&lt;/b&gt; a ≠ b &lt;b&gt;do&lt;/b&gt;&lt;br&gt;
   &lt;b&gt;if&lt;/b&gt; a &amp;lt; b &lt;b&gt;then&lt;/b&gt;&lt;br&gt;
      b ← b - a&lt;br&gt;
   &lt;b&gt;else&lt;/b&gt;&lt;br&gt;
      a ← a - b&lt;br&gt;
   &lt;b&gt;end if&lt;/b&gt;&lt;br&gt;
&lt;b&gt;end while&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
The slides note at this point that in the future we'll often look at algorithms in pseudo code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6a583f8" class="outline-3"&gt;
&lt;h3 id="org6a583f8"&gt;Correctness&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6a583f8"&gt;
&lt;p&gt;
When you find an approach for a problem / an algorithm, the &lt;i&gt;correctness&lt;/i&gt; has to be validated.
&lt;/p&gt;

&lt;p&gt;
It is advised to verify the correctness of the idea first and then the correctness of the concrete algorithm.
The correctness of an idea cannot be verified formally, but the following things should be pondered:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;does the idea work &lt;i&gt;in general&lt;/i&gt; or just for a &lt;i&gt;specific case&lt;/i&gt;?&lt;/li&gt;
&lt;li&gt;are there &lt;i&gt;special cases&lt;/i&gt; in which the idea does not work out? are these relevant?&lt;/li&gt;
&lt;li&gt;try finding an &lt;i&gt;counter-example&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;what about &lt;i&gt;extreme cases&lt;/i&gt;?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
What follows on slides 25-30 are some example problems and ideas to solve them, take a look there if you want.
&lt;/p&gt;

&lt;p&gt;
As stated before the correctness of the concrete algorithm also has to be validated. There are in general two ways to do this:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Exhaustive Testing&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;verify that there is no incorrect behaviour in the implementation of the algorithm by testing/executing it with all possible data inputs/combinations&lt;/li&gt;
&lt;li&gt;Problems:
&lt;ul class="org-ul"&gt;
&lt;li&gt;usually this is &lt;i&gt;impossible&lt;/i&gt; since the possible data combinations are really large or even infinite&lt;/li&gt;
&lt;li&gt;&lt;i&gt;partial testing&lt;/i&gt; may boost the confidence in regards to the correctness of a program/algorithm, but does not replace a proof&lt;/li&gt;
&lt;li&gt;a good selection of test cases is difficult&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Correctness Proof&lt;/b&gt; (Korrektheitsbeweis)
&lt;ul class="org-ul"&gt;
&lt;li&gt;verify correct behaviour via mathematical methods/proofs&lt;/li&gt;
&lt;li&gt;Problems:
&lt;ul class="org-ul"&gt;
&lt;li&gt;are difficult or impossible on the level of implementation because of lacking formalization&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
To proof the correctness it can be performed on a more &lt;i&gt;abstract level&lt;/i&gt; instead. Mistakes are then however possible when performing the concrete implementation. We'll continue to look at proofs and not tests.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org050c734" class="outline-3"&gt;
&lt;h3 id="org050c734"&gt;Proofs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org050c734"&gt;
&lt;p&gt;
Slides: Informale Definition = Ein Beweis ist eine Herleitung einer Aussage aus bereits bewiesenen Aussagen und/oder Grundannahmen (Axiomen)
&lt;/p&gt;

&lt;p&gt;
We know a few different (but still combinable) methods for proofs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;deduction&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;classical proof via combination of premises&lt;/li&gt;
&lt;li&gt;eg: all humans are mortal(premise 1) &amp;amp; all kings are humans (premise 2) → all kings are mortal (conclusion/deduction)&lt;/li&gt;
&lt;li&gt;the correctness of the premises has to be given axiomatically or already been proven&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;complete case analysis/differentiation&lt;/b&gt; (vollständige Fallunterscheidung)
&lt;ul class="org-ul"&gt;
&lt;li&gt;when there are a finite amount of cases/variants then each one can be inspected individually&lt;/li&gt;
&lt;li&gt;if a statement is true for &lt;i&gt;every&lt;/i&gt; case/variant then the statement is true as a whole&lt;/li&gt;
&lt;li&gt;eg: "all odd integers in the intervall [2&lt;sup&gt;1&lt;/sup&gt;, 2&lt;sup&gt;3&lt;/sup&gt;] are prime numbers" (statement) → 3 is prime, 5 is prime, 7 is prime → statement is true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;complete /transfinite induction&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;base cases (Induktionsanker/-anfang IA) show that a statement is valid for a special (smallest/first) case (often \(n = 0\) or \(n = 1\))&lt;/li&gt;
&lt;li&gt;step case / inductive step (Induktionsschritt)
&lt;ul class="org-ul"&gt;
&lt;li&gt;assume that the statement holds true for \(n=k\) (Induktionsvoraussetzung IV) and prove that then the statements holds for \(n=k+1\); proof that the &lt;i&gt;induction hypothesis&lt;/i&gt; follows from the &lt;i&gt;induction requirement&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;Induktionsschluss → inference (Folgerung) that the statement holds for all cases starting at the first&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;indirect proof&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;assume the opposite of the hypothesis/statement and find a disproof via axioms and proven concepts → inference that the assumption is wrong and therefore the hypothesis/statment is true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6d2bb1e" class="outline-3"&gt;
&lt;h3 id="org6d2bb1e"&gt;Proofs of Algorithms&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6d2bb1e"&gt;
&lt;p&gt;
To prove an algorithm you have to ask two questions. 1) What is there to be proven (Specification)? 2.) What is already known?
&lt;/p&gt;

&lt;p&gt;
A distinction is made between 2 kinds of "correctness":
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;partial correctness&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an algorithm is &lt;i&gt;partially correct&lt;/i&gt; if an answer is returned that this answer will be correct (slides: ein Algorithmus is partiell korrekt, wenn er für eine spezifizerte erfüllte Vorbedingung Q bei einer eventuellen/möglichen Terminierung eine spezifizerte Nachbedingung R erreicht, dh R is nach Ausführung erfüllt)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;total correctness&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;total correctness requires additionally to partial correctness that the algorithm &lt;b&gt;terminates&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
So, &lt;i&gt;if&lt;/i&gt; a partial correct algorithm terminates he yields a correct result and a total correct algorithm yields the correct result after a finite amount of time. 
&lt;/p&gt;

&lt;p&gt;
In the next lecture/post we look a sorting algorithms and how/what kind of correctness we can prove there :P
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-14/</guid><pubDate>Fri, 23 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 13</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-13/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org8c4d7fa" class="outline-2"&gt;
&lt;h2 id="org8c4d7fa"&gt;Design and Correctness of Algorithms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8c4d7fa"&gt;
&lt;p&gt;
The first slides of this lecture chapter is just some meta information about the right mindset to create algorithms, which I find to be trivial, that's why I don't repeat that here (slides 1-5).
&lt;/p&gt;

&lt;p&gt;
We usually create a model for a problem (Modellierung) to abstract and reduce it. Especially mathematical concepts are suited as modeling approaches (Modellierungsansätze):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;sets, multisets&lt;/li&gt;
&lt;li&gt;permutations&lt;/li&gt;
&lt;li&gt;trees/hierarchies&lt;/li&gt;
&lt;li&gt;graphs&lt;/li&gt;
&lt;li&gt;points (geometry)&lt;/li&gt;
&lt;li&gt;polygons&lt;/li&gt;
&lt;li&gt;strings&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga3744c0" class="outline-3"&gt;
&lt;h3 id="orga3744c0"&gt;Excourse: Graphs&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga3744c0"&gt;
&lt;p&gt;
Graphs are often used for modelling. A graph is a ordered pair \((V,E)\), where \(V\) is a set of nodes/vertices (Knoten) \(V = {v_1, v_2, v_3,.., v_n}\) and \(E\) is a set of edges (Kanten/Linien) \(E = {e_1, e_2, .., e_m}\). Depending on the type of graph, \(E\) is:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;in &lt;b&gt;undirected*/*simple&lt;/b&gt; (ungerichtete) graphs &lt;b&gt;without multiple edges&lt;/b&gt; \(E\) is a &lt;b&gt;2-element subset&lt;/b&gt; of \(V\)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;directed&lt;/b&gt; (gerichteten) graphs &lt;b&gt;without multiple edges&lt;/b&gt; \(E\) is a &lt;b&gt;subset&lt;/b&gt; of all pairs/2-tuples (i,j) which result from the cartesian product of \(V * V\)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;undirected&lt;/b&gt; graphs with "zusammengefassten" &lt;b&gt;multiple edges&lt;/b&gt; (=Multigraph) \(E\) is a &lt;b&gt;multiset&lt;/b&gt; (Menge die Duplikate erlaubt) "über die Menge \(W\)" of all &lt;b&gt;2-element subsets&lt;/b&gt; of \(V\) (?weighted graph?)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;directed&lt;/b&gt; graphs with "zusammengefassten" &lt;b&gt;multiple edges&lt;/b&gt; (=Multigraph) \(E\) is a &lt;b&gt;multiset&lt;/b&gt;  "über dem kartesischen Produkt \(V * V\)" (?weighted graph?)&lt;/li&gt;
&lt;li&gt;in &lt;b&gt;hypergraphs&lt;/b&gt; \(E\) is a subset of the power set of \(V\)&lt;/li&gt;
&lt;li&gt;wiki: in gerichteten Graphen mit eigenständigen Mehrfachkanten eine beliebige Menge, deren Elemente mit Hilfe von zwei Funktionen {\displaystyle \mathrm {src} ,\mathrm {tgt} : E→ V} {\mathrm  {src}},{\mathrm  {tgt}}: E→ V die den Elementen einen Quell- bzw. Zielknoten zuordnen, als Kanten angesehen werden (so ein Graph ist dasselbe wie ein Funktor {\displaystyle G: {\mathcal {G}}→ \mathbf {Set} } G: {\mathcal  G}→ {\mathbf  {Set}}, wobei {\displaystyle {\mathcal {G}}} {\mathcal  G} die recht überschaubare Kategorie {\displaystyle {\mathcal {G}}=\{V{\stackrel {\mathrm {src} }{\longleftarrow }}E{\stackrel {\mathrm {tgt} }{\longrightarrow }}V\}} {\mathcal  G}=\{V{\stackrel  {{\mathrm  {src}}}\longleftarrow }E{\stackrel  {{\mathrm  {tgt}}}\longrightarrow }V\} mit zwei Objekten und zwei ausgezeichneten Pfeilen ist)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Slides: Kanten können Werte (Gewichte) zugewiesen werden, w : E → R. In diesem Fall spricht man von einem gewichteten Graph.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;i&gt;gerichteter&lt;/i&gt; Graph hat Pfeile an Kanten die die Richtung angeben&lt;/li&gt;
&lt;li&gt;&lt;i&gt;gewichteter&lt;/i&gt; Graph hat Werte an Kanten stehen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Two blog posts on graphs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8"&gt;https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38"&gt;https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The model of the graph is seperate of any concrete data structures. C for example does not have a built-in data type for graphs so you might need to implement one yourself. Furthermore just because a problem was modeled with a specific approach/model does not mean that a respective data structure is always needed to implement the approach.
&lt;/p&gt;

&lt;p&gt;
However if you find yourself in the need of such data structure there are a multitude of approaches to implement it such. Here are two:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;via &lt;b&gt;adjacency matrix&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;a square matrix to represent a finite graph&lt;/li&gt;
&lt;li&gt;the elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph&lt;/li&gt;
&lt;li&gt;in 2d array each element &lt;code&gt;a_{i,j}&lt;/code&gt; holds information weather or not an edge connects the vertices &lt;code&gt;v_i&lt;/code&gt; and &lt;code&gt;v_j&lt;/code&gt; or which weight the edge has:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// -&amp;gt; edge between verticle 0 and verticle 1 exists&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;via &lt;b&gt;structs and pointers&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;vertices can be modelled as structs and edges as pointers inside of those:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxDegree&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;node_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Since graph theory is a relatively old field of mathematics there are a lot of theorems, laws and standard algorithms for solving certain problems.
&lt;/p&gt;

&lt;p style="color:red;"&gt;
TODO check those code examples
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org38e59ea" class="outline-3"&gt;
&lt;h3 id="org38e59ea"&gt;Specification&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org38e59ea"&gt;
&lt;p style="color:red;"&gt;
TODO check those code examples
&lt;/p&gt;

&lt;p&gt;
An algorithm has to be described somehow. One variant to do so would be in a concrete programming language. The problem with that is that different programming languages know different concepts and no programming language knows all concepts. C for example does not know data types and operations for mathematical sets by itself. Set operations in C could therefore look a bit unclear and obfuscate (verschleiern) the underlying algorithm which is the real point of interest.
&lt;/p&gt;

&lt;p&gt;
A solution to this is writing algorithms in a &lt;i&gt;specification&lt;/i&gt; (Spezifikationsprachen) of which there are many (natural languages are too inprecise btw) when the algorithm itself is the point of interest. 
&lt;/p&gt;

&lt;p&gt;
There are &lt;b&gt;formal&lt;/b&gt; and &lt;b&gt;semiformal&lt;/b&gt; specification languages. The former are automatically processable for example theorem proofs, however these are often hard to read. The latter serve the purpose of communicating about algorithms.
&lt;/p&gt;

&lt;p&gt;
We'll use the probably most popular semiformal specification language for imperative algorithms which is &lt;b&gt;pseudocode&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
And this (pseudocode) is where we will continue in the next lecture. Cya :)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-13/</guid><pubDate>Sun, 18 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 12</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org9e75314" class="outline-2"&gt;
&lt;h2 id="org9e75314"&gt;Bit Operators&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e75314"&gt;
&lt;p&gt;
In this lecture we started by covering bit operators. I've also written about those &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-03/"&gt;here&lt;/a&gt;. To keep it short (look at the link for more detailed explainations):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; bitwise &lt;b&gt;and&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; bitwise &lt;b&gt;or&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; bitwise &lt;b&gt;not&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; bitwise &lt;b&gt;xor&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bitwise-op.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Then there are the bitshift operators as well:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;8 &amp;lt;&amp;lt; n&lt;/code&gt; leftshift which is like multiplication with 2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;8 &amp;gt;&amp;gt; n&lt;/code&gt; rightshift which is like division with 2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are more operators in C. Some of them offer a shorter/more concise notation. The lecturer calls them "Faulheitsoperatoren" (lazy operators) I don't like that term because it can get mixed with "lazy evaluation" (which is called short circuit evaluatoin to be precise) rather easily. So I'll now just go over the operators we covered in the lecture next.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2bceece" class="outline-2"&gt;
&lt;h2 id="org2bceece"&gt;Comma Operator&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2bceece"&gt;
&lt;p&gt;
The wikipedia page on this operator is very well written, I have copied the valuable information to here:
&lt;/p&gt;

&lt;p&gt;
In the C and C++ programming languages, the comma operator (represented by the token &lt;code&gt;,&lt;/code&gt;) is a &lt;b&gt;binary operator&lt;/b&gt; that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).
&lt;/p&gt;

&lt;p&gt;
The use of the comma token as an operator is distinct from its use in function calls and definitions, variable declarations, enum declarations, and similar constructs, where it acts as a separator.
&lt;/p&gt;

&lt;p&gt;
The comma operator separates expressions (which have value) in a way analogous to how the semicolon terminates statements, and sequences of expressions are enclosed in parentheses analogously to how sequences of statements are enclosed in braces: &lt;code&gt;(a, b, c)&lt;/code&gt; is a sequence of expressions, separated by commas, which evaluates to the last expression &lt;code&gt;c&lt;/code&gt; while &lt;code&gt;{a; b; c;}&lt;/code&gt; is a sequence of statements, and does not evaluate to any value. A comma can only occur between two expressions – commas separate expressions – unlike the semicolon, which occurs at the end of a (non-block) statement – semicolons terminate statements.
&lt;/p&gt;

&lt;p&gt;
The comma operator has the lowest precedence of any C operator, and acts as a sequence point. In a combination of commas and semicolons, semicolons have lower precedence than commas, as semicolons separate statements but commas occur within statements, which accords with their use as ordinary punctuation: &lt;code&gt;a, b; c, d&lt;/code&gt; is grouped as &lt;code&gt;(a, b); (c, d)&lt;/code&gt; because these are two separate statements.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Commas act as separators in this line, not as an operator.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=0&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of b into i.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=2&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// parens are required here because '=' has higher precedence than ',' it would get treated as (int i = a), (int b); without the parens which would be a redeclaration of b with no linkage          &lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of a into i. Equivalent to (i = a), b;&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=1&lt;/span&gt;
&lt;span class="cm"&gt; *  (The curly braces on the second line are needed to&lt;/span&gt;
&lt;span class="cm"&gt; *   avoid a compiler error.  The second 'b' declared&lt;/span&gt;
&lt;span class="cm"&gt; *   is given no initial value.)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Increases value of a by 2, then assigns value of resulting operation a+b into i .&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=3, b=2, c=3, i=5&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Increases value of a by 2, then stores value of a to i, and discards unused&lt;/span&gt;
&lt;span class="cm"&gt; *  values of resulting operation a + b . Equivalent to (i = (a += 2)), a + b; &lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=3, b=2, c=3, i=3&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of a into i;  the following 'b' and 'c'&lt;/span&gt;
&lt;span class="cm"&gt; *  are not part of the initializer but declarators for&lt;/span&gt;
&lt;span class="cm"&gt; *  second instances of those variables.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=1&lt;/span&gt;
&lt;span class="cm"&gt; *  (The curly braces on the second line are needed to&lt;/span&gt;
&lt;span class="cm"&gt; *   avoid a compiler error.  The second 'b' and second&lt;/span&gt;
&lt;span class="cm"&gt; *   'c' declared are given no initial value.)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;     
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Assigns value of c into i, discarding the unused a and b values.&lt;/span&gt;
&lt;span class="cm"&gt; *  Results: a=1, b=2, c=3, i=3&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 6, not 4, since comma operator sequence points following the keyword &lt;/span&gt;
&lt;span class="cm"&gt; *  'return' are considered a single expression evaluating to rvalue of final &lt;/span&gt;
&lt;span class="cm"&gt; *  subexpression c=6 .&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 3, not 1, for same reason as previous example, that is return expressions must be fully evaluated before the function can return.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  Returns 3, not 1, still for same reason as above. This example works as it does&lt;/span&gt;
&lt;span class="cm"&gt; *  because return is a keyword, not a function call. Even though compilers will &lt;/span&gt;
&lt;span class="cm"&gt; *  allow for the construct return(value), the parentheses are only relative to "value"&lt;/span&gt;
&lt;span class="cm"&gt; *  and have no special effect on the return keyword.&lt;/span&gt;
&lt;span class="cm"&gt; *  Return simply gets an expression and here the expression is "(1), 2, 3".&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;Use cases&lt;/b&gt;: The comma operator has relatively limited use cases. Because it discards its first operand, it is generally only useful where the first operand has desirable side effects. Further, because it is rarely used outside of specific idioms, and easily mistaken with other commas or the semicolon, it is potentially confusing and error-prone. Nevertheless, there are certain circumstances where it is commonly used, notably in for loops and in SFINAE. For embedded systems which may have limited debugging capabilities, the comma operator can be used in combination with a macro to seamlessly override a function call, to insert code just before the function call.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;For Loops&lt;/i&gt;:
&lt;/p&gt;

&lt;p&gt;
The most common use is to allow multiple assignment statements without using a block statement, primarily in the initialization and the increment expressions of a for loop. This is the only idiomatic use in elementary C programming. In the following example, the order of the loop's initializers is significant:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// reverse print char array&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rev&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Outside of for loop initializers (which have a special use of semicolons), the comma might be used synonymously with the semicolon, particularly when the statements in question function similarly to a loop increment (e.g. at the end of a while loop):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Two statements on one line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
However, as this usage achieves the same thing as the semicolon in a visually different way, this is of dubious usefulness and might confuse readers.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Condition&lt;/i&gt;:
&lt;/p&gt;

&lt;p&gt;
The comma can be used within a condition (of an if, while, do while, or for) to allow auxiliary computations, particularly calling a function and using the result, with block scoping:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;// statements involving x and y&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;i&gt;Complex return&lt;/i&gt;:
The comma can be used in return statements, to assign to a global variable or out parameter (passed by reference). This idiom suggests that the assignments are part of the return, rather than auxiliary assignments in a block that terminates with the actual return. For example, in setting a global error number:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;failure&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This can be written more verbosely as:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;failure&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;i&gt;Avoid a block&lt;/i&gt;:
For brevity, the comma can be used to avoid a block and associated braces, as in:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
instead of:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9b592ea" class="outline-2"&gt;
&lt;h2 id="org9b592ea"&gt;Increment and Decrement Operator&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9b592ea"&gt;
&lt;p&gt;
Next up are &lt;code&gt;++&lt;/code&gt; increment and &lt;code&gt;--&lt;/code&gt; decrement operators which are unary operators that add or subtract one, to or from their operand. C like languages offer two versions (pre and post) of each operator with slighltly different semantics. Now guess what I've also written a bit about them &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/"&gt;here&lt;/a&gt; xD but that was a bit superficial so we'll repeat now.
&lt;/p&gt;

&lt;p&gt;
The increment operator increases, and the decrement operator decreases, the value of its operand by 1. The operand must have an arithmetic or pointer data type, and must refer to a modifiable data object. Pointers values are increased (or decreased) by an amount that makes them point to the next (or previous) element adjacent in memory → so eg incrementing a pointer via &lt;code&gt;++&lt;/code&gt; will increment it to point to the next element which would really be an incrementation of 8 when the base handled base type is a char for example.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;pre-increment&lt;/b&gt; and &lt;b&gt;pre-decrement&lt;/b&gt; operators increment (or decrement) their operand by 1, and the value of the expression is the resulting incremented (or decremented) value.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;post-increment&lt;/b&gt; and &lt;b&gt;post-decrement&lt;/b&gt; operators increase (or decrease) the value of their operand by 1, but the value of the expression is the operand's original value prior to the increment (or decrement) operation.
&lt;/p&gt;

&lt;p&gt;
Since the increment/decrement operator modifies its operand, use of such an operand more than once within the same expression can produce undefined results. For example, in expressions such as &lt;code&gt;x - ++x&lt;/code&gt;, it is not clear in what sequence the subtraction and increment operations should be performed. Such expressions generally invoke undefined behavior, and should be avoided.
&lt;/p&gt;

&lt;p&gt;
This example visualizes the difference between the post and prefix operators:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Increment operators&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 2, y is also 2&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 3, y is 2&lt;/span&gt;

&lt;span class="c1"&gt;// Decrement operators&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 2, y is 3&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// x is now 1, y is also 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
If these shorthand operators are just used for their side effect (which is de-/in-crementing the variable for example in the third for loop statement) then it does not matter which variant post or pre is used.
&lt;/p&gt;

&lt;p&gt;
Easy peazy my friend :D 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org72e4534" class="outline-2"&gt;
&lt;h2 id="org72e4534"&gt;Compound Assignment Operators&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org72e4534"&gt;
&lt;p&gt;
The next type of operators we cover are called &lt;b&gt;compound assignment operators&lt;/b&gt; ('Selbstzuweisungsoperatoren' in script). The following table visualizes their effects:
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Operator name&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Syntax&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Addition assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a += b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a + b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Subtraction assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a -= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a - b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Multiplication assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a *= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a * b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Division assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a /= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a / b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Modulo assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a %= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a % b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise AND assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;amp;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;amp; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise OR assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a ❘= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a ❘ b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise XOR assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a ^= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a ^ b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise leftshift assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;lt;&amp;lt;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;lt;&amp;lt; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bitwise rightshift assignment&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a &amp;gt;&amp;gt;= b&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;a = a &amp;gt;&amp;gt; b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Be careful, while &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; are somewhat common to see, the others might be confusing and it is okay to not use them as much.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbfaa6b9" class="outline-2"&gt;
&lt;h2 id="orgbfaa6b9"&gt;Operator Precedence and Associativity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbfaa6b9"&gt;
&lt;p&gt;
When multiple operators are used in an expression, the evaluation order depends on the &lt;i&gt;precedence&lt;/i&gt; and / associativity/ of the operators.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;order of operations&lt;/b&gt; (or &lt;b&gt;operator precedence&lt;/b&gt;) is a collection of rules that reflect conventions about which procedures to perform first in order to evaluate a given mathematical expression.
&lt;/p&gt;

&lt;p&gt;
For example, in mathematics and most computer languages, multiplication is granted a higher precedence than addition, and it has been this way since the introduction of modern algebraic notation. Thus, the expression &lt;code&gt;2 + 3 × 4&lt;/code&gt; is interpreted to have the value &lt;code&gt;2 + (3 × 4) = 14&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Skript: Operatoren mit höherer Priorität werden zuerst ausgewertet
&lt;/p&gt;


&lt;p&gt;
The &lt;b&gt;associativity&lt;/b&gt; of an operator is a property that determines how operators of the same precedence are grouped in the absence of parentheses. If an operand is both preceded and followed by operators, and those operators have equal precedence, then the operand may be used as input to two different operations (i.e. the two operations indicated by the two operators). The choice of which operations to apply the operand to, is determined by the &lt;i&gt;"associativity"&lt;/i&gt; of the operators.
&lt;/p&gt;

&lt;p&gt;
Operators may be &lt;b&gt;associative&lt;/b&gt; (meaning the operations can be grouped arbitrarily), &lt;b&gt;left-associative&lt;/b&gt; (meaning the operations are grouped from the left), &lt;b&gt;right-associative&lt;/b&gt; (meaning the operations are grouped from the right) or &lt;b&gt;non-associative&lt;/b&gt; (meaning operations cannot be chained, often because the output type is incompatible with the input types).
&lt;/p&gt;

&lt;p&gt;
The associativity and precedence of an operator is a part of the definition of the programming language; different programming languages may have different associativity and precedence for the same type of operator.
&lt;/p&gt;

&lt;p&gt;
Consider the expression &lt;code&gt;a ~ b ~ c&lt;/code&gt;. If the operator &lt;code&gt;~&lt;/code&gt; has left associativity, this expression would be interpreted as &lt;code&gt;(a ~ b) ~ c&lt;/code&gt;. If the operator has right associativity, the expression would be interpreted as &lt;code&gt;a ~ (b ~ c)&lt;/code&gt;. If the operator is non-associative, the expression might be a syntax error, or it might have some special meaning. 
&lt;/p&gt;

&lt;p&gt;
Some mathematical operators have inherent associativity. For example, subtraction and division, as used in conventional math notation, are inherently left-associative. Addition and multiplication, by contrast, are both left and right associative eg &lt;code&gt;(a * b) * c = a * (b * c))&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Skript: Assoziativität bestimmt die Richtung der Auswertung
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C++#Compound_assignment_operators"&gt;Wiki C Precedence / Associativity Table&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Table and notes below from &lt;a href="https://en.cppreference.com/w/c/language/operator_precedence"&gt;cppreference.com&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/c-table.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression &lt;code&gt;*p++&lt;/code&gt; is parsed as &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;(*p)++&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression &lt;code&gt;a=b=c&lt;/code&gt; is parsed as &lt;code&gt;a=(b=c)&lt;/code&gt;, and not as &lt;code&gt;(a=b)=c&lt;/code&gt; because of &lt;i&gt;right-to-left associativity&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Precedence and associativity are independent from order of evaluation.
&lt;/p&gt;

&lt;p&gt;
The C language standard doesn't specify operator precedence. It specifies the language grammar, and the precedence table is derived from it to simplify understanding. There is a part of the grammar that cannot be represented by a precedence table: an assignment-expression is not allowed as the right hand operand of a conditional operator, so &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed, and therefore relative precedence of conditional and assignment operators cannot be described easily.
&lt;/p&gt;

&lt;p&gt;
However, many C compilers use non-standard expression grammar where &lt;code&gt;?:&lt;/code&gt; is designated higher precedence than &lt;code&gt;=&lt;/code&gt;, which parses that expression as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, which then fails to compile due to semantic constraints: &lt;code&gt;?:&lt;/code&gt; is never lvalue and &lt;code&gt;=&lt;/code&gt; requires a modifiable lvalue on the left. This is the table presented on this page.
&lt;/p&gt;

&lt;p&gt;
Note that this is different in C++, where the conditional operator has the same precedence as assignment.
&lt;/p&gt;

&lt;p&gt;
Associativity specification is redundant for unary operators and is only shown for completeness: &lt;i&gt;unary prefix&lt;/i&gt; operators always associate right-to-left eg &lt;code&gt;sizeof ++*p&lt;/code&gt; is
 &lt;code&gt;sizeof(++(*p))&lt;/code&gt; and &lt;i&gt;unary postfix&lt;/i&gt; operators always associate left-to-right
 eg &lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Remeber when in doubt use parentheses as it improves readability as well!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgae52c08" class="outline-2"&gt;
&lt;h2 id="orgae52c08"&gt;Abstract Machines (Automaten)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgae52c08"&gt;
&lt;p&gt;
The next part of the chapter dealt with abstract machines. The slides are hard to convert to a blog format and it did not seem to be important for the course so I'll just skip over some stuff here. You should still take a look &lt;a href="https://osg.informatik.tu-chemnitz.de/lehre/aup/aup-06-Logik-handout_de.pdf"&gt;here&lt;/a&gt; (lecture slides 06: slide 40).
&lt;/p&gt;

&lt;p&gt;
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types – deterministic finite state machines and non-deterministic finite state machines. A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.
&lt;/p&gt;

&lt;p&gt;
Slides: Ein endlicher (deterministischer) Automat (EA, Zustandsmaschine, finite state machine ➡ FSM, auch: finite state automata) ist ein Modell zur Beschreibung von Abläufen (z.B. in Computern). Ein EA besteht aus einer Menge von &lt;i&gt;Zuständen&lt;/i&gt; S (states) und &lt;i&gt;Zustandsübergängen&lt;/i&gt; T : S × Γ → S (Transitionen, transitions). Ein EA startet in einem &lt;i&gt;Startzustand&lt;/i&gt;. Er „verarbeitet“ eine Sequenz von &lt;i&gt;Zeichen&lt;/i&gt; oder &lt;i&gt;Ereignissen&lt;/i&gt; Γ. Dabei bestimmt das nächste Zeichen/Ereignis, in welchen Zustand der EA wechselt. Ein EA kann einen oder mehrere &lt;i&gt;Endzustände&lt;/i&gt; (accepting states) besitzen. Wird ein solcher Zustand erreicht, ist die Abarbeitung beendet.
&lt;/p&gt;

&lt;p&gt;
Transitions (Zustandsveränderungen) in a state machine (endlichem Automaten) can lead to &lt;i&gt;actions&lt;/i&gt; or &lt;i&gt;output&lt;/i&gt;.
Transducers (Transduktor, ein spezieller endlicher Automat der im Ggsatz zu einem Akzeptor eine Ausgabe erzeugt, überführt/übersetzt eine Quellsprache in eine Zielsprache) generate output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.
&lt;/p&gt;

&lt;p&gt;
In control applications, two types are distinguished:
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Moore machine&lt;/b&gt;:
&lt;/p&gt;

&lt;p&gt;
The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: "command&lt;sub&gt;open&lt;/sub&gt;" and "command&lt;sub&gt;close&lt;/sub&gt;", which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: "door is open" or "door is closed". Slides: Aktion/Ausgabe ist an die Ankunft in einem bestimmten Zustand gebunden
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/moore.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;Mealy machine&lt;/b&gt;:
&lt;/p&gt;

&lt;p&gt;
The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in the picture below shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): "start motor to close the door if command&lt;sub&gt;close&lt;/sub&gt; arrives" and "start motor in the other direction to open the door if command&lt;sub&gt;open&lt;/sub&gt; arrives". The "opening" and "closing" intermediate states are not shown. Slides: Aktion/Ausgabe ist an einen bestimmten Übergang gebunden
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/mealy.png" alt="nil"&gt;
&lt;/p&gt;



&lt;p&gt;
Finite state machines are closely related to regular grammars because to every regular grammar there exists at least one FSM which accepts all expressions of that language (slides: Jede Folge von zulässigen Eingabesymbolen bzw. -ereignissen, die in einen Endzustand führen, entspricht einer formalen Sprache, die durch eine reguläre Grammatik beschrieben werden kann).
&lt;/p&gt;

&lt;p&gt;
However a FSM is not sufficient for context free languages.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/</guid><pubDate>Thu, 15 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 11</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org35c18e5" class="outline-2"&gt;
&lt;h2 id="org35c18e5"&gt;Logic and Abstract Machines (Automaten)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35c18e5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc02a1f6" class="outline-3"&gt;
&lt;h3 id="orgc02a1f6"&gt;Boolean Algebra&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc02a1f6"&gt;
&lt;p&gt;
Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively.
&lt;b&gt;Propositional logic&lt;/b&gt; (Aussagenlogik) is a branch of logic which deals with propositions (which can be true or false) and argument flow. Compound propositions are formed by connecting propositions by logical connectives. The propositions without logical connectives are called atomic propositions. 
&lt;/p&gt;

&lt;p&gt;
Principles:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;principle of bivalence&lt;/b&gt; (Zweiwertigkeit) → every proposition (Aussage) is either true (truthy) or false (falsy)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle/law of excluded third/middle&lt;/b&gt; → for any proposition, either that proposition is true or its negation is true - no third possibility is given&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle/law of noncontradiction&lt;/b&gt; → no proposition can be true and false at the same time&lt;/li&gt;
&lt;li&gt;&lt;b&gt;principle of extensionality&lt;/b&gt; → the truth value of a composite proposition (Aussageverknüpfung) only depends on the truth value of its components&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
F 3./4.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbcbba1b" class="outline-4"&gt;
&lt;h4 id="orgbcbba1b"&gt;Logical Composition&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgbcbba1b"&gt;
&lt;p&gt;
The following logical compositions (Verknüpfungsfunktionen) will be inserted as pictures from the lecture slides because it is pretty time-consuming to port it over.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/logical-comp-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/logical-comp-2.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
A set of logical compositions that is able to express all other compositions is called &lt;b&gt;logically/functionally complete&lt;/b&gt; (logisch vollständig)
&lt;/p&gt;

&lt;p&gt;
More laws and rules from lecture slides:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bool-law-1.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/bool-law-2.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3cb7059" class="outline-4"&gt;
&lt;h4 id="org3cb7059"&gt;Normal Form&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3cb7059"&gt;
&lt;p&gt;
Normal forms can help with unifying boolean expressions/propositions which can get unclearly fast (unübersichtlich):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;disjunctive normal form&lt;/b&gt; → is a standardization (or normalization) of a logical formula which is a disjunction of conjunctive clauses; it can also be described as an &lt;b&gt;OR&lt;/b&gt; of &lt;b&gt;ANDs&lt;/b&gt; or a sum of products
&lt;ul class="org-ul"&gt;
&lt;li&gt;slides: Eine boolsche Funktion ist in disjunktiver Normalform (DNF), wenn sie eine Disjunktion (Oder) von Konjunktionsstermen (Und) ist, wobei die Konjunktionsterme nur (ggf. negierten) Funktionsparameter enthält&lt;/li&gt;
&lt;li&gt;\(y = \vee_i (\wedge_j [\neg] x_{i,j}) \)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;conjunctive normal form&lt;/b&gt; → is a conjunction of one or more clauses, where a clause is a disjunction of literals; otherwise put, it is an &lt;b&gt;AND&lt;/b&gt; of &lt;b&gt;ORs&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;slides: Eine boolsche Funktion ist in konjunktiver Normalform (KNF), wenn sie eine Konjunktion (Und) von Disjunktionstermen (Oder) ist, wobei die Disjunktionsterme nur (ggf. negierten) Funktionsparameter enthält&lt;/li&gt;
&lt;li&gt;\(y = \wedge_i (\vee_j  [\neg] x_{i,j}) \)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are different ways to create normal forms eg conversions via boolean algebra or by using truth tables:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/normalform.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
At this point the Karnaugh-Veitch Diagram for optimization purposes was mentioned which I'm skipping here. Take a look at slide 13 if you want (I don't lol).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc3eee68" class="outline-2"&gt;
&lt;h2 id="orgc3eee68"&gt;Logic in C&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc3eee68"&gt;
&lt;p&gt;
C uses logical (boolean) propositions/expressions and knows an according type. However since that type is so close to integer, it was not made explicitly available before C99. Since C99 however there is &lt;code&gt;_Bool&lt;/code&gt;. Via including &lt;code&gt;stdbool.h&lt;/code&gt; the type &lt;code&gt;bool&lt;/code&gt; is available which is a synonym for &lt;code&gt;_Bool&lt;/code&gt; and can hold the values &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
But remember that everywhere were a boolean type is required there can always be an integer. If so &lt;code&gt;0&lt;/code&gt; is always interpreted as &lt;code&gt;false&lt;/code&gt; and &lt;i&gt;every other&lt;/i&gt; value as &lt;code&gt;true&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The logic/boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in C do so called &lt;b&gt;short-circuit evaluation&lt;/b&gt; from left to right which means the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression: when the first argument of the &lt;b&gt;AND&lt;/b&gt; function evaluates to &lt;code&gt;false&lt;/code&gt;, the overall value must be &lt;code&gt;false&lt;/code&gt;; and when the first argument of the &lt;b&gt;OR&lt;/b&gt; function evaluates to &lt;code&gt;true&lt;/code&gt;, the overall value must be &lt;code&gt;true&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Short-circuit operators are, in effect, control structures rather than simple arithmetic operators, as they are not strict. In imperative language terms (notably C and C++), where side effects are important, short-circuit operators introduce a sequence point – they completely evaluate the first argument, including any side effects, before (optionally) processing the second argument (es ist eine gängige Programmiertechnik, links im Kurzschlussoperator eine Bedingung abzusichern, die rechts zu einem Laufzeitfehler führen würde)
&lt;/p&gt;

&lt;p&gt;
Bad code example from the lecture slides follows, BRACE YOURSELF:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* shortcut .c -- partial evaluation */&lt;/span&gt;
&lt;span class="cp"&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraysize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d. value : %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Some imho more practical pseudo examples could look like this:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;firedMissles&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CanFireMissiles&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;FireMissiles&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="cm"&gt;/* or */&lt;/span&gt;

&lt;span class="n"&gt;isFileReady&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;getFileReady&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
C also provides a &lt;i&gt;conditional operator&lt;/i&gt;. If any operator is used on three operands or variable is also known as &lt;i&gt;Ternary Operator&lt;/i&gt;. It can be represented with &lt;code&gt;"? : "&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The ternary operator is used to execute code based on the result of a binary condition.
&lt;/p&gt;

&lt;p&gt;
It takes in a binary condition as input, which makes it similar to an 'if-else' control flow block. It also, however, returns a value, behaving similar to a function (functional model).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;binaryCondition&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;valueReturnedIfTrue&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;valueReturnedIfFalse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The ternary cannot be used to execute code. It must be either returned in a function, or set equal to a variable with the same data type as the returned values:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findMaximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;//if a &amp;gt; b, it returns a, if not it returns b&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;a&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Some interesting notes and observations about the ternary operator can be found &lt;a href="https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/"&gt;here&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The next lecture topic was the switch-case. I already covered that in &lt;a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/#org48e22fb"&gt;this CS01 post&lt;/a&gt; and the rules from C++ apply to C aswell (other way round technically :D). Remember that "switch case" works with constant values as its cases and is used to "jump" to a specific statement from where execution will be continued until you &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;! so following cases would be executed as well (avoid this and rather group cases together. It is also important to know that cases inside a switch are like "goto" labels and share scope, thats why often times people wrap the cases code inside "{}" to create case specific code and dont "skip" initialization of variables).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/</guid><pubDate>Sun, 11 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 10</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org3412ab9" class="outline-2"&gt;
&lt;h2 id="org3412ab9"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3412ab9"&gt;
&lt;p&gt;
How does the compiler know whether a program is "correct" (in the sense of compilable) or not?
We basically distinguish between &lt;b&gt;grammar&lt;/b&gt; and &lt;b&gt;semantics&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Grammar&lt;/b&gt; (like we know it from school) consists of  &lt;i&gt;morphology&lt;/i&gt; (Formenlehre v Wörtern) and syntax (Sätze). In the realm of programming morphology practically doesn't matter therefore &lt;i&gt;grammar&lt;/i&gt; and &lt;i&gt;syntax&lt;/i&gt; are mostly used interchangeably.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;semantics&lt;/b&gt; (&lt;i&gt;meaning of a sentence&lt;/i&gt;) do not matter to the compiler.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc7b3af8" class="outline-2"&gt;
&lt;h2 id="orgc7b3af8"&gt;Syntax&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc7b3af8"&gt;
&lt;p&gt;
The &lt;b&gt;syntax&lt;/b&gt; of a language is a &lt;i&gt;set of rules&lt;/i&gt; after which &lt;i&gt;expressions&lt;/i&gt; are built. This is true for natural languages like English and for formal languages likes C or Python, as well as mathematical logic or description languages etc.
&lt;/p&gt;

&lt;p&gt;
Expressions in the above definition might be phrases, formulas are program/code statements.
&lt;/p&gt;

&lt;p&gt;
Often times the better you understand the semantics the harder it gets to recognize the syntax (for example in my motherlanguage I don't think about the SPO-rule for subject-predicate-object at all).
&lt;/p&gt;

&lt;p&gt;
Every formal language consists of &lt;b&gt;symbols/tokens&lt;/b&gt;. A symbol is the &lt;b&gt;smallest&lt;/b&gt; observable unit in a language (kleinste Einheit der Betrachtung innerhalb der Sprache). Symbols can be single tokens, combinations of such or whole words.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Every finite, non-empty set \(\sum\) of symbols is called &lt;b&gt;alphabet&lt;/b&gt;.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
With the elements in \(\sum\) we can build &lt;b&gt;expression&lt;/b&gt;. The "empty expression" is represented as \(\epsilon\)  (epsilon).
&lt;/p&gt;

&lt;p&gt;
The set \(\sum = {0,1,2,3,4,5,6,7,8,9}\) for example is sufficient to build all natural numbers in the decimal system.
&lt;/p&gt;

&lt;p&gt;
/The set of all strings(combinations) (Zeichenketten) the symbols from \(\sum\) can build is called &lt;b&gt;Kleene star&lt;/b&gt; \(\sum *\) of \(\sum\) (Kleenesche Hülle).
&lt;/p&gt;

&lt;p&gt;
For example:
\[ \sum = \{a,b\} \Rightarrow \sum * = \{\epsilon, a, b, aa, bb, ab, ba, aaa, aab, aba,baa, ...\} \]
&lt;/p&gt;

&lt;p&gt;
The set of all strings without the empty string is represented as \(sum +\) Kleene Plus.
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Each subset \(L \subseteq \sum*\) is also a &lt;b&gt;formal language&lt;/b&gt;&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
In the following context we focus on formal languages and "languages" then refers to such.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5262b4a" class="outline-2"&gt;
&lt;h2 id="org5262b4a"&gt;Formal languages and generative/formal grammar&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5262b4a"&gt;
&lt;p&gt;
How can the syntax of a language be described? Which expressions/strings in a language are valid and which aren't? An enumeration of valid expressions is usually unpractical because the quantity of expressions is often times enormously big or infinite. 
&lt;/p&gt;

&lt;p&gt;
A solution to this is to &lt;i&gt;describe&lt;/i&gt; how valid expressions can/may be &lt;b&gt;generated&lt;/b&gt;. These "rules" are called &lt;b&gt;generative/formal grammar&lt;/b&gt;. From wikipedia: "In formal language theory, a grammar (when the context is not given, often called a formal grammar for clarity) is a set of production rules for strings in a formal language. The rules describe how to form strings from the language's alphabet that are valid according to the language's syntax. A grammar does not describe the meaning of the strings or what can be done with them in whatever context—only their form."
&lt;/p&gt;

&lt;p&gt;
For generative grammar of a language \(L\) a second alphabet \(V\) of variables is used in addition to the alphabet \(\sum\).
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;elements of \(\sum\) are called &lt;b&gt;terminal symbols&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;elementary symbols of a language&lt;/li&gt;
&lt;li&gt;cannot be replaced/reproduced via production rules&lt;/li&gt;
&lt;li&gt;eg: "for", "if"&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;elements of \(V\) are called &lt;b&gt;nonterminal symbols&lt;/b&gt; (in some literature it is N instead of V)
&lt;ul class="org-ul"&gt;
&lt;li&gt;are reproducable/replacable via production rules&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
When speaking about those elements in an abstract way usually lower case letters (a,b,c..) are used for elements of \(\sum\) and uppercase letters for elements of \(V\).
&lt;/p&gt;

&lt;p&gt;
A grammar is defined by production rules (or just 'productions') that specify which symbols may replace which other symbols; these rules may be used to generate strings, or to parse them. Each such rule has a head, or left-hand side, which consists of the string that may be replaced, and a body, or right-hand side, which consists of a string that may replace it. Rules are often written in the form head → body; e.g., the rule a → b specifies that a can be replaced by b.
&lt;/p&gt;

&lt;p&gt;
To generate an expression we begin with a &lt;b&gt;start symbol&lt;/b&gt; \(S \in V\).
&lt;/p&gt;

&lt;p&gt;
Then depending on the nature of the rules \(P\) we distinguish between different kind of grammars (a regular grammar is a left or a right regular grammar):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a left regular grammar  is a formal grammar (V, Σ, P, S), such that all rules in P obey the forms:
&lt;ul class="org-ul"&gt;
&lt;li&gt;A → a - where A is a non-terminal in V and a is a terminal in Σ&lt;/li&gt;
&lt;li&gt;A → Ba - where A and B are in V and a is in Σ&lt;/li&gt;
&lt;li&gt;A → ε - where A is in N and ε is the empty string.&lt;/li&gt;
&lt;li&gt;so only &lt;b&gt;one nonterminal symbol&lt;/b&gt; on the &lt;i&gt;left side&lt;/i&gt; and on the &lt;i&gt;right side&lt;/i&gt; &lt;b&gt;one terminal symbol&lt;/b&gt; that &lt;i&gt;may be&lt;/i&gt; &lt;b&gt;preceeded&lt;/b&gt; by &lt;i&gt;one nonterminal symbol max&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;a &lt;b&gt;right regular grammar&lt;/b&gt; is a formal grammar (V, Σ, P, S) such that all the production rules in P are of one of the following forms:
&lt;ul class="org-ul"&gt;
&lt;li&gt;B → a - where B is a non-terminal in V and a is a terminal in Σ&lt;/li&gt;
&lt;li&gt;B → aC - where B and C are non-terminals in V and a is in Σ&lt;/li&gt;
&lt;li&gt;B → ε - where B is in V and ε denotes the empty string, i.e. the string of length 0.&lt;/li&gt;
&lt;li&gt;so only &lt;b&gt;one nonterminal symbol&lt;/b&gt; on the &lt;i&gt;left side&lt;/i&gt; and on the &lt;i&gt;right side&lt;/i&gt; &lt;b&gt;one terminal symbol&lt;/b&gt; that &lt;i&gt;may be&lt;/i&gt; &lt;b&gt;followed&lt;/b&gt; by &lt;i&gt;one nonterminal symbol max&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Types of grammars:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;regular grammar&lt;/b&gt; (reguläre Grammatik) → either &lt;i&gt;all&lt;/i&gt; rules of P are of left regular grammar nature &lt;i&gt;or&lt;/i&gt; right regular grammar nature (not both/mixed)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;context-free grammar&lt;/b&gt; (kontextfreie Grammatik) → a context-free grammar is a grammar in which the left-hand side of each production rule consists of &lt;i&gt;only a single nonterminal symbol&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;context-sensitive grammar&lt;/b&gt; (kontextbehaftet/sensitive Grammatik) → a context-sensitive grammar is a formal grammar in which the left-hand sides and right-hand sides of any production rules may be surrounded by a context of &lt;b&gt;the same&lt;/b&gt; terminal and nonterminal symbols &lt;code&gt;αAβ → αγβ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;unrestricted grammar&lt;/b&gt; (allgemeine Grammatik)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
After the american linguist Noam Chomsky those grammars build the so called &lt;b&gt;Chomsky-Hierarchy&lt;/b&gt; in which they're also called as:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;Type-0 grammars&lt;/b&gt; → &lt;i&gt;unrestricted grammars&lt;/i&gt; (allgemeine Grammatiken)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-1 grammars&lt;/b&gt; → &lt;i&gt;context-sensitive grammars&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-2 grammars&lt;/b&gt; → &lt;i&gt;context-free grammars&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Type-3 grammars&lt;/b&gt; → &lt;i&gt;regular grammars&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Each n-1 grammar can "do everything and more" that a grammar of type n can do (a type 1 grammar can do everything a type 2 grammar can and so on; Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69566a8" class="outline-2"&gt;
&lt;h2 id="org69566a8"&gt;Syntax Diagrams&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org69566a8"&gt;
&lt;p&gt;
How may we describe the rules of grammars? For the following we limit us to (maximal) contrext free grammars. To describe grammar rules there exist two main approaches:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;syntax diagrams&lt;/li&gt;
&lt;li&gt;(extended) Backus-Naur form&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:red;"&gt;
I was told that these were asked in last years exam
&lt;/p&gt;

&lt;p&gt;
Syntax diagrams consist of of:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;boxes with round corners → terminal symbols (lowercase, see above)&lt;/li&gt;
&lt;li&gt;boxes with straight corners → nonterminal symbols (uppercase, see above)&lt;/li&gt;
&lt;li&gt;connections via lines and arrows&lt;/li&gt;
&lt;li&gt;each walkable way (in arrow direction) is valid a expression (Jeder (in Pfeilrichtung) begehbare Weg ist ein valider Ausdruck)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Components:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-intro.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
An example of a (simplified) function declaration in C in a syntax diagram:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-func-decl.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Example of a syntax diagram for a while loop in python:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/syntax-diagram-python.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org94ed424" class="outline-2"&gt;
&lt;h2 id="org94ed424"&gt;Backus-Naur Form&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org94ed424"&gt;
&lt;p&gt;
While syntax diagrams are easy to read, they're quite cumbersome and take a lot of space. A more compact alternative is the Backus-Naur form (BNF).
&lt;/p&gt;

&lt;p&gt;
BNF uses meta symbols:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;::=&lt;/code&gt; definition symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; alternative symbol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; nonterminal brackets which convert any sequence of letters, digits and spaces into a nonterminal symbol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
All symbols which are neither meta symbols nor nonterminalsymbols are terminal symbols.
&lt;/p&gt;

&lt;p&gt;
BNF is directly translatable into context-free grammar, but needs (for example for loops) syntactic helper variables.
&lt;/p&gt;

&lt;p&gt;
That's why there's also the Extended Backus-Naur form (EBNF) which is like BNF plus:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[ ... ]&lt;/code&gt; → description of &lt;b&gt;optional parts&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ ... }&lt;/code&gt; → description of &lt;b&gt;repetitions&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are also some syntactic differences:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;arbitrary paren placement (Klammerung)&lt;/li&gt;
&lt;li&gt;definition symbol is &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;terminal symbols are wrapped in &lt;code&gt;""&lt;/code&gt; or &lt;code&gt;''&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;nonterminal symbols arent specially marked
&lt;ul class="org-ul"&gt;
&lt;li&gt;there also might be whitespaces in nonterminal symbol identifiers, the sequence is then separated via commas eg &lt;code&gt;signed integer = sign, integer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;expressions end with semicolons &lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;specific repetitions via &lt;code&gt;4 * (...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;comments via &lt;code&gt;(* This is a comment*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A (E)BNF defintion or a syntax diagram is &lt;b&gt;complete&lt;/b&gt; (vollständig) if a rule exist on the left side for every nonterminal symbol on the right hand rule side.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7d07cca" class="outline-2"&gt;
&lt;h2 id="org7d07cca"&gt;Regular Grammar in Action&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7d07cca"&gt;
&lt;p&gt;
Now we'll introduce &lt;b&gt;regular expressions&lt;/b&gt; which are a compact notation for regular grammars.
&lt;/p&gt;

&lt;p&gt;
String searching or pattern matching in (certain) files is such a common task that "tools" using regular expression exist to help with it (for example grep, sed, awk, perl, Python, C#.. provide ways to pattern match with regular expressions).
&lt;/p&gt;

&lt;p&gt;
Since the 1980s, different syntaxes for writing regular expressions exist, one being the POSIX standard and another, widely used, being the Perl syntax.
&lt;/p&gt;

&lt;p&gt;
Because there is only a limited amount of symbols/characters/tokens (Zeichen) available regular expressions differentiate between regular("normal") (terminal)symbols and meta characters, with a special meaning. Common but not all meta characters are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; matches the starting position within the string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; dot wildcard matches any single character (newlines sometimes excluded tho)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ ]&lt;/code&gt; a bracket expression matches a single character that is contained within the brackets eg &lt;code&gt;[abc]&lt;/code&gt; matches "a", "b", or "c"
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[^ ]&lt;/code&gt; matches a single character that is &lt;i&gt;not&lt;/i&gt; contained within the brackets&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
= &lt;code&gt;$&lt;/code&gt; matches the ending position of the string or the position just before a string-ending newline (in line-based tools, it matches the ending position of any line)
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; matches the preceding element &lt;i&gt;zero or more&lt;/i&gt; times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; matches the preceding element &lt;i&gt;one or more&lt;/i&gt; times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; matches the preceding element at least &lt;code&gt;n&lt;/code&gt; and not more than &lt;code&gt;m&lt;/code&gt; times (eg &lt;code&gt;a{1,3}&lt;/code&gt; matches only &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;aa&lt;/code&gt; and &lt;code&gt;aaa&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt; escapes the previous meta character&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There are also character classes which are the most basic regex concept after a literal match. It makes one small sequence of characters match a larget set of characters (eg in ASCII [a-z] for lowercase letters). Some examples of POSIX character classes:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;[:alpha:]&lt;/code&gt; for alphabetic characters (A-Z, a-z)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:digit:]&lt;/code&gt; for digits (0-9)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alnum:]&lt;/code&gt; for alphanumeric characters (A-Z,a-z,0-9)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:blank:]&lt;/code&gt; for space and tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:print:]&lt;/code&gt; visible characters and the space character (printable characters)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example usage of grep which finds all defintions of &lt;code&gt;time_t&lt;/code&gt; in header files (option -E stands for extended-regexp):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep −E &lt;span class="s2"&gt;"typedef ([_[:alpha:]][_[:alnum:]]*[[:blank:]]+)+time_t;"&lt;/span&gt; *.h &lt;span class="c1"&gt;# (copied from slides doesnt work for me :D)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc58be84" class="outline-2"&gt;
&lt;h2 id="orgc58be84"&gt;Compiler&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc58be84"&gt;
&lt;p&gt;
A modern compiler uses multiple formal grammars for different purposes:
&lt;/p&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgb26bd0f"&gt;&lt;/a&gt;Lexical Analysis&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgb26bd0f"&gt;
&lt;p&gt;
Lexical Analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning). 
&lt;/p&gt;

&lt;p&gt;
Lexical analysis is the first phase of a compiler. It takes the modified source code from language preprocessors that are written in the form of sentences. The lexical analyzer breaks these syntaxes into a series of tokens, by removing any whitespace (in C, not in python because they belong to the syntax) or comments in the source code.
&lt;/p&gt;

&lt;p&gt;
If the lexical analyzer finds a token invalid, it generates an error. The lexical analyzer works closely with the syntax analyzer. It reads character streams from the source code, checks for legal tokens, and passes the data to the syntax analyzer when it demands.
&lt;/p&gt;

&lt;p&gt;
This is often done via a lexical specification that is defined using regular expressions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org837dc09"&gt;&lt;/a&gt;Syntax Analysis&lt;br&gt;
&lt;div class="outline-text-5" id="text-org837dc09"&gt;
&lt;p&gt;
Syntax analysis or parsing is the second phase of a compiler. We have seen that a lexical analyzer can identify tokens with the help of regular expressions and pattern rules. But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses &lt;i&gt;context-free grammar&lt;/i&gt; (CFG), which is recognized by push-down automata.
&lt;/p&gt;

&lt;p&gt;
CFG, on the other hand, is a superset of Regular Grammar. This implies that every Regular Grammar is also context-free, but there exists some problems, which are beyond the scope of Regular Grammar. CFG is a helpful tool in describing the syntax of programming languages (take a look at &lt;a href="https://www.tutorialspoint.com/compiler_design/compiler_design_syntax_analysis.htm"&gt;this&lt;/a&gt; resource which is pretty good and also has some more explanations for terminal symbols etc). 
&lt;/p&gt;

&lt;p&gt;
A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a parse tree.
&lt;/p&gt;

&lt;p&gt;
This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.
&lt;/p&gt;

&lt;p&gt;
Parsers are expected to parse the whole code even if some errors exist in the program. 
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Limitations of syntax analyzers&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
Syntax analyzers receive their inputs, in the form of tokens, from lexical analyzers. Lexical analyzers are responsible for the validity of a token supplied by the syntax analyzer. Syntax analyzers have the following drawbacks:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;it cannot determine if a token is valid&lt;/li&gt;
&lt;li&gt;it cannot determine if a token is declared before it is being used&lt;/li&gt;
&lt;li&gt;it cannot determine if a token is initialized before it is being used&lt;/li&gt;
&lt;li&gt;it cannot determine if an operation performed on a token type is valid or not&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
These tasks are accomplished by the &lt;i&gt;semantic analyzer&lt;/i&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org8e4d771"&gt;&lt;/a&gt;Semantic Analyzer&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8e4d771"&gt;
&lt;p&gt;
A parser constructs parse trees as seen in the section about the parser / syntax analyzer above.
&lt;/p&gt;

&lt;p&gt;
The plain parse-tree constructed in that phase is generally of no use for a compiler, as it does not carry any information of how to evaluate the tree. The productions of context-free grammar, which makes the rules of the language, do not accommodate how to interpret them.
&lt;/p&gt;

&lt;p&gt;
Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.
&lt;/p&gt;

&lt;p&gt;
For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"value"&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The code above should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Scope resolution&lt;/li&gt;
&lt;li&gt;Type checking&lt;/li&gt;
&lt;li&gt;Array-bound checking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
From the lecture slides: "usually context-sensitive language is used to perform semantic analysis"
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div id="outline-container-org7d80d47" class="outline-2"&gt;
&lt;h2 id="org7d80d47"&gt;Excourse: General Difference between Expressions and Statements&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7d80d47"&gt;
&lt;p&gt;
A statement is like an instruction that the runtime performs. Programs consist of statements. Without statements, there is nothing to do. 
&lt;/p&gt;

&lt;p&gt;
An expression is a piece of code that can be 'evaluated', meaning it can be reduced to a value. 
&lt;/p&gt;

&lt;p&gt;
The two concepts are not related, or even similar. They may coincide with the same piece of code, but they do very different things. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;x = 1&lt;/code&gt; is not a statement. &lt;code&gt;'x = 1'&lt;/code&gt; is an &lt;i&gt;expression&lt;/i&gt; that evaluates to 1, with the side effect of assigning the value 1 to x. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;x = 1;&lt;/code&gt; is a &lt;i&gt;statement&lt;/i&gt; (note the semi-colon at the end) that performs this assignment. 
&lt;/p&gt;

&lt;p&gt;
In many languages (Java, C, JavaScript), it's easy to distinguish statements. Statements usually end with a semi-colon. Statements can't be evaluated, they just do something. 
&lt;/p&gt;

&lt;p&gt;
Expressions are harder to distinguish: The following statement consists of 9 expressions: &lt;code&gt;f[x] = 2*x+1;&lt;/code&gt;
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x]&lt;/code&gt; binary postfix operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; literal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2*x&lt;/code&gt; binary operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; literal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2*x+1&lt;/code&gt; binary operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x] = 2*x+1&lt;/code&gt; assignment operation&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
In some languages there is no distinction between expressions and staments. In Lisp for example all code and data are written as expressions. When an expression is evaluated, it produces a value.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
Sources: &lt;a href="https://www.tutorialspoint.com"&gt;https://www.tutorialspoint.com&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/</guid><pubDate>Thu, 08 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 09</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org80666c1" class="outline-2"&gt;
&lt;h2 id="org80666c1"&gt;Complex Types in Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org80666c1"&gt;
&lt;p&gt;
There are built-in types in Python which offer similar functionality to the complex types in C and more.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9f298c6" class="outline-3"&gt;
&lt;h3 id="org9f298c6"&gt;Python Strings&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9f298c6"&gt;
&lt;p&gt;
Strings are character sequences of a fixed length and are to be precise &lt;b&gt;not&lt;/b&gt; a complex type (why?).
String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).
&lt;/p&gt;

&lt;p&gt;
Python strings are "immutable" which means they cannot be changed after they are created. Since strings can't be changed, we construct &lt;b&gt;new&lt;/b&gt; strings as we go to represent computed values. So for example the expression &lt;code&gt;'hello' + 'there'&lt;/code&gt; takes in the 2 strings &lt;code&gt;'hello'&lt;/code&gt; and &lt;code&gt;'there'&lt;/code&gt; and builds a new string &lt;code&gt;'hellothere'&lt;/code&gt;. The resulting string has a different &lt;code&gt;id()&lt;/code&gt; because a new object is created and the others may then be garbage collected.
&lt;/p&gt;

&lt;p&gt;
Python string also recognize escape sequences similarly to C for example &lt;code&gt;'\n'&lt;/code&gt;  is recognized as a ASCII Linefeed. To prevent parsing of those one may use a &lt;i&gt;raw string&lt;/i&gt; by prepending and &lt;code&gt;r&lt;/code&gt; or &lt;code&gt;R&lt;/code&gt; to the string:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"H&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;i"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;"H\ni"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Hello"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;" World"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
H
i
H\ni
Id of Hello 139710321381872
Id of Hello World 139710321440048

&lt;/pre&gt;

&lt;p&gt;
Individual characters of a string can be accessed via &lt;code&gt;[]&lt;/code&gt; bracket notation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2c8ba19" class="outline-3"&gt;
&lt;h3 id="org2c8ba19"&gt;Python Lists&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2c8ba19"&gt;
&lt;p&gt;
Python has a great built-in list type named "list". List literals are written within square brackets &lt;code&gt;[ ]&lt;/code&gt;. Lists work similarly to strings - use the &lt;code&gt;len()&lt;/code&gt; function and square brackets [ ] to access data, with the first element at index &lt;code&gt;0&lt;/code&gt;. To access elements from the back use negative indices.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'red'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'green'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'red'&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Assignment with an &lt;code&gt;=&lt;/code&gt; on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.
&lt;/p&gt;

&lt;p&gt;
The "empty list" is just an empty pair of brackets &lt;code&gt;[ ]&lt;/code&gt;. The &lt;code&gt;+&lt;/code&gt; works to append two lists, so &lt;code&gt;[1, 2] + [3, 4]&lt;/code&gt; yields &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; (this is just like &lt;code&gt;+&lt;/code&gt; with strings).
&lt;/p&gt;

&lt;p&gt;
Lists in Python can (in contrast to arrays in C) hold values of different types.
&lt;/p&gt;

&lt;p&gt;
Python lists are also &lt;i&gt;mutable&lt;/i&gt;. In fact there are a lot of &lt;i&gt;methods&lt;/i&gt; to modify lists eg &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5896b74" class="outline-3"&gt;
&lt;h3 id="org5896b74"&gt;Python Tuples&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5896b74"&gt;
&lt;p&gt;
Tuples in Python are similar to lists with the difference that they are &lt;b&gt;immutable&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.
&lt;/p&gt;

&lt;p&gt;
Creating a tuple is as simple as putting different comma-separated values. Optionally you can put these comma-separated values between parentheses also. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tup1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'physics'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'chemistry'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1997&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"b"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"c"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The empty tuple is written as two parens containing nothing &lt;code&gt;tup1 = ()&lt;/code&gt;. To write a tuple containing a single value you have to include a comma, even though there is only one value &lt;code&gt;(77,)&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Like string indices, tuple indices start at 0, and they can be sliced, concatenated, and so on.
&lt;/p&gt;

&lt;p&gt;
However if tuples are eg concatenated via &lt;code&gt;+&lt;/code&gt; a new tuple is created:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
tuple:  (1, 2) with id:  140056518200328
tuple:  (1, 2, 3, 4) with id:  140056518172568

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org80a4df1" class="outline-3"&gt;
&lt;h3 id="org80a4df1"&gt;Python Sets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org80a4df1"&gt;
&lt;p&gt;
Since Python 2.6 there are set types (Mengentypen). 
A Set in Python is a data structure equivalent to sets in mathematics. It may consist of various elements; the order of elements in a set is undefined. You can add and delete elements of a set, you can iterate the elements of the set, you can perform standard operations on sets (union, intersection, difference). Besides that, you can check if an element belongs to a set.
&lt;/p&gt;

&lt;p&gt;
Unlike arrays, where the elements are stored as ordered list, the order of elements in a set is undefined (moreover, the set elements are usually not stored in order of appearance in the set; this allows checking if an element belongs to a set faster than just going through all the elements of the set).
&lt;/p&gt;

&lt;p&gt;
Any immutable data type can be an element of a set: a number, a string, a tuple. Mutable (changeable) data types cannot be elements of the set. In particular, lists cannot be an element of a set (but tuple can), and another set cannot be an element of a set. The requirement of immutability follows from the way how do computers represent sets in memory.
&lt;/p&gt;

&lt;p&gt;
Sets unlike lists or tuples can't have multiple occurrences of the same element → &lt;code&gt;set('a','b','c','a','b','c')&lt;/code&gt; → &lt;code&gt;{'a','b','c'}&lt;/code&gt; no values are duplicated.
&lt;/p&gt;

&lt;p&gt;
To create a set the &lt;code&gt;set()&lt;/code&gt; is called which constructs a Python set from the given iterable and returns it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# empty set&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="c1"&gt;# from string&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Python'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# from tuple&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;# from list&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="c1"&gt;# from range&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
set()
{'t', 'y', 'h', 'o', 'n', 'P'}
{'e', 'u', 'o', 'a', 'i'}
{'e', 'u', 'o', 'a', 'i'}
{0, 1, 2, 3, 4}

&lt;/pre&gt;

&lt;p&gt;
Sets are implemented in a way, which doesn't allow mutable objects. The following example demonstrates that we cannot include, for example, lists as elements:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="c1"&gt;# valid set of tuples&lt;/span&gt;

&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="c1"&gt;# -&amp;gt; TypeError: unhashable type: 'list'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Although sets can't contain mutable objects, sets are mutable themselves. Elements may for example added via the &lt;code&gt;add&lt;/code&gt; method (&lt;code&gt;cities.add("Tokyo")&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Frozensets are like sets except that they cannot be changed so they are immutable:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;frozenset&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;"Frankfurt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Basel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Freiburg"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Strasbourg"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# AttributeError: 'frozenset' object  has no attribute 'add'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There's also a simplified shorter notation to construct sets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Madrid"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;class 'set'&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
The known operations from set theory are also available via Python Sets (following part in German xD):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;len(s)&lt;/code&gt; gibt Mächtigkeit der Menge &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 | s2&lt;/code&gt; gibt Vereinigungsmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 &amp;amp; s2&lt;/code&gt; gibt Schnittmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 - s2&lt;/code&gt; gibt Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 ^ s2&lt;/code&gt; gibt symmetrische Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org89f6671" class="outline-3"&gt;
&lt;h3 id="org89f6671"&gt;Python Dictionaries&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org89f6671"&gt;
&lt;p&gt;
A dictionary is a collection which is unordered, changeable (mutable) and indexed. In Python dictionaries are written with curly brackets, and they have keys and values.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can access the items of a dictionary by referring to its key name, inside square brackets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
value
Mustang
1964

&lt;/pre&gt;

&lt;p&gt;
More on dictionaries and how to work with them / their methods &lt;a href="https://www.w3schools.com/python/python_dictionaries.asp"&gt;here&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb2c2bcc" class="outline-2"&gt;
&lt;h2 id="orgb2c2bcc"&gt;Loops and Iterations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb2c2bcc"&gt;
&lt;p&gt;
In C there are three types of loops:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;while loop&lt;/li&gt;
&lt;li&gt;do while loop&lt;/li&gt;
&lt;li&gt;for loop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
All of these loops use conditions are able to simulate one another. Which one to use is often a matter of personal taste.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org184bfcc" class="outline-3"&gt;
&lt;h3 id="org184bfcc"&gt;While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org184bfcc"&gt;
&lt;p&gt;
The while loop executes as long as a conditions is true resp. until a condition is false. This is the procedure:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Check if condition &lt;code&gt;while (expression/Condition)&lt;/code&gt; evaluates to true (nonzero)&lt;/li&gt;
&lt;li&gt;If yes: execute body of the loop and jump to 1.&lt;/li&gt;
&lt;li&gt;If no: resume program execution after the loop&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Program to find factorial of a number&lt;/span&gt;
&lt;span class="c1"&gt;// For a positive integer n, factorial = 1*2*3...n&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// printf("Enter an integer: ");&lt;/span&gt;
    &lt;span class="c1"&gt;// scanf("%d",&amp;amp;number); // cannot read from stdio in my blog :)&lt;/span&gt;
    &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// loop terminates when number is less than or equal to 0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// factorial = factorial*number;&lt;/span&gt;
	&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

	&lt;span class="c1"&gt;// alternatively: factorial *= number--;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Factorial= %lld"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Factorial= 120

&lt;/pre&gt;

&lt;p&gt;
Loops can be used to fill fields of an array:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// constant for array size&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Element %d of arr: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Element 0 of arr: 0
Element 1 of arr: 1
Element 2 of arr: 4
Element 3 of arr: 9
Element 4 of arr: 16
Element 5 of arr: 25
Element 6 of arr: 36
Element 7 of arr: 49
Element 8 of arr: 64
Element 9 of arr: 81
Element 10 of arr: 100
Element 11 of arr: 121
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5a72cc7" class="outline-3"&gt;
&lt;h3 id="org5a72cc7"&gt;Do While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5a72cc7"&gt;
&lt;p&gt;
The do while loop is similar to the while loop with the difference being that the do while loop checks the condition &lt;b&gt;after&lt;/b&gt; it has run, therefore it always runs at least one time.
The syntax is
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// notice the semicolon!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org312c1c8" class="outline-3"&gt;
&lt;h3 id="org312c1c8"&gt;For Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org312c1c8"&gt;
&lt;p&gt;
A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;mutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eg&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;decrement&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// "conditon" and "mutation" are expressions (see C standard) but that is how they're used commonly&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Here is the flow of control in a 'for' loop :
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the init step is executed first, and only once
&lt;ul class="org-ul"&gt;
&lt;li&gt;this step allows you to declare and initialize any loop control variables&lt;/li&gt;
&lt;li&gt;you are not required to put a statement here, as long as a semicolon appears&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;next, the condition is evaluated
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the body of the loop is executed&lt;/li&gt;
&lt;li&gt;if it is false, the body of the loop does not execute and the flow of control jumps to the next statement just after the 'for' loop&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;after the body of the 'for' loop executes, the flow of control jumps back up to the mutation statement
&lt;ul class="org-ul"&gt;
&lt;li&gt;this statement allows you to update any loop control variables&lt;/li&gt;
&lt;li&gt;This statement can be left blank, as long as a semicolon appears after the condition&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the condition is now evaluated again 
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the loop executes and the process repeats itself (body of loop, then mutation step, and then again condition)&lt;/li&gt;
&lt;li&gt;after the condition becomes false, the 'for' loop terminates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Omitting expressions:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// omitting initalization&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d. argument: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;


  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;;)&lt;/span&gt; &lt;span class="c1"&gt;// endless loop&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The answer is 42&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 


  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// never reached&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Dont forget it is possible to have more complex conditions and multiple assignments!
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d, %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2, 1
3, 2
4, 3
5, 4

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7aba6ab" class="outline-3"&gt;
&lt;h3 id="org7aba6ab"&gt;&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7aba6ab"&gt;
&lt;p&gt;
Loops run as long as the loop condition evaluates to true. There are however two ways to modify the control flow from &lt;i&gt;inside the function body&lt;/i&gt;:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; stops execution of the loop regardless of the loop condition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; immediately starts the next evaluation of first the loop condition and possibly the next loop iteration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; should be used sparsely - an excessive use might be an indicator for insufficient program logic.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* reciprocal .c -- calculate reciprocal value of array elements */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* a negative value indicates end of list */&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.5&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;3.1415&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.33333&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.7182&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;42.23&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// notice the condition!&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d value : %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0 value : 1.000000
1 value : 2.000000
2 value : 0.318319
3 value : 3.000030
4 value : 0.000000
5 value : 0.367891
6 value : 0.023680

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8e0127e" class="outline-2"&gt;
&lt;h2 id="org8e0127e"&gt;Loops in Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e0127e"&gt;
&lt;p&gt;
There are two types of loops in Python &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;.
The &lt;code&gt;while&lt;/code&gt; loops are similar to their pendants in C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"i ="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
i = 5
i = 4
i = 3
i = 2
i = 1

&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are also available in Python with the same semantic as in C.
&lt;/p&gt;

&lt;p&gt;
In addition to what we know from C in Python there can be an optional &lt;code&gt;else&lt;/code&gt; branch after a loop which is executed &lt;b&gt;after the loop finished&lt;/b&gt; if it was &lt;b&gt;not canceled&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"1. Loop finished execution"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"------------"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"2. Loop finished execution"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# not executed because loop doesnt finish naturally but is canceled&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0
1
2
1. Loop finished execution
------------
0
1
2

&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;else&lt;/code&gt; can also be used with the for loop in Python!
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;for&lt;/code&gt; loop in Python iterates over a given &lt;i&gt;sequence&lt;/i&gt; or &lt;i&gt;set&lt;/i&gt; (an iterable type!):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ITERABLE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
In the example above the elements of &lt;code&gt;ITERABLE&lt;/code&gt; are assigned to &lt;code&gt;i&lt;/code&gt; one by one per iteration.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'John'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'Paul'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'George'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'Pete'&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
 &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
John
Paul
George
Pete

&lt;/pre&gt;

&lt;p&gt;
This also works for mixed types:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Alpha'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
AlphaAlpha
96
0.4
(1, 2, 3, 1, 2, 3)

&lt;/pre&gt;

&lt;p&gt;
To "mimic" the C for loop we can iterate over a &lt;i&gt;sequence&lt;/i&gt; of numbers using the &lt;code&gt;range&lt;/code&gt; function:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# range([start,] stop [, step]) # generate from 'start' up to and NOT INCLUDING 'stop' and increment by 'step'&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"------------"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0
2
4
------------
0
1
2

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90be5d3" class="outline-2"&gt;
&lt;h2 id="org90be5d3"&gt;Iterators and Loop Functions in C&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org90be5d3"&gt;
&lt;p&gt;
Code sample of an iterator with C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"John"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Paul"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"George"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Ringo"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// so the iterator can be used multiple times -&amp;gt; first ALWAYS returns first element&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// set index to 0 when arrived at last element delmiited via NULL&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%s "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
John Paul George Ringo

&lt;/pre&gt;

&lt;p&gt;
Iterators like those above are more common in C++ where they are more elegant (also in C there are prettier ways to do this).
&lt;/p&gt;

&lt;p&gt;
Until now we used loops with assignments (state model). It is also possible to have loops in the functional model where they are realized via recursion:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Ctuhlu!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// i-- would NOT work because i is evaluated -&amp;gt; 3 and passed to the function and THEN decremented -&amp;gt; endless loop&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;say_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Ctuhlu!
Ctuhlu!
Ctuhlu!

&lt;/pre&gt;

&lt;p&gt;
It is also possible to separate the loop body from the "loop mechanic" → &lt;i&gt;generic loop function&lt;/i&gt;. To do so we use a &lt;i&gt;pointer to functions&lt;/i&gt;.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;functionPointer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// functions are passed by pointer (efficiency) need to be wrapped in () else it would be interpreted as "void*" return type (pointer to void) instead&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;functionPointer&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loopBody&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d^2 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loopBody&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
0^2 = 0
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25

&lt;/pre&gt;

&lt;p&gt;
In Python such things are achievable more easily via &lt;a href="https://www.programiz.com/python-programming/anonymous-function"&gt;lambda functions&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org54d7fb9" class="outline-2"&gt;
&lt;h2 id="org54d7fb9"&gt;Equivalence&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org54d7fb9"&gt;
&lt;p&gt;
Generally every loop in a program can be translated into a recursive function and each (trivially) recursive function can be computed via loops. To be precise: &lt;i&gt;primitive-recursive functions&lt;/i&gt; can be computed with &lt;i&gt;a priori limited&lt;/i&gt; loops, for the so called &lt;i&gt;μ-recursive functions&lt;/i&gt; (&lt;i&gt;my&lt;/i&gt; "müh" xD as i like to call it). The ACKERMANN-Function for example is not trivially recursive.
&lt;/p&gt;

&lt;p&gt;
So for the most practical use cases loops and recursion are equipotent (gleichmächtig). However loops are usually more clearer (übersichtlicher), but there are also cases where recursion are the handier solution.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</guid><pubDate>Sun, 04 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 08</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-08/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgf22ea76" class="outline-2"&gt;
&lt;h2 id="orgf22ea76"&gt;Complex Types&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf22ea76"&gt;
&lt;p&gt;
In C there are so called &lt;b&gt;derived types&lt;/b&gt;. We already know one kind of a derived type, that is &lt;i&gt;pointers&lt;/i&gt;. There are more types though:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;composite data types (Verbunddatentypen, &lt;b&gt;struct&lt;/b&gt; and &lt;b&gt;union&lt;/b&gt;)&lt;/li&gt;
&lt;li&gt;enumerated data types (Aufzählungstypen, &lt;b&gt;enum&lt;/b&gt;)&lt;/li&gt;
&lt;li&gt;array data types (Felddatentypen, &lt;b&gt;arrays&lt;/b&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Derived types are sometimes also called &lt;i&gt;complex types&lt;/i&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org343ae46" class="outline-3"&gt;
&lt;h3 id="org343ae46"&gt;Composite data type &lt;code&gt;struct&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org343ae46"&gt;
&lt;p&gt;
The &lt;code&gt;struct&lt;/code&gt; type can be used to deal with variables (elements/members) of different types in combination.
A declaration of a struct type consists of the keyword &lt;code&gt;struct&lt;/code&gt;, a &lt;b&gt;name&lt;/b&gt; (tag) and a list of declarations of elements wrapped in a block of curly braces.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This declaration introduces the type and now variables of this type may be declared and defined in the usual way:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Type and varibale declaration may also be done in one step:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
It is also possible to omit the name/tag (in this case "point") to create an anonymous type:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
However when omitting the tag it is not possible to create another type of the &lt;b&gt;same&lt;/b&gt; type. Even another type that seem structurally equal won't be treated the same and behave as a different type. So remember that anonymous types are not compatible (Question: What happens if I declare multiple anonymous type variables at the same anonymous type declaration? Are those compatible?).
&lt;/p&gt;

&lt;p&gt;
To access an element of a &lt;code&gt;struct&lt;/code&gt; the &lt;code&gt;.&lt;/code&gt; operator is used.
&lt;/p&gt;

&lt;p&gt;
When declaring a &lt;code&gt;struct&lt;/code&gt; it is also possible to initialize a variable of that struct type via &lt;code&gt;varName = { .. };&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;105&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
To only initialize specific elements by their name one can use the following notation with a leading dot to do so:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// order does not matter (ᵔᴥᵔ)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There are only few operations and therefore operators allowed to be used on structs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;assignment via  &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;retrieve address via &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;access elements via &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
It is pretty common practice in C to create anonymous struct variables (the variable is anonymous not the struct!) with malloc/calloc and use them with pointers:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// dot has precedence over * thats why you need parens!&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"member of pt: x=%d, y=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ppt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Because you need to wrap the dereferencing part of a pointer in parens when accessing a member via &lt;code&gt;.&lt;/code&gt; because the dot has higher precedence there is another notation for this common use case.
The &lt;code&gt;-&amp;gt;&lt;/code&gt; operator does exactly this. The following code is therefore equivalent:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;109&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When creating a variable of specific struct type the &lt;code&gt;struct&lt;/code&gt; keyword has always to be used. This gets pretty repetitive and boring quick! That's why you may want to do a little type alias via &lt;code&gt;typedef&lt;/code&gt;.
So instead of:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can do:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Neat! (It is not possible to direclty initialize a variable with &lt;code&gt;typedef&lt;/code&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5158ea7" class="outline-3"&gt;
&lt;h3 id="org5158ea7"&gt;Composite data type &lt;code&gt;union&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5158ea7"&gt;
&lt;p&gt;
A union is a special data type available in C that allows to store different data types in the same memory location. You can define a union with many members, but only one member can contain a value at any given time. Unions provide an efficient way of using the same memory location for multiple-purpose.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Now, a variable of &lt;code&gt;Data&lt;/code&gt; type can store an integer, a floating-point number, or a string of characters. It means a single variable, i.e., same memory location, can be used to store multiple types of data. You can use any built-in or user defined data types inside a union based on your requirement.
&lt;/p&gt;

&lt;p&gt;
The memory occupied by a union will be large enough to hold the largest member of the union. For example, in the above example, Data type will occupy 20 bytes of memory space because this is the maximum space which can be occupied by a character string.
&lt;/p&gt;

&lt;p&gt;
To access a member of a union the &lt;b&gt;member access operator&lt;/b&gt; &lt;code&gt;.&lt;/code&gt; is used as with structs.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga68558a" class="outline-3"&gt;
&lt;h3 id="orga68558a"&gt;Enumeration data type &lt;code&gt;enum&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga68558a"&gt;
&lt;p&gt;
With the help of enumeration data types it is possible to define types with discrete, named values. The corresponding keyword in C is &lt;code&gt;enum&lt;/code&gt;.
We can use this keyword to declare and initialize a sequence of integer constants eg &lt;code&gt;enum colors {RED, YELLOW, GREEN, BLUE};&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Here, colors is the name given to the set of constants - the name is optional. Now, if you don't assign a value to a constant, the default value for the first one in the list - &lt;code&gt;RED&lt;/code&gt; in our case, has the value of &lt;code&gt;0&lt;/code&gt;. The rest of the undefined constants have a value &lt;code&gt;1&lt;/code&gt; more than the one before, so in our case, &lt;code&gt;YELLOW&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, GREEN is &lt;code&gt;2&lt;/code&gt; and BLUE is &lt;code&gt;3&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
But you can assign values if you wanted to also in random order as well:
&lt;code&gt;enum colors {RED=1, YELLOW, GREEN=6, BLUE };&lt;/code&gt;
Now &lt;code&gt;RED=1&lt;/code&gt;, &lt;code&gt;YELLOW=2&lt;/code&gt;, &lt;code&gt;GREEN=6&lt;/code&gt; and &lt;code&gt;BLUE=7&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The main advantage of enum is that if you don't initialize your constants, each one would have a unique value. The first would be zero and the rest would then count upwards.
&lt;/p&gt;

&lt;p&gt;
Enums are helpful to assign specific (constant) values:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;jan&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;apr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jun&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jul&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aug&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oct&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nov&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;escape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;NL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BACKSPACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\b'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TAB&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\t'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RETURN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\r'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BELL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\a'&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Enums are determined at compile time and offer therefore the ability to define constants. This is however &lt;b&gt;only&lt;/b&gt; applies for integer constants.
In contrast to &lt;code&gt;const&lt;/code&gt; (see below) an "unused" (ungebrauchtes) &lt;code&gt;enum&lt;/code&gt; does not need memory space at runtime.
&lt;/p&gt;

&lt;p&gt;
Since enums are basically treated like ints, they only offer restricted type safety.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd6f4856" class="outline-3"&gt;
&lt;h3 id="orgd6f4856"&gt;Array data type&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd6f4856"&gt;
&lt;p&gt;
C provides the derived array type do deal with collection of values with the same type. The declaration of an array doesn't require a keyword, since it is done via the &lt;i&gt;index operator&lt;/i&gt; &lt;code&gt;[]&lt;/code&gt; in which the amount of elements has to be written in and which needs to go after the variable name &lt;code&gt;int xa[10]&lt;/code&gt; (array of 10 ints).
&lt;/p&gt;

&lt;p&gt;
The base type of an array can be of any type, look at the following declarations:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pxa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Array of 10 pointers to integers&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Array of 10 point structs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Elements of an array are also accessed via the index operator &lt;code&gt;int x1 = xa[0];&lt;/code&gt;, however keep in mind that an array of size n has the indexes 0 til n-1 because the indexing of arrays (in C) is zero based as in many programming languages.
&lt;/p&gt;

&lt;p&gt;
It is also possible to declare multidimensional arrays (array which elements are arrays themselves). Eg &lt;code&gt;int xa[4][3]&lt;/code&gt; declares an 4x3 array, which is an array that has 4 elements and those 4 elements are arrays as well with a size of 3 elements that can hold ints.
Basically this can be done for an arbitrary amount of arrays inside arrays &lt;code&gt;int xa[4][3][2]&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Since C90 it is possible to create variable arrays. That means arrays of variable length which is determined at runtime, for example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
In C11 this is still possible however one should not rely on this with regards to portability.
&lt;/p&gt;

&lt;p&gt;
VLA (variable length array) also have some disadvantages:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;cannot be &lt;code&gt;static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cannot be part of &lt;code&gt;struct&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;"Der Steuerfluss darf niemals hinter die Deklaration eines VLA in dessen Gültigkeitsbereich gelangen" (? ლ,ᔑ•ﺪ͟͠•ᔐ.ლ)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Similar to structs array can be initialized with curly braces &lt;code&gt;int xa[4] = {1, 2, 3, 4};&lt;/code&gt; . This also works for multidimensional arrays:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When an array is initialized when its defined the (last) dimension may also be ommitted &lt;code&gt;int xa[] = {5, 2, 1}&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Since C90 it is also possible to do a partial initialization ala &lt;code&gt;int xa[10] = { [4] = 43, [1] = 5 };&lt;/code&gt; . The elements which are not explicitly initialized then default to &lt;code&gt;0&lt;/code&gt;. Similar to enums the following is also possible:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
… results in &lt;code&gt;200,0,0,43,8,5,0,0&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
When passing arrays to functions it is said that arrays "decay" into pointers.
If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, sizeof no longer gives the complete array's size, because it essentially becomes a pointer. This is why it's preferred (among other reasons) to pass by reference or pointer.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* array.c -- an array decays */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;myarray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myarray&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of a: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// really yields pointer size (8 byte on 64 bit machines)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;myarray&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of x: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// decay looses dimensions thats why this is possible&lt;/span&gt;
  &lt;span class="n"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;x:&lt;/td&gt;
&lt;td class="org-right"&gt;40&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;a:&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;a:&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
So when passing an array, what really gets passed is a pointer to the first element in the array. Therefore the following function declarations are equivalent:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;[]);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
A problem that occurs here is that there is no way to find out how big/large the array is that was passed. That's why many function which have arrays as parameters, have another (auxillary) parameter to specify the amount of elements of the array:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* array_param .c -- auxiliary parameter */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;[]);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="n"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;654&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="n"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;32&lt;/td&gt;
&lt;td class="org-right"&gt;32&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-right"&gt;54&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;td class="org-right"&gt;77&lt;/td&gt;
&lt;td class="org-right"&gt;654&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org97ebf84" class="outline-2"&gt;
&lt;h2 id="org97ebf84"&gt;Memory Layout&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org97ebf84"&gt;
&lt;p&gt;
Why is it that we can treat arrays as pointers? It is because array values are stored in contiguous memory locations. The array &lt;code&gt;int x[6] = {1, 2, 3, 4, 5, 6};&lt;/code&gt; is for example stored like this in memory:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/array-in-memory.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
This also applies to multidimensional arrays:
&lt;code&gt;int x[4][12] = {{11,12}, {21,22}, {31,32}, {41,42}};&lt;/code&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/multi-array-in-memory.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The notion of &lt;code&gt;xa[i]&lt;/code&gt; is actually just a different syntax for &lt;code&gt;*(&amp;amp;xa+i)&lt;/code&gt; (give me the address of xa which really gives the address of the first element of xa, then add i&lt;sup&gt;1&lt;/sup&gt; to it and dereference the resulting address to give me the value).
&lt;/p&gt;

&lt;p&gt;
1 When adding an integer to a pointer, the integer is multiplied by the size of the type that the pointer points to because that is the "distance between the addresses" in memory. One memory location usually stores 1 Byte (8 bits) on modern systems. So when an integer is stored in 4 bytes than the offset between the first and second address of an int value in a array would be 4.
&lt;/p&gt;

&lt;p&gt;
Look at the following code which is really interesting and makes a lot of things clear:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of int %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Size  of  int  4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdd810cc" class="outline-2"&gt;
&lt;h2 id="orgdd810cc"&gt;Char Arrays&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdd810cc"&gt;
&lt;p&gt;
As we already know C does not provide strings by default. That's why &lt;code&gt;char&lt;/code&gt; arrays are "abused" as such. There is a special way to intialize char arrays in C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello!"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which really is the equivalent to:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;'H'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As you can see character strings are stored as an array containing the characters and are terminated with a &lt;i&gt;null character&lt;/i&gt; (&lt;code&gt;0&lt;/code&gt; or &lt;code&gt;'\0'&lt;/code&gt;). Therefore &lt;code&gt;'\0'&lt;/code&gt; musnt be in any string because it designates the ending of a string.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"World"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"5th ('last') char: %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Really last element of the array %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of str: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// 5 characters + null character = 6&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
A terminating 0 is a C convention and many functions from the standard library for example assume that as well (&lt;code&gt;int printf(char*,...)&lt;/code&gt;, &lt;code&gt;int atoi(char*)&lt;/code&gt;). A convention can be broken tho! Look at the following example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;'H'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// no terminating 0!&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;bla&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;" This is top secret&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Hello This is top secret

&lt;/pre&gt;

&lt;p&gt;
I faked this output result for illustrating purposes because most modern compilers do not store those stuff sequentially anymore to reduce vulnerabilities (reading out values). plz have mercy. It really just printed "Hello".
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga704855" class="outline-2"&gt;
&lt;h2 id="orga704855"&gt;Parameters of &lt;code&gt;main()&lt;/code&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga704855"&gt;
&lt;p&gt;
The signature of C's  &lt;code&gt;main()&lt;/code&gt; function is mentioned by C11 as the following:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int argc&lt;/code&gt; ist the count of prorgam parameters
&lt;ul class="org-ul"&gt;
&lt;li&gt;because the name of the program is always passed when executing main with params &lt;code&gt;argc&lt;/code&gt; is at least &lt;code&gt;1&lt;/code&gt; because that's the program name&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char* argv&lt;/code&gt; is the argument vector resp. an array of &lt;b&gt;pointers&lt;/b&gt; to C-Strings
&lt;ul class="org-ul"&gt;
&lt;li&gt;each of those C-Strings holds a &lt;i&gt;program parameter&lt;/i&gt; (inclusive the program name at &lt;code&gt;argv[0]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is what the &lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf"&gt;C11 standard&lt;/a&gt; says:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt; represents the program name;
&lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the program name is not available from the host environment. 
If the value of &lt;code&gt;argc&lt;/code&gt; is greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt; represent the program parameters.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/argv-argc.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
As already mentioned the declaration &lt;code&gt;char *argv[]&lt;/code&gt; stands for an &lt;b&gt;array of pointers to &lt;code&gt;char&lt;/code&gt;'s&lt;/b&gt;
Calling for example the code from the picture above this is how the corresponding memory layout would look like:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/argv-memory-layout.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org3b6c440" class="outline-2"&gt;
&lt;h2 id="org3b6c440"&gt;Revision: Storage Classes and Storage Types/Attributes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3b6c440"&gt;
&lt;p&gt;
→ see "Named Variables" in Lecture 06
&lt;/p&gt;

&lt;p&gt;
Storage classes:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; → variables can only be accessed within the block of declaration which defines their scope&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; → life cycle does not end with ending scope and last value is preserved through program execution; does not affect visibility&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; →  only declares a variable/function/we, addidtional definition is required (usally in another module or a library)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt; → same functionality as auto variables with the difference that the compiler tries to store these variables in the register of the microprocessor, which makes access much faster than that of the variables stored in memory
&lt;ul class="org-ul"&gt;
&lt;li&gt;address of register variables &lt;b&gt;is not retrievable using pointers&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The following code would not compile! (&lt;code&gt;error: address of register variable ‘fastInt’ requested&lt;/code&gt;)
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fastInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;pf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fastInt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Fast int: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fastInt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Storage types (&lt;b&gt;Type Qualifiers&lt;/b&gt; seems to be the proper term, Speicherattribute in Skript):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;constants are also like normal variables with the difference that their values can’t be modified by the program once they are defined (compiler prohibits assignment anywhere else than when initialized)&lt;/li&gt;
&lt;li&gt;enables the compiler to do some optimizations&lt;/li&gt;
&lt;li&gt;Gotchas:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;const int * p&lt;/code&gt; declares a &lt;i&gt;variable&lt;/i&gt; pointer to a &lt;i&gt;constant&lt;/i&gt; integer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int * const p&lt;/code&gt; declares a &lt;i&gt;constant&lt;/i&gt; pointer to a &lt;i&gt;variable&lt;/i&gt; integer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
&lt;code&gt;volatile&lt;/code&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;volatile (flüchtig, sprunghaft) variables indicate to the compiler that their value might have changed since the last explicit writing operation&lt;/li&gt;
&lt;li&gt;eg, if global variable’s address is passed to clock routine of the operating system to store the system time, the value in this address keep on changing without any assignment by the program&lt;/li&gt;
&lt;li&gt;indicates that the object should not be subject to compiler optimizations altering references to, or modifications of, the object&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;restrict&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;introduced in C99&lt;/li&gt;
&lt;li&gt;only for pointer variables (and hereby derived for arrays)&lt;/li&gt;
&lt;li&gt;it doesn’t add any new functionality and it is only a way for programmers to inform about optimizations that the compiler can make&lt;/li&gt;
&lt;li&gt;when using &lt;code&gt;restrict&lt;/code&gt; with a pointer &lt;code&gt;ptr&lt;/code&gt;, it tells the compiler that &lt;code&gt;ptr&lt;/code&gt; is the only way to access the object pointed by it and compiler doesn’t need to add any additional checks
&lt;ul class="org-ul"&gt;
&lt;li&gt;for example when a variable is restrict the compiler will not reload the value at that adddress in its assembly code and therefore the assembly code is optimized&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
(Since C11 there is also &lt;code&gt;_Atomic&lt;/code&gt; &lt;a href="https://en.cppreference.com/w/c/language/atomic"&gt;here is more&lt;/a&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-08/</guid><pubDate>Thu, 01 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 07</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-07/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgb6513fa" class="outline-2"&gt;
&lt;h2 id="orgb6513fa"&gt;Storage and memory&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb6513fa"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge040e05" class="outline-3"&gt;
&lt;h3 id="orge040e05"&gt;Parameters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge040e05"&gt;
&lt;p&gt;
Besides the named variables for which memory is allocated at compile time and anonymous variables for which memory is allocated at runtime, there is a third kind of variables → &lt;b&gt;parameters&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Parameters are variables that are automatically created and initialized when a function is called.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;lifecycle&lt;/b&gt; → retention time (Verweilzeit) of the program in that function &lt;i&gt;instance&lt;/i&gt; (the surrounding function)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;visibility&lt;/b&gt; → whole function body as long as it's not shadowed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Parameters are declared and defined whith the function definition. They cannot have /storage classes/(auto, static, extern, register), but may have /storage types/(const, volatile, restrict).
&lt;/p&gt;

&lt;p&gt;
The term parameter (sometimes called formal parameter) is used to refer to the variable as found in the function definition which is used in the function body, while argument (sometimes called actual parameter) refers to the actual input supplied at function call.
&lt;/p&gt;

&lt;p&gt;
In general there are two ways of assocating an argument with a parameter. C for example uses &lt;b&gt;positional parameters&lt;/b&gt; &lt;i&gt;only&lt;/i&gt; which means arguments have to be provided in the order specified by the function definition. 
&lt;/p&gt;

&lt;p&gt;
Python in contrast provides the option to use positional arguments as well as &lt;b&gt;named parameters&lt;/b&gt;.
A function call using named parameters differs from a regular function call in that the values are passed by associating each one with a parameter name, instead of providing an ordered list of values.
&lt;/p&gt;

&lt;p&gt;
In languages with no named parameters, the order of parameters in a function call is necessarily fixed, since it is the only way that the language can identify which value is intended to be used for which purpose.
&lt;/p&gt;

&lt;p&gt;
With named parameters, it is usually possible to provide the values in any arbitrary order, since the name attached to each value identifies its purpose. This reduces the connascence between parts of the program. A few languages use named parameters but still require the parameters to be provided in a specific order.
&lt;/p&gt;

&lt;p&gt;
Example usage of &lt;b&gt;ordered/positional parameters&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;testFun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Title"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Example usage of &lt;b&gt;named parameters&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;testFun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Title"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;xPosition&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;yPosition&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;drawingNow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Besides the different ways to associate parameters and arguments, there are different ways in which arguments are &lt;i&gt;passed&lt;/i&gt; to the function!
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;call by value&lt;/b&gt;: the actual parameter (argument) is evaluated and the formal parameter recieves that value (the function recieves a copy of the value)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by name&lt;/b&gt;: the formal parameter is replaced by the name of the actual parameter&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by reference&lt;/b&gt;: the formal parameter becomes a "proxy object" (Stellvertreterobjekt) for the argument so that all changes are immediately effective outside of the function as well&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by copy/return&lt;/b&gt;: the argument is evaluated and the formal parameter gets this value at the begin of the function; when the function execution finishes the value of the formal parameter is assigned to the actual parameter (copy in - copy out, call by value - return)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In C the only way of passing parameters is &lt;b&gt;by value&lt;/b&gt; and it does not know the concept of procedures and reference parameters. 
&lt;/p&gt;

&lt;p&gt;
To be still able to manipulate values outside of the executing function one may pass &lt;i&gt;pointers&lt;/i&gt;. Changes outside of the function scope can then be realised via dereferencing those pointers. The effect of this is basically the same as it would be when calling by reference and is an often used practice in C.
&lt;/p&gt;

&lt;p&gt;
A manipulation of values outside of a functions local variables (including parameters) is called &lt;i&gt;side effect&lt;/i&gt; (input &amp;amp; output is also a side effect).
&lt;/p&gt;

&lt;p&gt;
Example of manipulating a value outside of a functions local scope via pointer and therefore simulating reference parameters:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* sideeffect .c -- simulated reference parameter */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sideeffect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;sideeffect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sideeffect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;x=42&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;x=23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Another use case of reference parameters is value input. The function &lt;code&gt;scanf()&lt;/code&gt; from the standard library provides this functionality. Similar to &lt;code&gt;printf()&lt;/code&gt; the parameters begin with a format string, followed by a sequence of pointers to the variables where the input should be stored in. &lt;code&gt;scanf&lt;/code&gt; returns the count of successfully read variables.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Give the point as &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;(x,y )&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;: "&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"(%d ,%d)"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You provided : (%d, %d).&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c9f9d6" class="outline-3"&gt;
&lt;h3 id="org8c9f9d6"&gt;Excursus: Variables and References in Python&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8c9f9d6"&gt;
&lt;p&gt;
Parameter passing in Python is somewhat special. It is not one of the most known methods like "pass-by-value" or "pass-by-reference", in fact parameter passing in Python is &lt;b&gt;"pass-by-object-reference"&lt;/b&gt; of which is often said "Object references are passed by value".
&lt;/p&gt;

&lt;p&gt;
What is actually happening when you make a variable assignment? This is an important question in Python, because the answer differs somewhat from what you’d find in many other programming languages.
&lt;/p&gt;

&lt;p&gt;
Python is a highly object-oriented language. In fact, virtually every item of data in a Python program is an object of a specific type or class. 
&lt;/p&gt;

&lt;p&gt;
When presented with the statement &lt;code&gt;print(300)&lt;/code&gt;, the interpreter does the following:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Creates an integer object&lt;/li&gt;
&lt;li&gt;Gives it the value 300&lt;/li&gt;
&lt;li&gt;Displays it to the console&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A Python variable is a symbolic name that is a reference or pointer to an object. Once an object is assigned to a variable, you can refer to the object by that name. But the data itself is still contained within the object.
&lt;/p&gt;

&lt;p&gt;
For example the assignment &lt;code&gt;n = 9000&lt;/code&gt; creates an integer object with the value &lt;code&gt;300&lt;/code&gt; and assigns the variable &lt;code&gt;n&lt;/code&gt; to point to that object:
\[n \longrightarrow \fbox{9000}\]
&lt;/p&gt;

&lt;p&gt;
Now consider the following statement &lt;code&gt;m = n&lt;/code&gt;. What happens when it is executed? Python does not create another object. It simply creates a new symbolic name or reference, &lt;code&gt;m&lt;/code&gt;, which points to the same object that &lt;code&gt;n&lt;/code&gt; points to.
\[n \longrightarrow \fbox{9000} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
Next suppose you do this &lt;code&gt;m = 400&lt;/code&gt;. Now Python creates a new integer object with the value &lt;code&gt;400&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; becomes a reference to it:
\[n \longrightarrow \fbox{9000} \\ \fbox{400} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
Lastly, suppose this statement is executed next &lt;code&gt;n = "foo"&lt;/code&gt; . Now Python creates a string object with the value &lt;code&gt;"foo"&lt;/code&gt; and makes &lt;code&gt;n&lt;/code&gt; reference that.
&lt;/p&gt;

&lt;p&gt;
\[n \longrightarrow \fbox{"foo"} \\ \fbox{9000} \\ \fbox{400} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
There is no longer any reference to the integer object &lt;code&gt;9000&lt;/code&gt;. It is orphaned, and there is no way to access it.
&lt;/p&gt;

&lt;p&gt;
An object’s life begins when it is created, at which time at least one reference to it is created. During an object’s lifetime, additional references to it may be created, as you saw above, and references to it may be deleted as well. An object stays alive, as it were, so long as there is at least one reference to it.
&lt;/p&gt;

&lt;p&gt;
When the number of references to an object drops to zero, it is no longer accessible. At that point, its lifetime is over. Python will eventually notice that it is inaccessible and reclaim the allocated memory so it can be used for something else. In computer lingo, this process is referred to as garbage collection.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7f04363" class="outline-4"&gt;
&lt;h4 id="org7f04363"&gt;Object Identity&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7f04363"&gt;
&lt;p&gt;
In Python, every object that is created is given a number that uniquely identifies it. It is guaranteed that no two objects will have the same identifier during any period in which their lifetimes overlap. Once an object’s reference count drops to zero and it is garbage collected, as happened to the &lt;code&gt;9000&lt;/code&gt; object above, then its identifying number becomes available and may be used again.
&lt;/p&gt;

&lt;p&gt;
The built-in Python function &lt;code&gt;id()&lt;/code&gt; returns an object’s integer identifier. Using the &lt;code&gt;id()&lt;/code&gt; function, you can verify that two variables indeed point to the same object:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;768&lt;/span&gt;
&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
True

&lt;/pre&gt;
&lt;p&gt;
After the assignment &lt;code&gt;m = n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; both point to the same object, confirmed by the fact that &lt;code&gt;id(m)&lt;/code&gt; and &lt;code&gt;id(n)&lt;/code&gt; return the same number.
&lt;/p&gt;

&lt;p&gt;
Now take a look at the following code:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"a="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(a)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"b="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(b)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"a="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(a)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
a= 23 , id(a)= 140345766270720
b= 42 , id(b)= 140345766271328
a= 42 , id(a)= 140345766271328

&lt;/pre&gt;

&lt;p&gt;
When dealing with &lt;i&gt;immutable objects&lt;/i&gt; (eg integers, bool, string) a variable assignment like &lt;code&gt;a = a+19&lt;/code&gt; &lt;b&gt;does not&lt;/b&gt; modify the &lt;i&gt;object&lt;/i&gt;, instead
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a &lt;b&gt;new object&lt;/b&gt; is created and referenced&lt;/li&gt;
&lt;li&gt;or if such object (eg obj with value &lt;code&gt;42&lt;/code&gt;) already exists it is referenced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Complex objects (eg list, dict, set) are &lt;i&gt;mutable&lt;/i&gt;. When operating on them, they are changed directly without the creation of new objects so the reference stays the same.
&lt;/p&gt;

&lt;p&gt;
In the code example above an object holding the integer &lt;code&gt;42&lt;/code&gt; already existed and was referenced by &lt;code&gt;b&lt;/code&gt; and thats why assigning &lt;code&gt;42&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; changes the reference to point to the same object, which is verified by comparing the object ids with &lt;code&gt;id()&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
So parameter passing in Python passes &lt;b&gt;object references&lt;/b&gt;. 
&lt;/p&gt;

&lt;p&gt;
In case of &lt;i&gt;immutable objects&lt;/i&gt; modifications inside the called function leads to creation and then referencing of other objects. Outside of the function the same ol' object is referenced, which was not modified so this has the same effect as "pass-by-value".
&lt;/p&gt;

&lt;p&gt;
In case of &lt;i&gt;mutable objects&lt;/i&gt; no new references and objects would be created when modifications occur so variables outside of the function that refer to the same object reference the same object to which the modifications are applied. This has the same effect as "pass-by-reference".
&lt;/p&gt;

&lt;p&gt;
Sources of the python excursus: &lt;a href="https://realpython.com/python-variables/"&gt;https://realpython.com/python-variables/&lt;/a&gt; and &lt;a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/"&gt;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-07/</guid><pubDate>Mon, 29 Oct 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 06</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-06/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org28bcc5a" class="outline-2"&gt;
&lt;h2 id="org28bcc5a"&gt;Storage and memory&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org28bcc5a"&gt;
&lt;p&gt;
Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;storing in the file system (good for big data sets but slow)&lt;/li&gt;
&lt;li&gt;storing in memory (faster but limited in some aspects as well)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We continue with the latter option (ᵔᴥᵔ).
&lt;/p&gt;

&lt;p&gt;
C is theoretically able to write to and acces every place in memory. Due to the implied dangers of this, most operating systems prevent this to some degree. There are three fundamental methods to reserve (&lt;b&gt;allocate&lt;/b&gt;) memory:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(implicit) "named" memory allocation at compile time&lt;/li&gt;
&lt;li&gt;"anonymous" memory allocation at run time&lt;/li&gt;
&lt;li&gt;parameters which allocate storage at run rime as well&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The terms "named" and "anonymous" are taken from the lecture script, I don't like them and think they're confusing. As I understand it the first method refers to the memory allocation that happens when you have e.g &lt;code&gt;int num = 5;&lt;/code&gt; in your code and the compiler allocates/reserves at least 16 bits (2 bytes), while the second method refers to dynamic memory allocation via &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;calloc()&lt;/code&gt;. I'm not entirely sure if this is what the professor means xD. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgee5753f" class="outline-3"&gt;
&lt;h3 id="orgee5753f"&gt;Variables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgee5753f"&gt;
&lt;p&gt;
Should the value of a place in memory be modified (purpose of the state model), you speak of (named or anonymous) &lt;i&gt;variables&lt;/i&gt;. Should the value in memory stay unchanged, then it is a &lt;i&gt;constant&lt;/i&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0b77064" class="outline-4"&gt;
&lt;h4 id="org0b77064"&gt;Named variables&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0b77064"&gt;
&lt;p&gt;
Named variables in C have to be declared (analogus to functions). The declarations has to contain the type of the variable as well as the name. It is possible to declare multiple variables of the same type together ala &lt;code&gt;int x, y ,z;&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
When declaring a variable it is possible to also provide a &lt;i&gt;storage class&lt;/i&gt; and/or a &lt;i&gt;type qualifier&lt;/i&gt;. The storage class is declared via one of the following keywors &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt;. These basically impact the &lt;i&gt;scope&lt;/i&gt;, &lt;i&gt;visibility/(?! might be wrong) and the /life time&lt;/i&gt; of the specific variable.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; (assumed by default if no other storage class is specified)
&lt;ul class="org-ul"&gt;
&lt;li&gt;not often written because it is the default&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; variables can only be accessed within the block of declaration which defines their scope&lt;/li&gt;
&lt;li&gt;however they can be accessed outside their scope by using pointers&lt;/li&gt;
&lt;li&gt;get a garbage value assigned whenever they are declared (without initilization)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; variables preserve their (last) value even after they are out of scope&lt;/li&gt;
&lt;li&gt;therefore &lt;i&gt;only initialized once&lt;/i&gt; and exist until program termination, thus no new memory is allocated because they are not redeclared&lt;/li&gt;
&lt;li&gt;their scope is local to the function in which they were defined, global static variables can be accesed anywhere&lt;/li&gt;
&lt;li&gt;are assigned &lt;code&gt;0&lt;/code&gt; by default from the compiler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;same functionality as auto variables with the difference that the compiler tries to store these variables in the register of the microprocessor, which makes access much faster than that of the variables stored in memory&lt;/li&gt;
&lt;li&gt;if no free register is available the variable is stored in memory&lt;/li&gt;
&lt;li&gt;address of register variables is not retrievable using pointers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Type qualifiers are declared via the keywords &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;restrict&lt;/code&gt; and give hints to the compiler about the usage of the variables (see "Storage Classes and Storage Types/Attributes" in Lecture 08).
&lt;/p&gt;

&lt;p&gt;
Variables declared outside of any function are &lt;i&gt;global variables&lt;/i&gt;, while variables declared in blocks (&lt;code&gt;{..}&lt;/code&gt;) are &lt;i&gt;local variables&lt;/i&gt;. Only with the exception of variables with a storage class of &lt;code&gt;extern&lt;/code&gt;, variables are also &lt;i&gt;defined&lt;/i&gt; when they are &lt;i&gt;declared&lt;/i&gt; that means that memory for the varibale is automatically allocated in memory (dont mix this with initializing and/or assigning) without the programmer having to do anything.
&lt;/p&gt;

&lt;p&gt;
When the variable has a storage class of &lt;code&gt;extern&lt;/code&gt; it is &lt;b&gt;only declared&lt;/b&gt; but not defined and therefore has to be &lt;i&gt;globally defined&lt;/i&gt; (in a different module).
&lt;/p&gt;

&lt;p&gt;
A variable can be assigned a value via &lt;code&gt;0&lt;/code&gt;, this can also be done when declaring a variable → &lt;b&gt;initilization&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org34ce971"&gt;&lt;/a&gt;Addresses&lt;br&gt;
&lt;div class="outline-text-5" id="text-org34ce971"&gt;
&lt;p&gt;
Every variable has an address (place in memory where it is stored) that can be retrieved with the &lt;code&gt;&amp;amp;&lt;/code&gt; "address of" operator
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="cm"&gt;/* addr .c -- address of a variable */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Variable var has the address %p and the value %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Variable var has the address 0x7ffc5d3f3694 and the value 42

&lt;/pre&gt;

&lt;p&gt;
Actually the identifier of a variable (eg &lt;code&gt;testVar&lt;/code&gt;) is just a synonym of the address.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/identifier-memory.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgcbb85d2"&gt;&lt;/a&gt;Pointer&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgcbb85d2"&gt;
&lt;p&gt;
Variables can also hold addresses themselves! The prefix &lt;code&gt;*&lt;/code&gt; infront of the identifier of a variable makes it a pointer variable. It is essential for the compiler of what this address is built, therefore a pointer is always pointing to another &lt;b&gt;specific&lt;/b&gt; type. For instance:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int *p&lt;/code&gt; → pointer that is pointing to an integer type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float *p&lt;/code&gt; → pointer that is pointing to a float type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int *p&lt;/code&gt; → pointer that is pointing to an unsigned integer type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
If a generic memory address without a specific type shall be used then the base type &lt;code&gt;void&lt;/code&gt; is used:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void *p&lt;/code&gt; pointer that is pointing to an address&lt;/li&gt;
&lt;li&gt;assigning void pointers is compatible to/with all other pointer types (→ no warnings!)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* addr2 .c -- pointer to a variable */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Variable var has the address %p and the value %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Variable pvar has the address %p and the value %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The value that the pointer stored in pvar points to is %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Variable var has the address 0x7ffd08a3f97c and the value 42
Variable pvar has the address 0x7ffd08a3f980 and the value 0x7ffd08a3f97c
The value that the pointer stored in pvar points to is 42

&lt;/pre&gt;

&lt;p&gt;
Example memory representation of the above code (addresses will differ):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/pointer-memory-representation.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
A type and its derived type (eg &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;int *&lt;/code&gt;) are &lt;i&gt;different&lt;/i&gt; types.
&lt;/p&gt;

&lt;p&gt;
As seen in the code example above a pointer can be &lt;b&gt;dereferenced&lt;/b&gt; via the dereference operator &lt;code&gt;*&lt;/code&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* deref .c -- deref a pointer */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y=%d (at %p)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* same effect as printf ("y=%d\n" ,y); */&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* same effect as y=42 */&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y=%d (at %p)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
y=23 (at 0x7ffeeff30f1c)
y=42 (at 0x7ffeeff30f1c)

&lt;/pre&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf8a29f4" class="outline-4"&gt;
&lt;h4 id="orgf8a29f4"&gt;Anonymous variables&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf8a29f4"&gt;
&lt;p&gt;
Anonymous variables in C don't have a name but get memory allocated nevertheless. They are created at &lt;i&gt;run time&lt;/i&gt; with functions from the C standard library. Anonymous variables are &lt;b&gt;not declared&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
More specifically the following functions that are &lt;i&gt;declared&lt;/i&gt; in &lt;code&gt;stdlib.h&lt;/code&gt; are used to allocate memory at run time:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void *malloc(size_t size)&lt;/code&gt; → reserves &lt;code&gt;size&lt;/code&gt; bytes in memory (memory allocate)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *calloc(size_t count, size_t size)&lt;/code&gt; → reserves &lt;code&gt;count x size&lt;/code&gt; bytes in memory and initializes them with a value of &lt;code&gt;0&lt;/code&gt; (count allocate)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Both functions retrun the &lt;b&gt;address&lt;/b&gt; of the anonymous variable.
&lt;/p&gt;

&lt;p&gt;
To find out how much size/space is needed, C's &lt;code&gt;sizeof&lt;/code&gt; operator comes in handy because the size of eg an &lt;code&gt;int&lt;/code&gt; is not the same on all systems. It can be used on variables as well as on types and &lt;code&gt;sizeof(int)&lt;/code&gt; return for example &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The programmer has (in contrast to named variables) manage the scope and lifecycle of anonymous variables. To release the memory that was allocated for an anonymous variable &lt;code&gt;void free(void*)&lt;/code&gt; is used which takes the address of the anonymous variable.
To be able to do this you of course need the address of the anonymous variable and that is (amongst other reasons) why you should store it somewhere!
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* malloc .c -- anonymous variables */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// declare pointer to int&lt;/span&gt;

  &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// allocate memory for an int and store the returned address of the allocated memory location and store it in p&lt;/span&gt;

  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// dereference p and store the value 42&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Pointer p has address %p and points to %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Anonymous variable has the value %d which is stored in %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* pass address and release memory */&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Pointer p has address 0x7fff1376cea0 and points to 0x55ffde405260
Anonymous variable has the value 42 which is stored in 0x55ffde405260

&lt;/pre&gt;

&lt;p&gt;
In the example above you can see that the variable is anonymous because the value &lt;code&gt;42&lt;/code&gt; is nowhere stored directly in a named variable but is retrieved by dereferencing the pointer that points to the memory location where &lt;code&gt;42&lt;/code&gt; is stored (&lt;code&gt;*p&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Not releasing allocated memory can lead to so called &lt;i&gt;memory leaks&lt;/i&gt; and is a frequent error cause. Another frequent error is trying to use anonymous variables that are already released (&lt;i&gt;dangling pointer&lt;/i&gt;).
&lt;/p&gt;

&lt;p&gt;
Helping advice to avoid the above errors:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when you allocate memory with eg &lt;code&gt;malloc&lt;/code&gt; immediately write the code to free the memory as well&lt;/li&gt;
&lt;li&gt;when releasing/freeing an anonymous variable assign it the (symbolic) value &lt;code&gt;NULL&lt;/code&gt; which is defined in &lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;it is guaranteed that there is never another variable at a location that is described by &lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dereferencing &lt;code&gt;NULL&lt;/code&gt; leads to a run time error&lt;/li&gt;
&lt;li&gt;if functions like &lt;code&gt;malloc&lt;/code&gt; fail they also return &lt;code&gt;NULL&lt;/code&gt; therefore it is advised to check pointers against &lt;code&gt;null&lt;/code&gt; before using them&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1ed2e62" class="outline-4"&gt;
&lt;h4 id="org1ed2e62"&gt;Parameters&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1ed2e62"&gt;
&lt;p&gt;
Parameters are the third way memory is allocated to store values. We covered this in the next lecture (lecture 07). (¬‿¬)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-06/</guid><pubDate>Thu, 25 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 05</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-05/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org808418c" class="outline-2"&gt;
&lt;h2 id="org808418c"&gt;Type and signature&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org808418c"&gt;
&lt;p&gt;
Similar to functions in math functions in C (or programming for that matter) have a domain (Defintionsbereich/Definitionsmenge) and a codomain (Wertebereich/Zielmenge). Additionally to the name a function declaration (respective definiton) contains the domain and codomain:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;euclid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The type of the return value of euclid is &lt;code&gt;int&lt;/code&gt; and defines the codomain, which in this case is a set of integers. The domain is specified via the parameter types in this case &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; so also sets of integers. Mathematically expressed the code would look like this &lt;code&gt;euclid: int x int ⟶ int&lt;/code&gt; (an element out of the integer set emerges out of the domain &lt;code&gt;int x int&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Technically &lt;code&gt;int x int ⟶ int&lt;/code&gt; is the type of the function "euclid". Practically however it became established to view the codomain as "type" of the function. Following this you'd say "euclid" has the type &lt;code&gt;int&lt;/code&gt;, however &lt;i&gt;return type&lt;/i&gt; would be the more accurate term.
&lt;/p&gt;

&lt;p&gt;
The type together with the name of a functions builds the functions &lt;i&gt;signature&lt;/i&gt;. A declaration therefore introduces function signature to the compiler.
&lt;/p&gt;

&lt;p&gt;
Many operators look the same e.g &lt;code&gt;+&lt;/code&gt; but do different things depending on the context, which is the particular type. Typing helps the compiler to find the right procedure. Although there are other programming languages that do not require type declarations and infer types automatically for instance Javascript. This is called &lt;i&gt;type inference&lt;/i&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5291cee" class="outline-2"&gt;
&lt;h2 id="org5291cee"&gt;Basic types (primitive data types)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5291cee"&gt;
&lt;p&gt;
C provides few basic types. Yet it is possible to "build" more types. Since the sets are described by the C types are not infinite they are subsets of for example the natural numbers.
C99 knows the following basic types:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;subsets of integers&lt;/li&gt;
&lt;li&gt;subsets of rational numbers&lt;/li&gt;
&lt;li&gt;boolean values&lt;/li&gt;
&lt;li&gt;subset of complex numbers&lt;/li&gt;
&lt;li&gt;empty set&lt;/li&gt;
&lt;li&gt;memory addresses (which are derived types!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
More on &lt;a href="https://en.wikipedia.org/wiki/C_data_types"&gt;C data types&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0d9fb7e" class="outline-3"&gt;
&lt;h3 id="org0d9fb7e"&gt;Integers &amp;amp; Chars&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0d9fb7e"&gt;
&lt;p&gt;
C offers the following keywords in regards to integers
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;type specifiers: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;modifiers: &lt;code&gt;short&lt;/code&gt; (not for &lt;code&gt;char&lt;/code&gt;!), &lt;code&gt;long&lt;/code&gt; (not for &lt;code&gt;char&lt;/code&gt;!), &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;signed&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
When the type &lt;code&gt;int&lt;/code&gt; is modified it may be omitted as a keyword.
&lt;/p&gt;

&lt;p&gt;
But why do different types exist for integers? Well differently sized values need different amounts of storage space. A computer stores values in bits (&lt;b&gt;bi&lt;/b&gt; nary dig &lt;b&gt;its&lt;/b&gt;). In \(n\) bits it is possible to store \(2^n\) different values. Typically the smallest addressable unit is a &lt;b&gt;byte&lt;/b&gt; (= 8 bit). Values are therefore stored in one or more bytes.
&lt;/p&gt;

&lt;p&gt;
Choosing the the "right" type is hence always a compromise between the amount of different values and the size in storage (+ access speed).
&lt;/p&gt;

&lt;p&gt;
All types which name contains &lt;code&gt;unsigned&lt;/code&gt; are "vorzeichenlos", those which contain &lt;code&gt;signed&lt;/code&gt; are "vorzeichenbehaftet". In case of just &lt;code&gt;int&lt;/code&gt; without a sign modifier the type is always signed. In case of &lt;code&gt;char&lt;/code&gt; this is up to the compiler. For most types there are no concrete sets defined, however some ranges are guaranteed:
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Type&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Range&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Format specifier&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Smallest addressable unit of the machine that can contain basic character set. It is an integer type. Actual type can be either signed or unsigned.&lt;/td&gt;
&lt;td class="org-left"&gt;%c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;signed char&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Of the same size as &lt;code&gt;char&lt;/code&gt;, but guaranteed to be signed. Capable of containing at least the [−127, +127] range&lt;/td&gt;
&lt;td class="org-left"&gt;%c (or %hhi for numerical output)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;unsigned char&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Of the same size as &lt;code&gt;char&lt;/code&gt;, but guaranteed to be unsigned. Contains at least the [0, 255] range&lt;/td&gt;
&lt;td class="org-left"&gt;%c (or %hhu for numerical output)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;short&lt;/code&gt; &lt;code&gt;short int&lt;/code&gt; &lt;code&gt;signed short&lt;/code&gt; &lt;code&gt;signed short int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Short signed integer type. Capable of containing at least the [−32,767, +32,767] range* thus at least 16 bits in size&lt;/td&gt;
&lt;td class="org-left"&gt;%hi&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;unsigned short&lt;/code&gt; &lt;code&gt;unsigned short int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Short unsigned integer type. Contains at least the [0, 65,535] range;&lt;/td&gt;
&lt;td class="org-left"&gt;%hu&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int&lt;/code&gt; &lt;code&gt;signed&lt;/code&gt; &lt;code&gt;signed int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Basic signed integer type. Capable of containing at least the [−32,767, +32,767] range thus, it is at least 16 bits in size.&lt;/td&gt;
&lt;td class="org-left"&gt;%i or %d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;unsigned&lt;/code&gt; &lt;code&gt;unsigned int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Basic unsigned integer type. Contains at least the [0, 65,535] range&lt;/td&gt;
&lt;td class="org-left"&gt;%u&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;long&lt;/code&gt; &lt;code&gt;long int&lt;/code&gt; &lt;code&gt;signed long&lt;/code&gt; &lt;code&gt;signed long int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Long signed integer type. Capable of containing at least the [−2,147,483,647, +2,147,483,647] range;[3][4] thus, it is at least 32 bits in size&lt;/td&gt;
&lt;td class="org-left"&gt;%li&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;unsigned long&lt;/code&gt; &lt;code&gt;unsigned long int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Long unsigned integer type. Capable of containing at least the [0, 4,294,967,295] range&lt;/td&gt;
&lt;td class="org-left"&gt;%lu&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;long long&lt;/code&gt; &lt;code&gt;long long int&lt;/code&gt; &lt;code&gt;signed long long&lt;/code&gt; &lt;code&gt;signed long long int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Long long signed integer type. Capable of containing at least the [−9,223,372,036,854,775,807, +9,223,372,036,854,775,807] range thus, it is at least 64 bits in size, specified since C99&lt;/td&gt;
&lt;td class="org-left"&gt;%lli%&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;unsigned long long&lt;/code&gt; &lt;code&gt;unsigned long long int&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Long long unsigned integer type. Contains at least the [0, +18,446,744,073,709,551,615] range, specified since C99&lt;/td&gt;
&lt;td class="org-left"&gt;%llu%&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
∗The negative value is −32767 (not −32768) due to the one's-complement and sign-magnitude representations allowed by the standard, though the two's-complement representation is much more common
&lt;/p&gt;

&lt;p&gt;
Since C99 there is a header file called &lt;code&gt;stdint.h&lt;/code&gt; which defines integers with a fixed bit size like/if(?) they're present on the current platform/system. For example:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int8_t&lt;/code&gt; and &lt;code&gt;uint8_t&lt;/code&gt; for signed and unsigned integers with &lt;i&gt;exactly&lt;/i&gt; 8 bit and therefore a cardinality of \(256\)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int16_t&lt;/code&gt; and &lt;code&gt;uint16_t&lt;/code&gt; for signed and unsigned integers with &lt;i&gt;exactly&lt;/i&gt; 16 bit and therefore a cardinality of \(65536\)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int32_t&lt;/code&gt; and &lt;code&gt;uint32_t&lt;/code&gt; for signed and unsigned integers with &lt;i&gt;exactly&lt;/i&gt; 32 bit and therefore a cardinality of \(4294967296\)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int64_t&lt;/code&gt; and &lt;code&gt;uint64_t&lt;/code&gt; for signed and unsigned integers with &lt;i&gt;exactly&lt;/i&gt; 64 bit and therefore a cardinality of \(18446744073709551616\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
PS. Cardinality means the number of (distinct) elements in a set
&lt;/p&gt;

&lt;p&gt;
C90 doesn't specify how a value "looks" in memory/storage meaning how it is exactly represented in bits. Nevertheless most platforms use a binary positional notation with two's complement for the representation of negative integers:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;unsigned: value \( = \sum_{i=1}^{n} b_i * 2^{i-1} \)&lt;/li&gt;
&lt;li&gt;signed: value  \( = \begin{cases} \sum_{i=1}^{n-1} b_i * 2^{i-1}, \text{wenn } b_n = 0 \\ (- \sum_{i=1}^{n-1} (1- b_i ) * 2^{i-1}) - 1, \text{wenn } b_n = 1  \end{cases}\)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
Now a bit onto "char"s. Why is the name of an integer type &lt;code&gt;char&lt;/code&gt;?
&lt;/p&gt;

&lt;p&gt;
Originally this type was meant to represent values in the range of &lt;b&gt;ASCII-Codes&lt;/b&gt; (7 bit) respective &lt;b&gt;ANSI-Codes&lt;/b&gt; (8 bit) → &lt;i&gt;character&lt;/i&gt;. C doesn't provide an explicit type for characters. The usage through &lt;code&gt;char&lt;/code&gt; is solely achieved through the interpretation of the integer when outputting.
&lt;/p&gt;

&lt;p&gt;
Depending on the platform the same &lt;code&gt;char&lt;/code&gt; value can represent different characters. That's why today the usage of &lt;code&gt;wchar_t&lt;/code&gt; is encouraged because it eases internalization and standardization (importable from &lt;code&gt;wchar.h&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
However in this lecture we will continue with ASCII/ANSI codes for now.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* char .c -- interpretation of char type */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nf"&gt;addchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Result is %c with the code %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
 &lt;span class="n"&gt;addchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
 &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Result is b with the code 98

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3f8a8f4" class="outline-3"&gt;
&lt;h3 id="org3f8a8f4"&gt;Rational numbers&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3f8a8f4"&gt;
&lt;p&gt;
Because of internal representation C can only represent rational numbers \(\mathbb{Q}\) and not generic reals \(\mathbb{R}\) (allgemeine reelle Zahlen). These numbers are commonly called &lt;i&gt;floating points numbers&lt;/i&gt;. C provides the following types to represent floating point numbers:
&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long double&lt;/code&gt;. Besides a limited codomain floats in C have a limited precision. Again there are no fixed sizes provided, but minimum ranges are guaranteed:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt; has a codomain of at least \(\pm 10^{\pm 37}\) and a precision of at least 6 decimal places (Nachkommastelle)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt; at least the codomain of &lt;code&gt;float&lt;/code&gt; and a precision of at least 10 decimal places&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long double&lt;/code&gt; at least as "good" as &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In practice almost all compilers follow the IEEE-754 standard that defines the binary representations of floats.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb0f5476" class="outline-3"&gt;
&lt;h3 id="orgb0f5476"&gt;Void&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb0f5476"&gt;
&lt;p&gt;
C knows the base type &lt;code&gt;void&lt;/code&gt;. &lt;code&gt;void&lt;/code&gt; is basically an "anti-type" because it is used when no type is wanted (→ empty set; leere Menge). Is helpful when parameters and/or return value are not needed.
&lt;/p&gt;

&lt;p&gt;
If the return value of a function is &lt;code&gt;void&lt;/code&gt; the &lt;code&gt;return&lt;/code&gt; statement in the function can be omitted. Is the parameter list of a function empty (&lt;code&gt;void&lt;/code&gt; is its sole element) than it can be omitted as well.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8738d0b" class="outline-2"&gt;
&lt;h2 id="org8738d0b"&gt;Type conversion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8738d0b"&gt;
&lt;p&gt;
The types in &lt;code&gt;a + b&lt;/code&gt; could be different for instance &lt;code&gt;unsigned char&lt;/code&gt; and &lt;code&gt;signed int&lt;/code&gt;. In those cases the types are automatically (implicit) converted. Generally all the data types of the variables are upgraded to the data type of the variable with largest data type.
&lt;/p&gt;

&lt;p&gt;
However besides the implicit automatic conversion, type conversion may be triggered manually and therefore explicitly by writing the type in parens before the variable/expression. Using a type like this, it acts as a &lt;i&gt;cast operator&lt;/i&gt; and is type casting the value. Doing this type conversion to lower data types is possible as well.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* cast .c -- type cast */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;,...);&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;ladd&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Ergebnis : %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ladd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// "(int)" type cast to int to get rid of warning and implicit conversion because of "%d" formatter&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;ladd&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
A type declaration like in C is not needed in all languages. In python for example the types are dynamic, that means they're determined at runtime. Python in contrast to C also offers strings and numbers with arbitrary size and precision (and more!).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3c89e93" class="outline-2"&gt;
&lt;h2 id="org3c89e93"&gt;Literals&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3c89e93"&gt;
&lt;p&gt;
A "direct value" of a specific type is called &lt;i&gt;literal&lt;/i&gt;. Literals of specific types require a special notation, to prevent an unneccessary type conversion:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; literals can be written in decimal, octal and hexadecimal and if needed with a sign:
&lt;ul class="org-ul"&gt;
&lt;li&gt;decimal: only digits &lt;code&gt;0-9&lt;/code&gt; however not leading with a &lt;code&gt;0&lt;/code&gt; → e.g &lt;code&gt;42&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;octal: prefix of &lt;code&gt;0&lt;/code&gt; and then only digits &lt;code&gt;0-7&lt;/code&gt; → e.g &lt;code&gt;052&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;hexadecimal: prefix of &lt;code&gt;0x&lt;/code&gt; and then only digits &lt;code&gt;0-9&lt;/code&gt; and letters &lt;code&gt;A-F&lt;/code&gt; → e.g &lt;code&gt;0x2a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int&lt;/code&gt; like int but with the suffix "u"/"U" → e.g &lt;code&gt;123U&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long/unsigned long&lt;/code&gt; like int/unsigned int but with the suffix "l"/"L" → e.g &lt;code&gt;123L&lt;/code&gt; respective &lt;code&gt;123UL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long long/unsigned long long&lt;/code&gt; like int/unsigned int but with the suffix "ll"/"LL" → e.g &lt;code&gt;123LL&lt;/code&gt; respective &lt;code&gt;123ULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt; as a decimal with decimal place(s), decimal point, and/or "e"/"E" with following exponent→ e.g &lt;code&gt;1.23e10&lt;/code&gt;, &lt;code&gt;.23&lt;/code&gt; or &lt;code&gt;1e10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt; like double but with the suffix "f"/"F" → e.g &lt;code&gt;1.23e10f&lt;/code&gt;, &lt;code&gt;.23f&lt;/code&gt; or &lt;code&gt;1e10f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long double&lt;/code&gt; like double but with the suffix "l"/"L" → e.g &lt;code&gt;1.23e10L&lt;/code&gt;, &lt;code&gt;.23l&lt;/code&gt; or &lt;code&gt;1e10l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt; literals have to be written in single quotes → e.g &lt;code&gt;'*'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wchar_t&lt;/code&gt; literals are written like &lt;code&gt;char&lt;/code&gt; with the prefix &lt;code&gt;L&lt;/code&gt; → e.g &lt;code&gt;L'a'&lt;/code&gt;. There also escape sequences to display sequences or characters that are difficult to represent else. &lt;a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences"&gt;Here's a list&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-05/</guid><pubDate>Sun, 21 Oct 2018 22:00:00 GMT</pubDate></item></channel></rss>