<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 12 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 12">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/">
<meta property="og:description" content="Bit Operators


In this lecture we started by covering bit operators. I've also written about those here. To keep it short (look at the link for more detailed explainations):


&amp; bitwise and
| bitwise">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-16T00:00:00+01:00">
<meta property="article:tag" content="A&amp;P">
<meta property="article:tag" content="university">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<div>
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right search-form" role="search">
    <input type="text" name="q" class="form-control search-input" placeholder="Search"><button type="submit" class="search-button">
      <i class="fa fa-search" aria-hidden="true"></i>
    </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>
</div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 12
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-11-16T00:00:00+01:00">2018/11/16</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../../categories/ap/" rel="tag">A&amp;P</a>
	    </div>
	    <div class="tag">
	      <a href="../../../categories/university/" rel="tag">university</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-org9e75314" class="outline-2">
<h2 id="org9e75314">Bit Operators</h2>
<div class="outline-text-2" id="text-org9e75314">
<p>
In this lecture we started by covering bit operators. I've also written about those <a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-03/">here</a>. To keep it short (look at the link for more detailed explainations):
</p>
<ul class="org-ul">
<li>
<code>&amp;</code> bitwise <b>and</b>
</li>
<li>
<code>|</code> bitwise <b>or</b>
</li>
<li>
<code>~</code> bitwise <b>not</b>
</li>
<li>
<code>^</code> bitwise <b>xor</b>
</li>
</ul>
<p>
<img src="../../../images/bitwise-op.png" alt="nil"></p>

<p>
Then there are the bitshift operators as well:
</p>
<ul class="org-ul">
<li>
<code>8 &lt;&lt; n</code> leftshift which is like multiplication with 2<sup>n</sup>
</li>
<li>
<code>8 &gt;&gt; n</code> rightshift which is like division with 2<sup>n</sup>
</li>
</ul>
<p>
There are more operators in C. Some of them offer a shorter/more concise notation. The lecturer calls them "Faulheitsoperatoren" (lazy operators) I don't like that term because it can get mixed with "lazy evaluation" (which is called short circuit evaluatoin to be precise) rather easily. So I'll now just go over the operators we covered in the lecture next.
</p>
</div>
</div>

<div id="outline-container-org2bceece" class="outline-2">
<h2 id="org2bceece">Comma Operator</h2>
<div class="outline-text-2" id="text-org2bceece">
<p>
The wikipedia page on this operator is very well written, I have copied the valuable information to here:
</p>

<p>
In the C and C++ programming languages, the comma operator (represented by the token <code>,</code>) is a <b>binary operator</b> that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).
</p>

<p>
The use of the comma token as an operator is distinct from its use in function calls and definitions, variable declarations, enum declarations, and similar constructs, where it acts as a separator.
</p>

<p>
The comma operator separates expressions (which have value) in a way analogous to how the semicolon terminates statements, and sequences of expressions are enclosed in parentheses analogously to how sequences of statements are enclosed in braces: <code>(a, b, c)</code> is a sequence of expressions, separated by commas, which evaluates to the last expression <code>c</code> while <code>{a; b; c;}</code> is a sequence of statements, and does not evaluate to any value. A comma can only occur between two expressions – commas separate expressions – unlike the semicolon, which occurs at the end of a (non-block) statement – semicolons terminate statements.
</p>

<p>
The comma operator has the lowest precedence of any C operator, and acts as a sequence point. In a combination of commas and semicolons, semicolons have lower precedence than commas, as semicolons separate statements but commas occur within statements, which accords with their use as ordinary punctuation: <code>a, b; c, d</code> is grouped as <code>(a, b); (c, d)</code> because these are two separate statements.
</p>

<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> *  Commas act as separators in this line, not as an operator.</span>
<span class="cm"> *  Results: a=1, b=2, c=3, i=0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  Assigns value of b into i.</span>
<span class="cm"> *  Results: a=1, b=2, c=3, i=2</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>              
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// parens are required here because '=' has higher precedence than ',' it would get treated as (int i = a), (int b); without the parens which would be a redeclaration of b with no linkage          </span>

<span class="cm">/**</span>
<span class="cm"> *  Assigns value of a into i. Equivalent to (i = a), b;</span>
<span class="cm"> *  Results: a=1, b=2, c=3, i=1</span>
<span class="cm"> *  (The curly braces on the second line are needed to</span>
<span class="cm"> *   avoid a compiler error.  The second 'b' declared</span>
<span class="cm"> *   is given no initial value.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>                                
<span class="p">{</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Increases value of a by 2, then assigns value of resulting operation a+b into i .</span>
<span class="cm"> *  Results: a=3, b=2, c=3, i=5</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  Increases value of a by 2, then stores value of a to i, and discards unused</span>
<span class="cm"> *  values of resulting operation a + b . Equivalent to (i = (a += 2)), a + b; </span>
<span class="cm"> *  Results: a=3, b=2, c=3, i=3</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  Assigns value of a into i;  the following 'b' and 'c'</span>
<span class="cm"> *  are not part of the initializer but declarators for</span>
<span class="cm"> *  second instances of those variables.</span>
<span class="cm"> *  Results: a=1, b=2, c=3, i=1</span>
<span class="cm"> *  (The curly braces on the second line are needed to</span>
<span class="cm"> *   avoid a compiler error.  The second 'b' and second</span>
<span class="cm"> *   'c' declared are given no initial value.)</span>
<span class="cm"> */</span>     
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="p">{</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Assigns value of c into i, discarding the unused a and b values.</span>
<span class="cm"> *  Results: a=1, b=2, c=3, i=3</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  Returns 6, not 4, since comma operator sequence points following the keyword </span>
<span class="cm"> *  'return' are considered a single expression evaluating to rvalue of final </span>
<span class="cm"> *  subexpression c=6 .</span>
<span class="cm"> */</span>
<span class="k">return</span> <span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  Returns 3, not 1, for same reason as previous example, that is return expressions must be fully evaluated before the function can return.</span>
<span class="cm"> */</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  Returns 3, not 1, still for same reason as above. This example works as it does</span>
<span class="cm"> *  because return is a keyword, not a function call. Even though compilers will </span>
<span class="cm"> *  allow for the construct return(value), the parentheses are only relative to "value"</span>
<span class="cm"> *  and have no special effect on the return keyword.</span>
<span class="cm"> *  Return simply gets an expression and here the expression is "(1), 2, 3".</span>
<span class="cm"> */</span>
<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>

<p>
<b>Use cases</b>: The comma operator has relatively limited use cases. Because it discards its first operand, it is generally only useful where the first operand has desirable side effects. Further, because it is rarely used outside of specific idioms, and easily mistaken with other commas or the semicolon, it is potentially confusing and error-prone. Nevertheless, there are certain circumstances where it is commonly used, notably in for loops and in SFINAE. For embedded systems which may have limited debugging capabilities, the comma operator can be used in combination with a macro to seamlessly override a function call, to insert code just before the function call.
</p>

<p>
<i>For Loops</i>:
</p>

<p>
The most common use is to allow multiple assignment statements without using a block statement, primarily in the initialization and the increment expressions of a for loop. This is the only idiomatic use in elementary C programming. In the following example, the order of the loop's initializers is significant:
</p>
<div class="highlight"><pre><span></span><span class="c1">// reverse print char array</span>
<span class="kt">void</span> <span class="nf">rev</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">first</span><span class="p">;</span> <span class="o">--</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">putchar</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>
Outside of for loop initializers (which have a special use of semicolons), the comma might be used synonymously with the semicolon, particularly when the statements in question function similarly to a loop increment (e.g. at the end of a while loop):
</p>
<div class="highlight"><pre><span></span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="o">++</span><span class="n">q</span><span class="p">;</span>

<span class="o">++</span><span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">;</span> <span class="c1">// Two statements on one line</span>
</pre></div>
<p>
However, as this usage achieves the same thing as the semicolon in a visually different way, this is of dubious usefulness and might confuse readers.
</p>

<p>
<i>Condition</i>:
</p>

<p>
The comma can be used within a condition (of an if, while, do while, or for) to allow auxiliary computations, particularly calling a function and using the result, with block scoping:
</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// statements involving x and y</span>
<span class="p">}</span>
</pre></div>

<p>
<i>Complex return</i>:
The comma can be used in return statements, to assign to a global variable or out parameter (passed by reference). This idiom suggests that the assignments are part of the return, rather than auxiliary assignments in a block that terminates with the actual return. For example, in setting a global error number:
</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
<p>
This can be written more verbosely as:
</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
<i>Avoid a block</i>:
For brevity, the comma can be used to avoid a block and associated braces, as in:
</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
<p>
instead of:
</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div id="outline-container-org9b592ea" class="outline-2">
<h2 id="org9b592ea">Increment and Decrement Operator</h2>
<div class="outline-text-2" id="text-org9b592ea">
<p>
Next up are <code>++</code> increment and <code>--</code> decrement operators which are unary operators that add or subtract one, to or from their operand. C like languages offer two versions (pre and post) of each operator with slighltly different semantics. Now guess what I've also written a bit about them <a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/">here</a> xD but that was a bit superficial so we'll repeat now.
</p>

<p>
The increment operator increases, and the decrement operator decreases, the value of its operand by 1. The operand must have an arithmetic or pointer data type, and must refer to a modifiable data object. Pointers values are increased (or decreased) by an amount that makes them point to the next (or previous) element adjacent in memory → so eg incrementing a pointer via <code>++</code> will increment it to point to the next element which would really be an incrementation of 8 when the base handled base type is a char for example.
</p>

<p>
The <b>pre-increment</b> and <b>pre-decrement</b> operators increment (or decrement) their operand by 1, and the value of the expression is the resulting incremented (or decremented) value.
</p>

<p>
The <b>post-increment</b> and <b>post-decrement</b> operators increase (or decrease) the value of their operand by 1, but the value of the expression is the operand's original value prior to the increment (or decrement) operation.
</p>

<p>
Since the increment/decrement operator modifies its operand, use of such an operand more than once within the same expression can produce undefined results. For example, in expressions such as <code>x - ++x</code>, it is not clear in what sequence the subtraction and increment operations should be performed. Such expressions generally invoke undefined behavior, and should be avoided.
</p>

<p>
This example visualizes the difference between the post and prefix operators:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span>  <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span>  <span class="n">y</span><span class="p">;</span>

<span class="c1">// Increment operators</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span>    <span class="c1">// x is now 2, y is also 2</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">++</span><span class="p">;</span>    <span class="c1">// x is now 3, y is 2</span>

<span class="c1">// Decrement operators</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">--</span><span class="p">;</span>    <span class="c1">// x is now 2, y is 3</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">--</span><span class="n">x</span><span class="p">;</span>    <span class="c1">// x is now 1, y is also 1</span>
</pre></div>

<p>
If these shorthand operators are just used for their side effect (which is de-/in-crementing the variable for example in the third for loop statement) then it does not matter which variant post or pre is used.
</p>

<p>
Easy peazy my friend :D 
</p>
</div>
</div>

<div id="outline-container-org72e4534" class="outline-2">
<h2 id="org72e4534">Compound Assignment Operators</h2>
<div class="outline-text-2" id="text-org72e4534">
<p>
The next type of operators we cover are called <b>compound assignment operators</b> ('Selbstzuweisungsoperatoren' in script). The following table visualizes their effects:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-left">Operator name</th>
<th scope="col" class="org-left">Syntax</th>
<th scope="col" class="org-left">Meaning</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Addition assignment</td>
<td class="org-left"><code>a += b</code></td>
<td class="org-left"><code>a = a + b</code></td>
</tr>
<tr>
<td class="org-left">Subtraction assignment</td>
<td class="org-left"><code>a -= b</code></td>
<td class="org-left"><code>a = a - b</code></td>
</tr>
<tr>
<td class="org-left">Multiplication assignment</td>
<td class="org-left"><code>a *= b</code></td>
<td class="org-left"><code>a = a * b</code></td>
</tr>
<tr>
<td class="org-left">Division assignment</td>
<td class="org-left"><code>a /= b</code></td>
<td class="org-left"><code>a = a / b</code></td>
</tr>
<tr>
<td class="org-left">Modulo assignment</td>
<td class="org-left"><code>a %= b</code></td>
<td class="org-left"><code>a = a % b</code></td>
</tr>
<tr>
<td class="org-left">Bitwise AND assignment</td>
<td class="org-left"><code>a &amp;= b</code></td>
<td class="org-left"><code>a = a &amp; b</code></td>
</tr>
<tr>
<td class="org-left">Bitwise OR assignment</td>
<td class="org-left"><code>a ❘= b</code></td>
<td class="org-left"><code>a = a ❘ b</code></td>
</tr>
<tr>
<td class="org-left">Bitwise XOR assignment</td>
<td class="org-left"><code>a ^= b</code></td>
<td class="org-left"><code>a = a ^ b</code></td>
</tr>
<tr>
<td class="org-left">Bitwise leftshift assignment</td>
<td class="org-left"><code>a &lt;&lt;= b</code></td>
<td class="org-left"><code>a = a &lt;&lt; b</code></td>
</tr>
<tr>
<td class="org-left">Bitwise rightshift assignment</td>
<td class="org-left"><code>a &gt;&gt;= b</code></td>
<td class="org-left"><code>a = a &gt;&gt; b</code></td>
</tr>
</tbody>
</table>
<p>
Be careful, while <code>+=</code> and <code>-=</code> are somewhat common to see, the others might be confusing and it is okay to not use them as much.
</p>
</div>
</div>

<div id="outline-container-orgbfaa6b9" class="outline-2">
<h2 id="orgbfaa6b9">Operator Precedence and Associativity</h2>
<div class="outline-text-2" id="text-orgbfaa6b9">
<p>
When multiple operators are used in an expression, the evaluation order depends on the <i>precedence</i> and / associativity/ of the operators.
</p>

<p>
The <b>order of operations</b> (or <b>operator precedence</b>) is a collection of rules that reflect conventions about which procedures to perform first in order to evaluate a given mathematical expression.
</p>

<p>
For example, in mathematics and most computer languages, multiplication is granted a higher precedence than addition, and it has been this way since the introduction of modern algebraic notation. Thus, the expression <code>2 + 3 × 4</code> is interpreted to have the value <code>2 + (3 × 4) = 14</code>
</p>

<p>
Skript: Operatoren mit höherer Priorität werden zuerst ausgewertet
</p>


<p>
The <b>associativity</b> of an operator is a property that determines how operators of the same precedence are grouped in the absence of parentheses. If an operand is both preceded and followed by operators, and those operators have equal precedence, then the operand may be used as input to two different operations (i.e. the two operations indicated by the two operators). The choice of which operations to apply the operand to, is determined by the <i>"associativity"</i> of the operators.
</p>

<p>
Operators may be <b>associative</b> (meaning the operations can be grouped arbitrarily), <b>left-associative</b> (meaning the operations are grouped from the left), <b>right-associative</b> (meaning the operations are grouped from the right) or <b>non-associative</b> (meaning operations cannot be chained, often because the output type is incompatible with the input types).
</p>

<p>
The associativity and precedence of an operator is a part of the definition of the programming language; different programming languages may have different associativity and precedence for the same type of operator.
</p>

<p>
Consider the expression <code>a ~ b ~ c</code>. If the operator <code>~</code> has left associativity, this expression would be interpreted as <code>(a ~ b) ~ c</code>. If the operator has right associativity, the expression would be interpreted as <code>a ~ (b ~ c)</code>. If the operator is non-associative, the expression might be a syntax error, or it might have some special meaning. 
</p>

<p>
Some mathematical operators have inherent associativity. For example, subtraction and division, as used in conventional math notation, are inherently left-associative. Addition and multiplication, by contrast, are both left and right associative eg <code>(a * b) * c = a * (b * c))</code>.
</p>

<p>
Skript: Assoziativität bestimmt die Richtung der Auswertung
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C++#Compound_assignment_operators">Wiki C Precedence / Associativity Table</a>
</p>

<p>
Table and notes below from <a href="https://en.cppreference.com/w/c/language/operator_precedence">cppreference.com</a>
</p>

<p>
<img src="../../../images/c-table.png" alt="nil"></p>

<p>
When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression <code>*p++</code> is parsed as <code>*(p++)</code>, and not as <code>(*p)++</code>.
</p>

<p>
Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression <code>a=b=c</code> is parsed as <code>a=(b=c)</code>, and not as <code>(a=b)=c</code> because of <i>right-to-left associativity</i>.
</p>

<p>
Precedence and associativity are independent from order of evaluation.
</p>

<p>
The C language standard doesn't specify operator precedence. It specifies the language grammar, and the precedence table is derived from it to simplify understanding. There is a part of the grammar that cannot be represented by a precedence table: an assignment-expression is not allowed as the right hand operand of a conditional operator, so <code>e = a &lt; d ? a++ : a = d</code> is an expression that cannot be parsed, and therefore relative precedence of conditional and assignment operators cannot be described easily.
</p>

<p>
However, many C compilers use non-standard expression grammar where <code>?:</code> is designated higher precedence than <code>=</code>, which parses that expression as <code>e = ( ((a &lt; d) ? (a++) : a) = d )</code>, which then fails to compile due to semantic constraints: <code>?:</code> is never lvalue and <code>=</code> requires a modifiable lvalue on the left. This is the table presented on this page.
</p>

<p>
Note that this is different in C++, where the conditional operator has the same precedence as assignment.
</p>

<p>
Associativity specification is redundant for unary operators and is only shown for completeness: <i>unary prefix</i> operators always associate right-to-left eg <code>sizeof ++*p</code> is
 <code>sizeof(++(*p))</code> and <i>unary postfix</i> operators always associate left-to-right
 eg <code>a[1][2]++</code> is <code>((a[1])[2])++</code>
</p>

<p>
Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: <code>a.b++</code> is parsed <code>(a.b)++</code> and not <code>a.(b++)</code>.
</p>

<p>
Remeber when in doubt use parentheses as it improves readability as well!
</p>
</div>
</div>

<div id="outline-container-orgae52c08" class="outline-2">
<h2 id="orgae52c08">Abstract Machines (Automaten)</h2>
<div class="outline-text-2" id="text-orgae52c08">
<p>
The next part of the chapter dealt with abstract machines. The slides are hard to convert to a blog format and it did not seem to be important for the course so I'll just skip over some stuff here. You should still take a look <a href="https://osg.informatik.tu-chemnitz.de/lehre/aup/aup-06-Logik-handout_de.pdf">here</a> (lecture slides 06: slide 40).
</p>

<p>
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types – deterministic finite state machines and non-deterministic finite state machines. A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.
</p>

<p>
Slides: Ein endlicher (deterministischer) Automat (EA, Zustandsmaschine, finite state machine ➡ FSM, auch: finite state automata) ist ein Modell zur Beschreibung von Abläufen (z.B. in Computern). Ein EA besteht aus einer Menge von <i>Zuständen</i> S (states) und <i>Zustandsübergängen</i> T : S × Γ → S (Transitionen, transitions). Ein EA startet in einem <i>Startzustand</i>. Er „verarbeitet“ eine Sequenz von <i>Zeichen</i> oder <i>Ereignissen</i> Γ. Dabei bestimmt das nächste Zeichen/Ereignis, in welchen Zustand der EA wechselt. Ein EA kann einen oder mehrere <i>Endzustände</i> (accepting states) besitzen. Wird ein solcher Zustand erreicht, ist die Abarbeitung beendet.
</p>

<p>
Transitions (Zustandsveränderungen) in a state machine (endlichem Automaten) can lead to <i>actions</i> or <i>output</i>.
Transducers (Transduktor, ein spezieller endlicher Automat der im Ggsatz zu einem Akzeptor eine Ausgabe erzeugt, überführt/übersetzt eine Quellsprache in eine Zielsprache) generate output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.
</p>

<p>
In control applications, two types are distinguished:
</p>

<p>
<b>Moore machine</b>:
</p>

<p>
The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: "command<sub>open</sub>" and "command<sub>close</sub>", which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: "door is open" or "door is closed". Slides: Aktion/Ausgabe ist an die Ankunft in einem bestimmten Zustand gebunden
</p>

<p>
<img src="../../../images/moore.png" alt="nil"></p>


<p>
<b>Mealy machine</b>:
</p>

<p>
The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in the picture below shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): "start motor to close the door if command<sub>close</sub> arrives" and "start motor in the other direction to open the door if command<sub>open</sub> arrives". The "opening" and "closing" intermediate states are not shown. Slides: Aktion/Ausgabe ist an einen bestimmten Übergang gebunden
</p>

<p>
<img src="../../../images/mealy.png" alt="nil"></p>



<p>
Finite state machines are closely related to regular grammars because to every regular grammar there exists at least one FSM which accepts all expressions of that language (slides: Jede Folge von zulässigen Eingabesymbolen bzw. -ereignissen, die in einen Endzustand führen, entspricht einer formalen Sprache, die durch eine reguläre Grammatik beschrieben werden kann).
</p>

<p>
However a FSM is not sufficient for context free languages.
</p>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="knowledge-database",
            disqus_url="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-12/",
        disqus_title="Algos & Programming - Lecture 12",
        disqus_identifier="cache/posts/algos_and_programming/12-lecture.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
