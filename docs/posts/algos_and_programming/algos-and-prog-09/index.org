#+BEGIN_COMMENT
.. title: Algos & Programming - Lecture 09
.. slug: algos-and-prog-09
.. date: 2018-11-05
.. tags: university, A&P 
.. category: 
.. link: 
.. description: 
.. type: text
.. has_math: true
#+END_COMMENT

* Complex Types in Python
There are built-in types in Python which offer similar functionality to the complex types in C and more.
** Python Strings
Strings are character sequences of a fixed length and are to be precise *not* a complex type (why?).
String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).

Python strings are "immutable" which means they cannot be changed after they are created. Since strings can't be changed, we construct *new* strings as we go to represent computed values. So for example the expression ='hello' + 'there'= takes in the 2 strings ='hello'= and ='there'= and builds a new string ~'hellothere'~. The resulting string has a different =id()= because a new object is created and the others may then be garbage collected.

Python string also recognize escape sequences similarly to C for example ='\n'=  is recognized as a ASCII Linefeed. To prevent parsing of those one may use a /raw string/ by prepending and =r= or =R= to the string:
#+BEGIN_SRC python :results output print :exports both
print("H\ni")
print(r"H\ni")

a = "Hello"
print("Id of " + a + " " + str((id(a))))
a += " World"
print("Id of " + a + " " + str((id(a))))
#+END_SRC

#+RESULTS:
: H
: i
: H\ni
: Id of Hello 139710321381872
: Id of Hello World 139710321440048

Individual characters of a string can be accessed via =[]= bracket notation.
** Python Lists
Python has a great built-in list type named "list". List literals are written within square brackets ~[ ]~. Lists work similarly to strings - use the =len()= function and square brackets [ ] to access data, with the first element at index =0=. To access elements from the back use negative indices.

#+BEGIN_SRC python :results output print :export both
colors = ['red', 'blue', 'green']
print(id(colors))
print(id(colors[0]))

test = 'red'
print(id(test))


print(id(colors[1]))
print(id('blue'))
#+END_SRC

#+RESULTS:
: 140440210583432
: 140440209179064
: 140440209179064
: 140440209179120
: 140440209179120

Assignment with an ~=~ on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.

The "empty list" is just an empty pair of brackets ~[ ]~. The =+= works to append two lists, so =[1, 2] + [3, 4]= yields =[1, 2, 3, 4]= (this is just like =+= with strings).

Lists in Python can (in contrast to arrays in C) hold values of different types.

Python lists are also /mutable/. In fact there are a lot of /methods/ to modify lists eg =append=, =insert=, =remove=, =pop=.
** Python Tuples
Tuples in Python are similar to lists with the difference that they are *immutable*.

A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.

Creating a tuple is as simple as putting different comma-separated values. Optionally you can put these comma-separated values between parentheses also. For example:
#+BEGIN_SRC python
tup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = "a", "b", "c", "d"
#+END_SRC

The empty tuple is written as two parens containing nothing ~tup1 = ()~. To write a tuple containing a single value you have to include a comma, even though there is only one value ~(77,)~

Like string indices, tuple indices start at 0, and they can be sliced, concatenated, and so on.

However if tuples are eg concatenated via =+= a new tuple is created:
#+BEGIN_SRC python :results output print :exports both
T = (1,2)
print("tuple: ", T, "with id: ", id(T))
T += (3,4)
print("tuple: ", T, "with id: ", id(T))
#+END_SRC

#+RESULTS:
: tuple:  (1, 2) with id:  140056518200328
: tuple:  (1, 2, 3, 4) with id:  140056518172568

** Python Sets
Since Python 2.6 there are set types (Mengentypen). 
A Set in Python is a data structure equivalent to sets in mathematics. It may consist of various elements; the order of elements in a set is undefined. You can add and delete elements of a set, you can iterate the elements of the set, you can perform standard operations on sets (union, intersection, difference). Besides that, you can check if an element belongs to a set.

Unlike arrays, where the elements are stored as ordered list, the order of elements in a set is undefined (moreover, the set elements are usually not stored in order of appearance in the set; this allows checking if an element belongs to a set faster than just going through all the elements of the set).

Any immutable data type can be an element of a set: a number, a string, a tuple. Mutable (changeable) data types cannot be elements of the set. In particular, lists cannot be an element of a set (but tuple can), and another set cannot be an element of a set. The requirement of immutability follows from the way how do computers represent sets in memory.

Sets unlike lists or tuples can't have multiple occurrences of the same element \rightarrow ~set('a','b','c','a','b','c')~ \rightarrow ~{'a','b','c'}~ no values are duplicated.

To create a set the =set()= is called which constructs a Python set from the given iterable and returns it.

#+BEGIN_SRC python :results output print :exports both
# empty set
print(set())

# from string
print(set('Python'))

# from tuple
print(set(('a', 'e', 'i', 'o', 'u')))

# from list
print(set(['a', 'e', 'i', 'o', 'u']))

# from range
print(set(range(5)))
#+END_SRC

#+RESULTS:
: set()
: {'t', 'y', 'h', 'o', 'n', 'P'}
: {'e', 'u', 'o', 'a', 'i'}
: {'e', 'u', 'o', 'a', 'i'}
: {0, 1, 2, 3, 4}

Sets are implemented in a way, which doesn't allow mutable objects. The following example demonstrates that we cannot include, for example, lists as elements:
#+BEGIN_SRC python
cities = set((("Python","Perl"), ("Paris", "Berlin", "London"))) # valid set of tuples

cities = set((["Python","Perl"], ["Paris", "Berlin", "London"])) # -> TypeError: unhashable type: 'list'
#+END_SRC

Although sets can't contain mutable objects, sets are mutable themselves. Elements may for example added via the =add= method (=cities.add("Tokyo")=).

Frozensets are like sets except that they cannot be changed so they are immutable:
#+BEGIN_SRC python
cities = frozenset(["Frankfurt", "Basel","Freiburg"])
cities.add("Strasbourg") # AttributeError: 'frozenset' object  has no attribute 'add'
#+END_SRC

There's also a simplified shorter notation to construct sets:
#+BEGIN_SRC python :exports both :results output print
cities = {"London", "Paris", "Madrid"}
print(type(cities))
#+END_SRC

#+RESULTS:
: <class 'set'>

The known operations from set theory are also available via Python Sets (following part in German xD):
- =len(s)= gibt MÃ¤chtigkeit der Menge =s=
- =s1 | s2= gibt Vereinigungsmenge von =s1= und =s1=
- =s1 & s2= gibt Schnittmenge von =s1= und =s1=
- =s1 - s2= gibt Differenzmenge von =s1= und =s1=
- =s1 ^ s2= gibt symmetrische Differenzmenge von =s1= und =s1=

** Python Dictionaries
A dictionary is a collection which is unordered, changeable (mutable) and indexed. In Python dictionaries are written with curly brackets, and they have keys and values.
#+BEGIN_SRC python :exports both :results output print
thisdict =	{
  "key": "value",
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict)
#+END_SRC

You can access the items of a dictionary by referring to its key name, inside square brackets:
#+BEGIN_SRC python :exports both :results output print 
thisdict =	{
  "key": "value",
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict["key"])
print(thisdict["model"])
print(thisdict["year"])
#+END_SRC

#+RESULTS:
: value
: Mustang
: 1964

More on dictionaries and how to work with them / their methods [[https://www.w3schools.com/python/python_dictionaries.asp][here]]

* Loops and Iterations
In C there are three types of loops:
- while loop
- do while loop
- for loop
  
All of these loops use conditions are able to simulate one another. Which one to use is often a matter of personal taste.

** While Loop
The while loop executes as long as a conditions is true resp. until a condition is false. This is the procedure:
1. Check if condition =while (expression/Condition)= evaluates to true (nonzero)
2. If yes: execute body of the loop and jump to 1.
3. If no: resume program execution after the loop

#+BEGIN_SRC C :results output print :exports both
// Program to find factorial of a number
// For a positive integer n, factorial = 1*2*3...n

#include <stdio.h>
int main()
{
    int number;
    long long factorial;

    // printf("Enter an integer: ");
    // scanf("%d",&number); // cannot read from stdio in my blog :)
    number = 5;

    factorial = 1;

    // loop terminates when number is less than or equal to 0
    while (number > 0)
    {
        factorial *= number;  // factorial = factorial*number;
        number--;

        // alternatively: factorial *= number--;
    }

    printf("Factorial= %lld", factorial);

    return 0;
}
#+END_SRC

#+RESULTS:
: Factorial= 120

Loops can be used to fill fields of an array:
#+BEGIN_SRC C :results output print :exports both
  #include <stdio.h>
  enum { arraySize = 12 }; // constant for array size

  int main()
  {
    int arr[arraySize], i = 0;

    while (i < arraySize) { // 0,1,2...11
      arr[i] = i*i;
      i++;
    }

    i = 0;
    while (i < arraySize) { // 0,1,2...11
      printf("Element %d of arr: %d\n", i, arr[i]);
      i++;
    }

    return 0;
  }
#+END_SRC

#+RESULTS:
#+begin_example
Element 0 of arr: 0
Element 1 of arr: 1
Element 2 of arr: 4
Element 3 of arr: 9
Element 4 of arr: 16
Element 5 of arr: 25
Element 6 of arr: 36
Element 7 of arr: 49
Element 8 of arr: 64
Element 9 of arr: 81
Element 10 of arr: 100
Element 11 of arr: 121
#+end_example
** Do While Loop
The do while loop is similar to the while loop with the difference being that the do while loop checks the condition *after* it has run, therefore it always runs at least one time.
The syntax is
#+BEGIN_SRC C
do {
  statement(s);
} while (expression/condition); // notice the semicolon!
#+END_SRC
** For Loop
A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.
#+BEGIN_SRC C
for (init; condition; mutation(eg increment/decrement)) { // "conditon" and "mutation" are expressions (see C standard) but that is how they're used commonly
  statement(s);
}
#+END_SRC
Here is the flow of control in a 'for' loop :
- the init step is executed first, and only once
  - this step allows you to declare and initialize any loop control variables
  - you are not required to put a statement here, as long as a semicolon appears
- next, the condition is evaluated
  - if it is true, the body of the loop is executed
  - if it is false, the body of the loop does not execute and the flow of control jumps to the next statement just after the 'for' loop
- after the body of the 'for' loop executes, the flow of control jumps back up to the mutation statement
 - this statement allows you to update any loop control variables
 - This statement can be left blank, as long as a semicolon appears after the condition
- the condition is now evaluated again 
  - if it is true, the loop executes and the process repeats itself (body of loop, then mutation step, and then again condition)
  - after the condition becomes false, the 'for' loop terminates

Omitting expressions:
#+BEGIN_SRC C
  #include <stdio.h>

  int main(int argc, char* argv[])
  {
    int i = 0;
    for (; i < argc; i++) // omitting initalization
      printf("%d. argument: %s\n", i+1, argv[i]);


    for (;;) // endless loop
      printf("The answer is 42\n"); 


    return 0; // never reached
  }

#+END_SRC

Dont forget it is possible to have more complex conditions and multiple assignments!
#+BEGIN_SRC C :exports both :results output print
  #include <stdio.h>

  int main()
  {
    for (int i=2, j=1; i<3 || j<5; i++,j++)
      {
        printf("%d, %d\n",i ,j);
      }
    return 0;
  }
#+END_SRC

#+RESULTS:
: 2, 1
: 3, 2
: 4, 3
: 5, 4

** =break= and =continue=
