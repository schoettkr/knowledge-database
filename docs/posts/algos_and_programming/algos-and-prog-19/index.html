<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 19 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-19/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 19">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-19/">
<meta property="og:description" content="This lecture directly builds on lecture 18 so make sure to be in the picture about what we did there.


Text Search


In lecture 18 we ended with the pseudocode implementation of our search algorithm ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-12-10T00:00:00+01:00">
<meta property="article:tag" content="A&amp;P">
<meta property="article:tag" content="university">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right" role="search">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search">
</div>
  <button type="submit" class="btn btn-primary">
    <span class="glyphicon glyphicon-search"></span>
  </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 19
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-12-10T00:00:00+01:00">2018/12/10</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../../categories/ap/" rel="tag">A&amp;P</a>
	    </div>
	    <div class="tag">
	      <a href="../../../categories/university/" rel="tag">university</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <p>
This lecture directly builds on lecture 18 so make sure to be in the picture about what we did there.
</p>
<div id="outline-container-orgf863f0a" class="outline-2">
<h2 id="orgf863f0a">Text Search</h2>
<div class="outline-text-2" id="text-orgf863f0a">
<p>
In lecture 18 we ended with the pseudocode implementation of our search algorithm and now we want to implement it in C. As a refresher here's the pseudocode once again:
</p>
<div class="highlight"><pre><span></span><span class="c1">// str is file/text buffer and p is search string</span>
<span class="nl">Require</span><span class="p">:</span> <span class="n">str</span> <span class="n">and</span> <span class="n">p</span> <span class="n">is</span> <span class="n">text</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="nl">Ensure</span><span class="p">:</span> <span class="n">returns</span> <span class="n">index</span> <span class="n">of</span> <span class="n">first</span> <span class="n">appearance</span> <span class="n">of</span> <span class="n">p</span> <span class="n">in</span> <span class="n">str</span>

<span class="n">procedure</span> <span class="n">SIMPLE</span><span class="o">-</span><span class="n">SEARCH</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="n">and</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">j</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">then</span> <span class="c1">// found 1st occ of search string</span>
	<span class="k">return</span> <span class="n">pos</span>
      <span class="n">endif</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">end</span> <span class="k">while</span>
  <span class="k">return</span> <span class="s">"not found"</span>
<span class="n">end</span> <span class="n">procedure</span>
</pre></div>

<p>
As you can see in the line <code>if j = length(p) then ...</code>  we also need a function that determines the length of a string. There's one in the standard library but we'll write our own (same as for the <code>presentResult</code> function in lecture 18!):
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">len</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
Now the algorithm in C looks pretty similar to the pseudocode however we have to account for the fact that indices begin at 0 and also do some condition checking:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">search</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">tlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="n">tlen</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// abort if search string is longer than text</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">tlen</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// iterate over chars in text</span>
    <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span> <span class="c1">// increment j as long as chars in the search string and text match</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">plen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// when j is equal to plen - 1 all characters matched</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span> <span class="c1">//found the string (1st occurence)</span>
      <span class="p">}</span>

      <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>
Let's examine the above implementation/algorithm:
</p>
<ul class="org-ul">
<li>we have two nested loops
<ul class="org-ul">
<li>the outer loop runs through all \(n\) elements in our text <code>str</code>
</li>
<li>the inner loop runs through \(m\) elements in the search string <code>p</code>
</li>
<li>our upper boundary is therefore \(\mathcal{O} (m*n)\)</li>
<li>the lower boundary is \(\mathcal{O} (m)\) (text begins with searchstring)</li>
</ul>
</li>
</ul>
<p>
Let's look at more efficient approaches!
</p>
</div>

<div id="outline-container-orgf0af9dd" class="outline-4">
<h4 id="orgf0af9dd">Boyer-Moore Algorithm</h4>
<div class="outline-text-4" id="text-orgf0af9dd">
<p>
Wikipedia: The Boyer–Moore string-search algorithm is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature. It was developed by Robert S. Boyer and J Strother Moore in 1977.
</p>

<p>
The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches.
</p>

<p>
The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string search algorithms. In general, the algorithm runs faster as the pattern length increases. 
</p>

<p>
The key features of the algorithm are to <b>match on the tail of the pattern</b> rather than the head, and to <i>skip along the text in jumps of multiple characters</i> rather than searching every single character in the text.
</p>

<p>
The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text. If the characters do not match, there is no need to continue searching backwards along the text. If the character in the text <i>does not match</i> <b>any</b> <i>of the characters in the pattern</i>, then the next character in the text to check is located <code>n</code> characters farther along the text, where <code>n</code> is the length of the pattern. 
</p>

<p>
If the character in the text <b>is</b> in the pattern, then a <b>partial shift</b> of the pattern along the text is done <i>to line up along the matching character</i> and the process is repeated. Jumping along the text to make comparisons rather than checking every character in the text decreases the number of comparisons that have to be made, which is the key to the efficiency of the algorithm.
</p>

<p>
A shift is calculated by applying two rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.
</p>
</div>

<ul class="org-ul">
<li>
<a id="org4701525"></a>They Bad Character Rule (T=Text, P=Pattern)<br><div class="outline-text-5" id="text-org4701525">
<p>
The bad-character rule considers the character in <code>T</code> at which the comparison process failed (assuming such a failure occurred). The next occurrence of that character to the left in <code>P</code> is found, and a shift which brings that occurrence in line with the mismatched occurrence in <code>T</code> is proposed. If the mismatched character does not occur to the left in <code>P</code>, a shift is proposed that moves the entirety of <code>P</code> past the point of mismatch
</p>

<p>
For the Good Suffix Rule you should study the wikipedia section <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_Good_Suffix_Rule">here</a> as well as the slides :D On slide 35/36 (chapter 10) there is the code for a disttable and the adapted C search code.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org2948200" class="outline-4">
<h4 id="org2948200">Wildcards</h4>
<div class="outline-text-4" id="text-org2948200">
<p>
Let's extend the problem to also allow for wildcards in our search string:
</p>
<ul class="org-ul">
<li>
<code>?</code> match exactly <b>one</b> character</li>
<li>
<code>!</code> match <b>one or no</b> character</li>
<li>
<code>*</code> match arbitrary characters (0,1,2,…,)</li>
</ul>
<p>
For this idea we'll use state machines. The search string defines a regular grammar and the state machine gets into an <i>accept</i> state when a matching (according to the grammmar) character/expression (Ausdruck) is found in the text.
</p>

<p>
Since every search string can be different the state machine has to generated at run time! It exists of other generic state machines (generische Teilautomaten). From the starting the state the state machine goes into one of the end states:
</p>
<ul class="org-ul">
<li>(part) <b>success</b> <code>s</code> when a character is found → accept</li>
<li>
<b>failure</b> <code>f</code> when nothing was found</li>
</ul>
<p>
This is how such statement machine would look like for an input of <code>"A"</code> <b>without</b> wildcards:
</p>

<p>
<img src="../../../images/state-machine-a.png" alt="nil"></p>

<p>
Now we want to formulate a state machine for the input <code>A?C</code> (including wildcards):
</p>

<p>
<img src="../../../images/state-machine-2.png" alt="nil"></p>

<p>
Here's the state machine for matchin <code>A!C</code>:
</p>

<p>
<img src="../../../images/state-machine-3.png" alt="nil"></p>

<p>
And finally the state machine for matching <code>A*C</code>:
</p>

<p>
<img src="../../../images/state-machine-4.png" alt="nil"></p>


<p>
Question/Problem: What happens when there's no normal character after a <code>!</code> or <code>*</code> in our search string (-&gt; instead other wildcards)
</p>

<p>
Some observations:
</p>
<ul class="org-ul">
<li>a search sequence of <code>!</code>'s is not critical</li>
<li>if the search pattern starts with <code>*</code> or a <code>!</code>, that wildcard can be skipped</li>
<li>if the <code>*</code> or <code>!</code> is followed by the end of the text, that wildcard can be skipped</li>
<li>if a <code>!</code> or <code>*</code> is followed by a <code>?</code> then the characters can be swapped (so können beide Zeichen getauscht werden)</li>
<li>if a <code>!</code> is followed by a <code>*</code>, the <code>!</code> can be ignored</li>
<li>if a <code>*</code> is followed by <code>!</code> or another <code>*</code> then the second wildcard can be ignored</li>
</ul>
<p>
With the observations 2-6 transformation rules can be formulated as an algorithm.
</p>

<p>
Here is the pseudocode:
</p>
<div class="highlight"><pre><span></span><span class="nl">Require</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">possibly</span> <span class="n">with</span> <span class="n">wildcards</span>
<span class="nl">Ensure</span><span class="p">:</span> <span class="n">returns</span> <span class="n">sanitized</span> <span class="n">str</span>

<span class="n">repeat</span> 
  <span class="k">while</span> <span class="n">str</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">str</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'!'</span> <span class="k">do</span>
    <span class="n">remove</span> <span class="n">first</span> <span class="kt">char</span> <span class="n">from</span> <span class="n">str</span><span class="p">;</span>
  <span class="n">end</span> <span class="k">while</span>
  <span class="k">while</span> <span class="n">str</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'*'</span> <span class="o">||</span> <span class="n">str</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'!'</span> <span class="k">do</span>
    <span class="n">remove</span> <span class="n">last</span> <span class="kt">char</span> <span class="n">from</span> <span class="n">str</span><span class="p">;</span>
  <span class="n">end</span> <span class="k">while</span>

  <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span>

  <span class="k">for</span> <span class="n">all</span> <span class="n">substr</span> <span class="n">in</span> <span class="n">str</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">substr</span><span class="p">)</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">substr</span> <span class="o">=</span> <span class="err">'</span><span class="o">!?</span><span class="err">'</span> <span class="n">then</span>
      <span class="n">replace</span> <span class="n">substr</span> <span class="n">in</span> <span class="n">str</span> <span class="n">with</span> <span class="err">'</span><span class="o">?!</span><span class="err">'</span> 
    <span class="k">else</span> <span class="k">if</span> <span class="n">sub</span> <span class="o">=</span> <span class="err">'</span><span class="o">*?</span><span class="err">'</span> <span class="n">then</span>
      <span class="n">replace</span> <span class="n">substr</span> <span class="n">in</span> <span class="n">str</span> <span class="n">with</span> <span class="err">'</span><span class="o">?*</span><span class="err">'</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">sub</span> <span class="o">=</span> <span class="err">'</span><span class="o">!*</span><span class="err">'</span> <span class="o">||</span> <span class="n">sub</span> <span class="o">=</span> <span class="err">'</span><span class="o">*!</span><span class="err">'</span> <span class="o">||</span> <span class="n">sub</span> <span class="o">=</span> <span class="err">'</span><span class="o">**</span><span class="err">'</span> <span class="n">then</span>
      <span class="n">replace</span> <span class="n">substr</span> <span class="n">in</span> <span class="n">str</span> <span class="n">with</span> <span class="sc">'*'</span>
    <span class="k">else</span>
      <span class="n">changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span>
  <span class="n">end</span> <span class="k">for</span>
<span class="n">until</span> <span class="p">(</span><span class="n">changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
</pre></div>

<p>
Since string manipulation is easier in Python we'll take a look at the implemenation of the transformation rules in Python first:
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sanitize</span> <span class="p">(</span><span class="nb">str</span> <span class="p">):</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">changed</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span> <span class="c1"># repeat as often as needed</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'*'</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'!'</span><span class="p">):</span> <span class="c1"># delete leading * or !</span>
	<span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'*'</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'!'</span><span class="p">):</span> <span class="c1"># delete tailing * or !</span>
	<span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span> <span class="s1">'*?'</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'!?'</span><span class="p">):</span>
	    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
	    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">'?'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># *? -&gt; ?* and !? -&gt; ?!</span>
	<span class="k">if</span> <span class="p">((</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span> <span class="s1">'!*'</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'*!'</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'**'</span><span class="p">)):</span>
	    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
	    <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">'*'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># !* or *! or ** -&gt; *</span>
  <span class="k">return</span> <span class="nb">str</span>
</pre></div>

<p>
The C implemenation is a bit longer but achieves the same. You can take look at it on page 47/48 (chapter 10).
</p>
</div>
</div>


<div id="outline-container-org861d68f" class="outline-4">
<h4 id="org861d68f">Data Structures</h4>
<div class="outline-text-4" id="text-org861d68f">
<p>
The state machine we constructed has to be generated at run time. A suitable data structure to represent this would be a <b>graph</b> since state machines are graphs (they consist of vertices and edges). The vertices in a graph are the states in the state machine and the edges are the transitions.
</p>

<p>
An adjacency matrix is unsuited since vertices and edges need to hold additional information so we use =struct=s with pointers (see Chapter 7, Slide 13).
</p>

<p>
What do we need to describe a transition?
</p>

<p>
→ a start and end state<br>
→ a condition
</p>

<p>
Because we will associate the edges with their origin/start state we only need the target (Wir werden die Ausgangskanten den entsprechenden Zuständen zuordnen, deshalb brauchen wir nur das Ziel).
</p>

<p>
Also there just 5 conditions in our state machine:
</p>
<ul class="org-ul">
<li>the character is found</li>
<li>the character is not found</li>
<li>the end of text is reached</li>
<li>the end of text is not reached</li>
<li>neither the character nor the end of text was found</li>
</ul>
<p>
Accordingly we can define a data structure and constants:
</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	      <span class="n">MatchChar</span><span class="p">,</span>
	      <span class="n">MatchNotChar</span><span class="p">,</span>
	      <span class="n">MatchEOT</span><span class="p">,</span>
	      <span class="n">MatchNotEOT</span><span class="p">,</span>
	      <span class="n">MatchNotCharNotEOT</span><span class="p">,</span>
	      <span class="n">NoEdge</span> <span class="c1">// mark edges that are not existing in our state machine</span>
<span class="p">}</span> <span class="n">match_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">match_t</span> <span class="n">condition</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">edge_t</span><span class="p">;</span>
</pre></div>

<p>
We describe states with:
</p>
<ul class="org-ul">
<li>designating wheather it is an end state (either <code>s</code> or <code>f</code>) or another state</li>
<li>the character that refers to the state</li>
<li>the transitions from that state</li>
</ul>
<p>
And because there can only be 3 transitions at max to other states we allow ourselves to possibly waste a bit of memory by allocating an array for exactly 3 edges.
</p>

<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	      <span class="n">StateDefault</span><span class="p">,</span>
	      <span class="n">StateSuccess</span><span class="p">,</span>
	      <span class="n">StateFail</span>
<span class="p">}</span> <span class="n">statetype_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">statetype_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
  <span class="n">edge_t</span> <span class="n">edge</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">state_t</span>
</pre></div>

<p>
Because we only at run-time how large our state machine needs to be (ie how many states it has) we create an anonymous array (that holds the states -&gt; pointer) and store the index of the start state as well:
</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">state_t</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">initial</span><span class="p">;</span>
<span class="p">}</span> <span class="n">automata_t</span><span class="p">;</span>
</pre></div>

<p>
Now the state machine can be created from the search pattern at runtime. For that we also need a success state, a fail state and a state for every non <code>*</code> character in the search string. For that we allocate memory:
</p>
<div class="highlight"><pre><span></span><span class="n">automata_t</span> <span class="nf">init_automata</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">snr</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// snr = statenumber (?)</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">snr</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="o">--</span><span class="n">snr</span><span class="p">;</span> <span class="c1">// decrease for each '*'</span>
  <span class="p">}</span>

  <span class="n">automata_t</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">snr</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state_t</span><span class="p">));</span>

  <span class="cm">/* add the elments / states to the state array</span>
<span class="cm">   the success and fail state are always the same therefore we create constant for the indices */</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">S_FAIL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_SUCC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span>

  <span class="c1">// Fail</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_FAIL</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">StateFail</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_FAIL</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_FAIL</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_FAIL</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>

  <span class="c1">// Success</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_SUCC</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">StateSuccess</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_SUCC</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_SUCC</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">S_SUCC</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span>

  <span class="n">snr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>
Let's cover the case of normal characters first. We'd have two edges. One has the character from the search string as a condition, the other has the negation of such as the condition:
</p>
<div class="highlight"><pre><span></span><span class="c1">// continuing the switch in the code listing above</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="p">{</span>
 <span class="k">default</span><span class="o">:</span>
   <span class="o">++</span><span class="n">snr</span><span class="p">;</span>
   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">StateDefault</span><span class="p">;</span>

   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchChar</span><span class="p">;</span>
   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">snr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchNotChar</span><span class="p">;</span>
   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">S_FAIL</span><span class="p">;</span>

   <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span> <span class="c1">// later conditions marked as NoEdge wont be evaluated/executed</span>
   <span class="k">break</span><span class="p">;</span>
</pre></div>
<p>
This is what the above case represents
<img src="../../../images/state-machine-default-case.png" alt="nil"></p>

<p>
Onto the case for the <code>'?'</code> wildcard character which is similar to the state for a normal character, with the difference that the condition is <i>End-of-Text</i> (and its negation) because the '?' allows <b>one</b> arbitrary character:
<img src="../../../images/state-machine-question-mark.png" alt="nil"></p>
<div class="highlight"><pre><span></span><span class="k">case</span> <span class="sc">'?'</span><span class="o">:</span>
  <span class="o">++</span><span class="n">snr</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">StateDefault</span><span class="p">;</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchNotEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">snr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">S_FAIL</span><span class="p">;</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">NoEdge</span><span class="p">;</span> <span class="c1">// no third edge therefore not needed/used</span>

  <span class="k">break</span><span class="p">;</span>
</pre></div>

<p>
Now the case for the <code>'!'</code> wildcard character. The state for <code>'!'</code> needs 3 edges
</p>
<ul class="org-ul">
<li>one edge to the state after the next state (folgezustand des folgezustands) with the condition that the character of the next state is found (represents the optionality)</li>
<li>one edge to the next state when neither the character of the next state nor EOT is matched (represents arbitrary char)</li>
<li>one edge for EOT that goes to fail state</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">case</span> <span class="sc">'!'</span><span class="o">:</span>
  <span class="o">++</span><span class="n">snr</span><span class="p">;</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">StateDefault</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">ch</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ch</span><span class="p">;</span> <span class="c1">// get character from next state</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchChar</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>

  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">S_FAIL</span><span class="p">;</span>


  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchNotCharNotEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">snr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">break</span><span class="p">;</span>
</pre></div>

<p>
In contrast to the previous cases, the <code>'*'</code> character <b>does not</b> create a new state. Instead the state of the next character is <b>modified</b>
</p>
<ul class="org-ul">
<li>the condition of the edge to 'fail' is mititgated (abgeschwächt) to EOT</li>
<li>a loop to itself is added, when neither the original character nor EOT are matched</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">case</span> <span class="sc">'*'</span><span class="o">:</span>
  <span class="c1">// no ++snr</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">condition</span> <span class="o">=</span> <span class="n">MatchNotCharNotEOT</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">snr</span><span class="p">;</span>
  <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>
Finally we also need to determine the initial state of our state machine. Since we operated on the search pattern from the tail, the initial state is the state that was generated last.
</p>
<div class="highlight"><pre><span></span>  <span class="k">switch</span> <span class="p">{</span> <span class="c1">// switch from above</span>
  <span class="p">...</span>
  <span class="p">}</span>

  <span class="n">a</span><span class="p">.</span> <span class="n">initial</span> <span class="o">=</span> <span class="n">snr</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// close init_automata function</span>
</pre></div>

<p>
Now the state machine is constructed and can be used
</p>
</div>

<ul class="org-ul">
<li>
<a id="org7e00e31"></a>Executing the State Machine<br><div class="outline-text-5" id="text-org7e00e31">
<p>
Since now we have the function to initialize the state machine, it can be executed when the search is performed. Because of the wildcards the length of the match is not known beforehand, the search needs to return two values (start and end):
</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">searchresult_t</span><span class="p">;</span>

<span class="n">searchresult_t</span> <span class="nf">search</span> <span class="p">(</span><span class="n">automata_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
</pre></div>

<p>
When executing the search what basically needs to happen is that it is checked if a condition is true and then a switch to the next state needs to happen. If the state machine gets into the 'fail' or 'success' state the execution ends.
</p>

<div class="highlight"><pre><span></span><span class="n">searchresult_t</span> <span class="nf">search</span> <span class="p">(</span> <span class="n">automata_t</span> <span class="n">a</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">text</span> <span class="p">,</span> <span class="kt">size_t</span> <span class="n">tlen</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">searchresult_t</span> <span class="n">res</span> <span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">tlen</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">snr</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">initial</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">StateDefault</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">condition</span> <span class="o">==</span> <span class="n">MatchChar</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">ch</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">condition</span> <span class="o">==</span> <span class="n">MatchNotChar</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">ch</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">condition</span> <span class="o">==</span> <span class="n">MatchEOT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span> <span class="sc">'\0'</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">condition</span> <span class="o">==</span> <span class="n">MatchNotEOT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">condition</span> <span class="o">==</span> <span class="n">MatchNotCharNotEOT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">ch</span><span class="p">)))</span>
	  <span class="p">{</span>
	    <span class="n">snr</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	    <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="cm">/* next character */</span>
	    <span class="k">break</span><span class="p">;</span>
	  <span class="p">}</span>
      <span class="p">}</span> <span class="cm">/* end for iteration over edges */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="n">snr</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">StateSuccess</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
      <span class="n">res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">res</span> <span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="cm">/* end for iteration over text */</span>
  <span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
Because of the new return value of the search function, the presentResult function (from last lecture) also needs to be adapted:
</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">presentResult</span><span class="p">(</span><span class="n">searchresult_t</span> <span class="n">res</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">prelen</span><span class="p">;</span>

  <span class="n">start</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="o">?</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// output beginning</span>

  <span class="n">prelen</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span> <span class="c1">// beginning of match</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s[%.*s]%.20s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="o">-</span><span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">[</span><span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">[</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

<p>
Finally we can use our algorithm in the following main function:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span> <span class="p">[])</span> <span class="p">{</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">pattern</span><span class="p">;</span>
  <span class="n">automata_t</span> <span class="n">automata</span><span class="p">;</span>
  <span class="n">searchresult_t</span> <span class="n">found</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

  <span class="cm">/* ... error checks and file / memory !</span>
<span class="cm">     handling as in simple search ... */</span>

  <span class="n">text</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

  <span class="n">pattern</span> <span class="o">=</span> <span class="n">sanitize</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">automata</span> <span class="o">=</span> <span class="n">init_automata</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>

  <span class="n">found</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">automata</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">.</span><span class="n">start</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">presentResult</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">automata</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">found</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
Final Reflections:
Like the simple search, this algorithm has a complexity of \(\mathcal{O}(m*n)\) where <code>n</code> is the size of the text and <code>m</code> the max (expanded) size of the search pattern. In the worst case, when <code>*</code> occurs in the search pattern, the expanded length/size is the length of the text that is searched the complexity can get to \(\mathcal{O}(n^2)\). That's why in praxis there's usually an agreement upon that searches are performed line by line and that line endings are not matched (or that there's a max expansion length).
Also beware that wildcard search algorithm are often not realized via this algorithm that we looked and instead with recursive functions.
</p>
</div>
</li>
</ul>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="knowledge-database",
            disqus_url="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-19/",
        disqus_title="Algos & Programming - Lecture 19",
        disqus_identifier="cache/posts/algos_and_programming/19-lecture.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
