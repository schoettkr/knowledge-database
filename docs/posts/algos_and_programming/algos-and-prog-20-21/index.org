#+BEGIN_COMMENT
.. title: Algos & Programming - Lecture 20 & 21
.. slug: algos-and-prog-20-21
.. date: 2018-12-14
.. tags: university, A&P 
.. category: 
.. link: 
.. description: 
.. type: text
.. has_math: true
#+END_COMMENT

In this lecture chapter we turn our attention to a little project to use some of the learned skills together to build something. Therefore we build a "game". Because the emphasis is on the development cycle, there will also be preliminary and "wrong" solutions.

I might refer to the slides more often in the next two posts that regard this "game" because it would get pretty messy else and just copy & pasting code is not a good use of time, so I might skip that at some points and tell you to look at the slides directly.

This chapter also spans two lectures so lecture 20 and 21 will be pooled into this single blog post.

* Intro
The game we're building is TicTacToe (TTT), where there's one player versus the computer as the opponent player. TTT is a round-based game. Regardless of whose turn it is, the current game score should always be shown. The game continues until victory or draw.
These lead to the following high level pseudo algorithm:
#+BEGIN_SRC c
Input who will start -> turn {player, computer}

repeat
  if turn == computer then
    calculate move
    turn <- player
  else
    input move
    turn <- computer
  end if
  display move
until (somebody won) or (draw)
#+END_SRC

Modern programs usually offer a GUI (graphical user interface) but we'll stick to our beloved console (which might actually help with portability if we adhere to the POSIX-Standard).
On the terminal the game could be visualized like this:
#+BEGIN_SRC sh
x | o | x
--+---+--
x | o | 
--+---+--
o |   | x
#+END_SRC
Not as beatufiul as a GUI but much more simple for now. And to not obstruct the later development of a possible GUI, we should seperate the user interface as much as possible from the program logic.

To do so we *modularize* our project into three modules:
- "ttt_main.c" \rightarrow superstructure that combines the others and provides the =main= method
- "ttt_io.c" \rightarrow responsible for input and output
- "ttt_strategie.c" \rightarrow responsible for calculating the move of the computer
  
To share common types and interface we also want a shared header file "ttt.h".

This is how the file structure looks

[[img-url:/images/file-structure.png ]]

** Excourse: Make
When a project consists of multiple modules, each of them has to be translated to an object file seperately (eg via =gcc -c <file.c>=) and then all object files have to be linked (with the libraries).

Doing this by hand is cumbersome.

What to do? Well you could write a script to automate the job, but do we really want to compile and translate /every/ file even if we only change one of lets say 10 files? Hint: No we don't :D and that's why scripts (batch jobs) are not so well suited (beware that it is still possible to do that and some programmers actually prefer that which is totally fine).

Another solution to this are *build systems* also called *build automation tools*. Build automation is the process of automating the creation of a software build and the associated processes including: compiling computer source code into binary code, packaging binary code, and running automated tests (source: wikipedia).

We'll focus on one of the most common build tools which is *make*.

Wikipedia: Make is a build automation tool that automatically builds executable programs and libraries from source code by reading files called Makefiles which specify how to derive the target program. Though integrated development environments and language-specific compiler features can also be used to manage a build process, Make remains widely used, especially in Unix and Unix-like operating systems.

Besides building programs, Make can be used to manage any project where some files must be updated automatically from others whenever the others change. There are now a number of dependency-tracking build utilities, but Make is one of the most widespread, primarily due to its inclusion in Unix.

As stated above =make= interprets what is written in a so called "Makefile". A Makefile contains five kinds of things: /explicit rules/, /implicit rules/, /variable definitions/, /directives/, and /comments/.
- /explicit rule/ \rightarrow says when and how to remake one or more files, called the rule's targets; it lists the other files that the targets depend on, called the prerequisites of the target, and may also give a recipe to use to create or update the targets
- /implicit rule/ \rightarrow says when and how to remake a class of files based on their names; it describes how a target may depend on a file with a name similar to the target and gives a recipe to create or update such a target
- /variable definition/ \rightarrow is a line that specifies a text string value for a variable that can be substituted into the text later
- /directive/ \rightarrow is an instruction for make to do something special while reading the makefile such as reading another makefile
- /comment/ \rightarrow a comment is designated by '#' and ignores the rest of the line

To define variables in a makefile the following syntax is used:
#+BEGIN_SRC sh
# <name> = <value> or <name> := <value>
objects = program.o foo.o utils.o # variable that holds names of object files
# or
objects := program.o foo.o utils.o
# acess via $(objects) or ${objects}
#+END_SRC
Slides: The variant/flavour without colons (":") allows for recursion in the name resolution.

To read more about variables and the differences in the flavours you can go [[https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_chapter/make_6.html][here]].

To define functions in a makefile the following syntax is used:
#+BEGIN_SRC sh
# $(<functionname> <arg1>, <arg2>, ..) or ${<functionname> <arg1>, <arg2>, ..} 
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo)) # bar is now 'a,b,c'
#+END_SRC
Here the =subst= function, which is built-in with alot of others, replaces each space with a comma, through the value of foo, and substitutes the result. [[https://www.gnu.org/software/make/manual/html_node/Functions.html][Here]] you can read more about functions in makefiles.

Here's another example from the slides:
#+BEGIN_SRC sh
SOURCEFILES = $(wildcard ttt_*.c)
OBJECTFILES = ${subst .c,.o,$(SOURCEFILES)}
#+END_SRC
It is pretty common to use functions for text manipulation purposes.

Here're some more example functions (more can be found in the documentation):
#+BEGIN_SRC sh
$(subst <from>,<to>, <text>) # replaces all <from> with <to> in <text>
$(addprefix <prefix>,<list>) / $(addsuffix <suffix>,<list>) # adds the pre or suffix to every word in <list>
$(join <list1>,<list2>) # joins the two lists by word into one list
$(foreach <var>,<list>,<text>) # creates for each value in <list> a new instance of <text> in which every occurence of <var> is replaced by the list value
$(shell <command>) # executes the <command> in a shell
#+END_SRC

The rules in a makefile have the following form:
#+BEGIN_SRC sh
target: dependencies
    system command(s)
#+END_SRC

A *target* is usually the name of a file that is generated by a program (eg executable or object files), but a target can also be the name of an action to carry out, such as "clean".

A *dependency* (also called /prerequisite/) is a file that is used as input to create the target, which often depends on several files. Rules that specify a /recipe/ for the target don't /need/ to have prerequisites (eg delete command that is associated with target "clean" does not have any prerequisites).

The *system command(s)* (also called *recipe*) is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Note the use of meaningful indentation in specifying commands; also note that the indentation must consist of a single <tab> character.

Rules that operate on /classes/ of files (eg via wildcard) are called "implicit" rules in constrast to explicit rules. =%= serve as wildcards.

Example rules:
#+BEGIN_SRC sh
main.o: main.c defs.h
    cc -c main.c
    
clean:
     rm edit main.o kbd.o command.o display.o
#+END_SRC

And here're some automatic special variables than can be used in rules:
- =$@= = the file name of the target of the rule
- =$<= = the name of the first prerequisite (if the target got its recipe from an implicit rule, this will be the first prerequisite added by the implicit rule)
- =$?= = the names of all the prerequisites that are newer than the target, with spaces between them
- =$^= = the names of all the prerequisites, with spaces between them
- =${@D}= = the directory part of the file name of the target, with the trailing slash removed 
- =${<D}= = the directory part of the first prerequisite
- =${@F}= = the file-within-directory part of the file name of the target
- =${<F}= = the file-within-directory part of the first prerequisite

  
To execute =make= run =make <target>= which starts all activities that are accordingly to the Makefile required to update =<target>=. If a file is (already) updated is decided based on the timestamp of the file. If the =<target>= is ommitted when executing make, the first rule in the Makefile will be used. 

Example Makefiles:
#+BEGIN_SRC sh
a: b

c: e f

b: c d
#+END_SRC
So in this case when you run =make a=:
- =f=, =e=, and =d= are required to existing
- then first =c= is generated/updated out of =e= and =f=
- then =b= is generated/updated out of =c= and =d=
- da es für „a“ Ausführungsteil gibt, ist hier die Abarbeitung beendet
  
For our TicTacToe Project the Makefile could look like this:
#+BEGIN_SRC sh
PROG = ttt # program name
CC = cc # compiler
CFLAGS = -std=c99 -pedantic -Wall -Wextra # compiler flags
LDFLAGS = # linker flags (ld is the gnu linker)

HEADER = $(wildcard ttt*.h)
SOURCEFILES = $(wildcard ttt_*.c)
OBJECTFILES = $(subst .c, .o, $(SOURCEFILES))

$(PROG): $(OBJECTFILES)
    $(CC) $(LDFLAGS) $(OBJECTFILES) -o $(PROG)
                
%.o: %c
    $(CC) -c $(CFLAGS) $<
                
.PHONY: clean
clean:
    rm -f $(PROG) *.o

#+END_SRC

** The Main Loop
Going back to our initial draft of our high level pseudo code algorithm we might want some modifications that account for:
- recognition weather win or draw
  - probably closely related to the strategy part of our program so should be done there
- cancellation of the game
  - has to be dealt with in the main loop
- multiple games in a row
  - also belongs in the main loop
    
Here's the second version:
#+BEGIN_SRC c
repeat
  Input who will start -> turn {player, computer}

  repeat
    if turn == computer then
      calculate move
      turn <- player
    else // turn = player
      input move // abort is special move
      turn <- computer
    end if
    display move
  until (somebody won) or (draw) or (abort)
  Input if another game?
until not another game
#+END_SRC

This is how the main loop in "ttt_main.c" could look like in C:
#+BEGIN_SRC c
  do { // main loop
    int player =  ttt_x_or_o(); // select symbol (x or o)
    bool computer_turn = (player == 'o'); // x starts if player is o then the computer starts
    ttt_init_board(board); // erase board
    int move, assessment;

    do { // main loop for a game instance
      ttt_update_display(board); // display board
      move = computer_turn ? // computer's move?
        ttt_calculate_move(board, ttt_opponent(player)) : ttt_input_move(board);

      if (move != TTT_ABORT) { // continue?
        board[move] = computer_turn ? ttt_opponent(player) : player; // apply move
      }

      computer_turn = !computer_turn; // change the turn
      assessment = ttt_won_or_draw(board, player); // game over?

      if (assessment != TTT_UNDECIDED) { // game finished
        ttt_update_display(board); // display final board
        ttt_output_result(assessment); // print result
      }
    } while ((move != TTT_ABORT) && (assessment == TTT_UNDECIDED));
   } while (ttt_another_game() == true);
#+END_SRC
As you can see we use function that are not defined yet. Some of those shall be implemented in other modules. A somewhat common ("best") practice is to prefix global names with the name of the project (and optionally the module) to reduce the likelihood of name conflicts. In this case we use =ttt_= as a prefix.

Now we've got to ask ourselves how we want to represent the data in C. It first seems natural to use a multidimensional array =int board[3][3]= to represent the game board. *But*
- this would always require two indices \rightarrow and therefore 2 loops
- it is likely that we want to pass the board to functions \rightarrow *array decay* even unclearer when dealing with nested arrays (see lecture 08 for array decay)

For those reasons we use a "normal" array with 9 fields =int board[9]= (resp =typedef int ttt_board_t[NUMBER_OF_FIELDS])=.

Let's put declarations of types and constants in the shared header file =ttt.h=
#+BEGIN_SRC c
  #include <stdbool.h>

  /* general constants */
  typedef enum {TTT_ABORT = -1, NUMBER_OF_FIELDS = 9} ttt_constant_t;

  /* game outcomes */
  typedef enum {TTT_PLAYER_WINS, TTT_COMPUTER_WINS, TTT_DRAW, TTT_UNDECIDED} ttt_result_t;

  typedef int ttt_board_t[NUMBER_OF_FIELDS];
#+END_SRC
The prototypes (interfaces/declarations) of the (to be written) C functions that will be called from other modules will also be added there.

Two of the functions that we used in the main loop also go into the main file "ttt_main.c":
#+BEGIN_SRC c
  void ttt_init_board(ttt_board_t f) {
    /* emtpies every field */
    int i;
    for (i = 0; i < NUMBER_OF_FIELDS; i++) {
      f[i] = ' ';
    }
  }

  char ttt_opponent(char symbol) {
    switch (symbol)
      {
      case 'x': return 'o';
      case 'o': return 'x';
      default: return ' ';
      }
  }
#+END_SRC
** Input & Output
Since we use a text based interface our user interface is not so complicated and does not require as much of an effort (real user interfaces usually require a lot of work). But we still want to be lazy :D

For example let's look at options to clear the screen:
- scroll down \rightarrow window size has to be known (N)
- unix command =clear= \rightarrow really slow and not portable (N)
- ANSI/VT100 escape sequence (control command) \rightarrow also not 100% portable
- best solution: usage of portable libraries for example ncurses (or pdcurses for windows)
  
To keep it simple we use the solution with the ANSI escape codes:
#+BEGIN_SRC C
  /* Use VT100 ESC code to clean terminal */
  static void ttt_clean_terminal(void) {
    printf("%c[2J", 27);
  }
#+END_SRC

Now to determine whether or not another game should be started we use =getchar()=, which returns the integer value (!) of the entered character.
#+BEGIN_SRC c
  bool ttt_another_game() {
    int input;
    printf("Do you want to play another game [y/n] -> ");
    input = getchar();
    getchar(); // see notes below..
    if ((input == 'Y') || (input == 'y') ) {
      return true;
    } else {
      return false;
    }
  }
#+END_SRC
Slides: Es gibt allerdings ein Problem und zwar, dass das Terminal gibt eine Eingabe erst weiter, wenn <RETURN> gedrückt wurde. Das Zeichen "⏎" ist Teil des Eingabestroms. Lösung: Die Funktion wird zweimal aufgerufen und das zweite Ergebnis verworfen.

I actually fail to see what is meant by the "problem" described above and how the second call to =getchar()= should help with that... I tested the code with and without it and got identical behaviour, but this is what stands in the slides.


Now let's implement the function for inputting a move:
#+BEGIN_SRC c
  int ttt_input_move(const ttt_board_t board) {
    int input;
    printf("\nPlease enter the number of the field you want to occupy (0 for abort)\n");

    ttt_display_board(numberfield);

    printf("Your move ->");

    do {
      do {
        input = getchar(); getchar(); // xD defuq :D
      } while ((input < '0') || input > '9');

      if (input == '0') return TTT_ABORT;

      input = input - 1 // character to integer array index
        } while (board[input] != ' ');

    return input;
  }
#+END_SRC

To output/print the board we use a bit of ACII art :D
#+BEGIN_SRC C
  void ttt_display_board(const ttt_board_t board) {
    for (int i = 0; i < 3; i++) {
      if (i) { // not for first row
        printf("\n   -+-+-");
      }

      printf("\n   ");

      for (int j = 0; j < 3; i++) {
        if (j) { // not for first column
          printf("|");
        }

        printf("%c", board[3*i+j]);
      }
    }
    printf("\n");
  }
#+END_SRC

** Strategy & Logic
F28

------ 
Sources: Wikipedia was heavily used for this post
