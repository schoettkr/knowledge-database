<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 11 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
<meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 11">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-11/">
<meta property="og:description" content="Logic and Abstract Machines (Automaten)



Boolean Algebra


Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-12T00:00:00+01:00">
<meta property="article:tag" content="A&amp;P">
<meta property="article:tag" content="university">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right" role="search">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search">
</div>
  <button type="submit" class="btn btn-primary">
    <span class="glyphicon glyphicon-search"></span>
  </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 11
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-11-12T00:00:00+01:00">2018/11/12</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../../categories/ap/" rel="tag">A&amp;P</a>
	    </div>
	    <div class="tag">
	      <a href="../../../categories/university/" rel="tag">university</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-org35c18e5" class="outline-2">
<h2 id="org35c18e5">Logic and Abstract Machines (Automaten)</h2>
<div class="outline-text-2" id="text-org35c18e5">
</div>
<div id="outline-container-orgc02a1f6" class="outline-3">
<h3 id="orgc02a1f6">Boolean Algebra</h3>
<div class="outline-text-3" id="text-orgc02a1f6">
<p>
Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively.
<b>Propositional logic</b> (Aussagenlogik) is a branch of logic which deals with propositions (which can be true or false) and argument flow. Compound propositions are formed by connecting propositions by logical connectives. The propositions without logical connectives are called atomic propositions. 
</p>

<p>
Principles:
</p>
<ul class="org-ul">
<li>
<b>principle of bivalence</b> (Zweiwertigkeit) → every proposition (Aussage) is either true (truthy) or false (falsy)</li>
<li>
<b>principle/law of excluded third/middle</b> → for any proposition, either that proposition is true or its negation is true - no third possibility is given</li>
<li>
<b>principle/law of noncontradiction</b> → no proposition can be true and false at the same time</li>
<li>
<b>principle of extensionality</b> → the truth value of a composite proposition (Aussageverknüpfung) only depends on the truth value of its components</li>
</ul>
<p>
F 3./4.
</p>
</div>
<div id="outline-container-orgbcbba1b" class="outline-4">
<h4 id="orgbcbba1b">Logical Composition</h4>
<div class="outline-text-4" id="text-orgbcbba1b">
<p>
The following logical compositions (Verknüpfungsfunktionen) will be inserted as pictures from the lecture slides because it is pretty time-consuming to port it over.
</p>

<p>
<img src="../../../images/logical-comp-1.png" alt="nil"></p>

<p>
<img src="../../../images/logical-comp-2.png" alt="nil"></p>

<p>
A set of logical compositions that is able to express all other compositions is called <b>logically/functionally complete</b> (logisch vollständig)
</p>

<p>
More laws and rules from lecture slides:
</p>

<p>
<img src="../../../images/bool-law-1.png" alt="nil"></p>

<p>
<img src="../../../images/bool-law-2.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-org3cb7059" class="outline-4">
<h4 id="org3cb7059">Normal Form</h4>
<div class="outline-text-4" id="text-org3cb7059">
<p>
Normal forms can help with unifying boolean expressions/propositions which can get unclearly fast (unübersichtlich):
</p>
<ul class="org-ul">
<li>
<b>disjunctive normal form</b> → is a standardization (or normalization) of a logical formula which is a disjunction of conjunctive clauses; it can also be described as an <b>OR</b> of <b>ANDs</b> or a sum of products
<ul class="org-ul">
<li>slides: Eine boolsche Funktion ist in disjunktiver Normalform (DNF), wenn sie eine Disjunktion (Oder) von Konjunktionsstermen (Und) ist, wobei die Konjunktionsterme nur (ggf. negierten) Funktionsparameter enthält</li>
<li>\(y = \vee_i (\wedge_j [\neg] x_{i,j}) \)</li>
</ul>
</li>
<li>
<b>conjunctive normal form</b> → is a conjunction of one or more clauses, where a clause is a disjunction of literals; otherwise put, it is an <b>AND</b> of <b>ORs</b>
<ul class="org-ul">
<li>slides: Eine boolsche Funktion ist in konjunktiver Normalform (KNF), wenn sie eine Konjunktion (Und) von Disjunktionstermen (Oder) ist, wobei die Disjunktionsterme nur (ggf. negierten) Funktionsparameter enthält</li>
<li>\(y = \wedge_i (\vee_j  [\neg] x_{i,j}) \)</li>
</ul>
</li>
</ul>
<p>
There are different ways to create normal forms eg conversions via boolean algebra or by using truth tables:
</p>

<p>
<img src="../../../images/normalform.png" alt="nil"></p>

<p>
At this point the Karnaugh-Veitch Diagram for optimization purposes was mentioned which I'm skipping here. Take a look at slide 13 if you want (I don't lol).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc3eee68" class="outline-2">
<h2 id="orgc3eee68">Logic in C</h2>
<div class="outline-text-2" id="text-orgc3eee68">
<p>
C uses logical (boolean) propositions/expressions and knows an according type. However since that type is so close to integer, it was not made explicitly available before C99. Since C99 however there is <code>_Bool</code>. Via including <code>stdbool.h</code> the type <code>bool</code> is available which is a synonym for <code>_Bool</code> and can hold the values <code>true</code> or <code>false</code>.
But remember that everywhere were a boolean type is required there can always be an integer. If so <code>0</code> is always interpreted as <code>false</code> and <i>every other</i> value as <code>true</code>.
</p>

<p>
The logic/boolean operators <code>&amp;&amp;</code> and <code>||</code> in C do so called <b>short-circuit evaluation</b> from left to right which means the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression: when the first argument of the <b>AND</b> function evaluates to <code>false</code>, the overall value must be <code>false</code>; and when the first argument of the <b>OR</b> function evaluates to <code>true</code>, the overall value must be <code>true</code>
</p>

<p>
Short-circuit operators are, in effect, control structures rather than simple arithmetic operators, as they are not strict. In imperative language terms (notably C and C++), where side effects are important, short-circuit operators introduce a sequence point – they completely evaluate the first argument, including any side effects, before (optionally) processing the second argument (es ist eine gängige Programmiertechnik, links im Kurzschlussoperator eine Bedingung abzusichern, die rechts zu einem Laufzeitfehler führen würde)
</p>

<p>
Bad code example from the lecture slides follows, BRACE YOURSELF:
</p>
<div class="highlight"><pre><span></span><span class="cm">/* shortcut .c -- partial evaluation */</span>
<span class="cp"># include &lt;stdio.h&gt;</span>

<span class="k">enum</span> <span class="p">{</span><span class="n">arraysize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="n">arraysize</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">arraysize</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arraysize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">/</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d. value : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
Some imho more practical pseudo examples could look like this:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">firedMissles</span> <span class="o">=</span> <span class="n">CanFireMissiles</span> <span class="o">&amp;&amp;</span> <span class="n">FireMissiles</span><span class="p">();</span>

<span class="cm">/* or */</span>

<span class="n">isFileReady</span><span class="p">()</span> <span class="o">||</span> <span class="n">getFileReady</span><span class="p">()</span>
</pre></div>

<p>
C also provides a <i>conditional operator</i>. If any operator is used on three operands or variable is also known as <i>Ternary Operator</i>. It can be represented with <code>"? : "</code>.
</p>

<p>
The ternary operator is used to execute code based on the result of a binary condition.
</p>

<p>
It takes in a binary condition as input, which makes it similar to an 'if-else' control flow block. It also, however, returns a value, behaving similar to a function (functional model).
</p>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">binaryCondition</span> <span class="o">?</span> <span class="nl">valueReturnedIfTrue</span> <span class="p">:</span> <span class="n">valueReturnedIfFalse</span><span class="p">;</span>
</pre></div>
<p>
The ternary cannot be used to execute code. It must be either returned in a function, or set equal to a variable with the same data type as the returned values:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">findMaximum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="c1">//if a &gt; b, it returns a, if not it returns b</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span> 
</pre></div>
<p>
Some interesting notes and observations about the ternary operator can be found <a href="https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/">here</a>.
</p>

<p>
The next lecture topic was the switch-case. I already covered that in <a href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/#org48e22fb">this CS01 post</a> and the rules from C++ apply to C aswell (other way round technically :D). Remember that "switch case" works with constant values as its cases and is used to "jump" to a specific statement from where execution will be continued until you <code>break</code> or <code>return</code>! so following cases would be executed as well (avoid this and rather group cases together. It is also important to know that cases inside a switch are like "goto" labels and share scope, thats why often times people wrap the cases code inside "{}" to create case specific code and dont "skip" initialization of variables).
</p>
</div>
</div>
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2018         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
