<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 18 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-18/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 18">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-18/">
<meta property="og:description" content="Text Search



Files


Bigger volumes of data are usually not entered interactively but rather stored in files. That's why we take a look at files first: A file is a set of data that logically belongs">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-12-07T00:00:00+01:00">
<meta property="article:tag" content="A&amp;P">
<meta property="article:tag" content="university">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<div>
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right search-form" role="search">
    <input type="text" name="q" class="form-control search-input" placeholder="Search"><button type="submit" class="search-button">
      <i class="fa fa-search" aria-hidden="true"></i>
    </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>
</div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 18
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-12-07T00:00:00+01:00">2018/12/07</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../../categories/ap/" rel="tag">A&amp;P</a>
	    </div>
	    <div class="tag">
	      <a href="../../../categories/university/" rel="tag">university</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgeb4d687" class="outline-2">
<h2 id="orgeb4d687">Text Search</h2>
<div class="outline-text-2" id="text-orgeb4d687">
</div>
<div id="outline-container-org289df66" class="outline-3">
<h3 id="org289df66">Files</h3>
<div class="outline-text-3" id="text-org289df66">
<p>
Bigger volumes of data are usually not entered interactively but rather stored in <b>files</b>. That's why we take a look at files first: A file is a set of data that logically belongs together and is treated as a unit. Files are usually acessed by a <i>file name</i> that is known to the operating system and get stored on persistant data volumes (eg harddrives).
</p>

<p>
Files can be organized differently. In the sense of the UNIX philosophy a file is a single set of bytes with an arbitrary size. Such data set resp sequence of bit is also called <b>bitstream</b> resp. <b>bytestream</b>.
</p>

<p>
The input/ouput of the C standard library is adapted to this concept so that there is no differentitation required between input from an input device or a file. To be more precise, the C standard library knows two types of file operations:
</p>
<ul class="org-ul">
<li>
<b>low level file operations</b>
<ul class="org-ul">
<li>files and file/data streams are identified via a <b>handle</b>
</li>
<li>specific to the particular operating system</li>
</ul>
</li>
<li>
<b>high level file operations</b>
<ul class="org-ul">
<li>files and file/data streams are identified via a <b>file pointer</b>
</li>
<li>independant of the operating system</li>
</ul>
</li>
</ul>
<p>
For now we'll look at <b>high level file operations</b>.
</p>

<p>
Files have to be <b>opened</b>. When opening a file the management/administration information is created (Verwaltungsinformationen). There's a function in the standard library to open files <code>FILE* fopen(char* name, char* mode)</code> which returns a pointer to the file management structure (Dateiverwaltungsstruktur) or NULL:
</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cm">/* ... */</span>

<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"myFile.dat"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
</pre></div>

<p>
A file that is no longer needed should be closed and the management resources shoudl eb released. That is done via <code>int fclose(FILE* stream)</code> which returns <code>0</code> when the file was closed successfully.
</p>

<p>
Here's a list of the possible file access modes which are passed to <code>fopen</code>:
</p>
<ul class="org-ul">
<li>
<code>"r"</code> → <b>read</b>: open file for input operations (reading from the file); the file must exist</li>
<li>
<code>"w"</code> → <b>write</b>: create an empty file for output operations (writing to a file); if a file with the same name already exists, its contents are discarded and the file is treated as a new empty file</li>
<li>
<code>"a"</code> → <b>append</b>: open file for output at the end of a file; output operations always write data at the end of the file, thus expanding it; repositioning operations (fseek, fsetpos, rewind) are ignored; the file is created if it does not exist</li>
<li>
<code>"r+"</code> → <b>read/update</b>: open a file for update (both for input and output); the file must exist</li>
<li>
<code>"w+"</code> → <b>write/update</b>: create an empty file and open it for update (both for input and output); if a file with the same name already exists its contents are discarded and the file is treated as a new empty file</li>
<li>
<code>"a+"</code> → <b>append/update</b>: open a file for update (both for input and output) with all output operations writing data at the end of the file; repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file; the file is created if it does not exist</li>
</ul>
<p>
With the <i>mode specifiers</i> above files are opened as <i>text files</i>. In order to open a file as a <i>binary file</i> a <code>"b"</code> character has to be included in the mode string.  This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the plus sign for the mixed modes ("rb+", "wb+", "ab+").
</p>

<p>
For data input and output, C provides a collection of library functions. These functions enable the transfer of data between the C program and standard input/output devices. C always treats all input-output data, regardless of where they originate or where they go, as a stream of characters. 
The operating system makes the input and output devices available to a C program as if these devices were files. So, essentially, when a C program reads data from the keyboard, it is in effect reading from the file associated with the keyboard device. When a C program sends output data to the console, it is in effect writing to the file associated with the console device.
</p>

<p>
A stream of characters or text stream, is a sequence of characters divided into lines. Each line consists of various characters followed by a newline character (\n). All input-output functions in C conform to this model.
</p>

<p>
In order to be able to use the above mentioned input-output functions in your C program, you must begin each C program with a pre-processor directive to include these standard library functions.
</p>

<p>
This can be done via <code>#include &lt;stdio.h&gt;</code>.
</p>

<p>
These are the most common/essential input-output functions:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-left"> </th>
<th scope="col" class="org-left">Input</th>
<th scope="col" class="org-left">Output</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">formatted</td>
<td class="org-left"><code>int fscanf(FILE*, char*, ...)</code></td>
<td class="org-left"><code>int fprintf(FILE*, char*, ...)</code></td>
</tr>
<tr>
<td class="org-left">characters</td>
<td class="org-left"><code>int fgetc(FILE*)</code></td>
<td class="org-left"><code>int fputc(int, FILE*)</code></td>
</tr>
<tr>
<td class="org-left">strings</td>
<td class="org-left"><code>char* fgets(char*, int, FILE*)</code></td>
<td class="org-left"><code>int fputs(char*, FILE*)</code></td>
</tr>
<tr>
<td class="org-left">binary</td>
<td class="org-left"><code>size_t fread(void*, size_t, size_t, FILE*)</code></td>
<td class="org-left"><code>size_t fwrite(void*, size_t, size_t, FILE*)</code></td>
</tr>
<tr>
<td class="org-left"> </td>
<td class="org-left"> </td>
<td class="org-left"> </td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li>
<a id="org77ad400"></a>Formatted data input &amp; output<br><div class="outline-text-5" id="text-org77ad400">
<p>
<code>fscanf</code> and <code>fprintf</code> work like <code>scanf</code> and <code>printf</code> but take a file pointer as an additional first parameter. To use <code>fscanf</code> the file has (at least) to be opened in read mode ("r", "r+", "w+", "a+"). To use <code>fprintf</code> the file has (at least) to be opened in write mode ("w", "a", "r+", "w+", "a+"). 
</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"out.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"Hello world! The answer is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>

<li>
<a id="org07c317f"></a>Characterwise data input &amp; output<br><div class="outline-text-5" id="text-org07c317f">
<p>
The function <code>int fgetc(FILE* stream)</code> returns the next character of a file <code>stream</code> as an integer. When there's no character left, the constant <code>EOF</code> (defined in <code>stdio.h</code>) is returned (same thing when an error occurs). 
</p>

<p>
The function <code>int fputc(int c, FILE* stream)</code> writes the integer coded character <code>c</code> into the file <code>stream</code> and returns the number of written characters (= 1). In case of an error it returns <code>EOF</code>.
</p>
</div>
</li>

<li>
<a id="org318e40c"></a>String data input &amp; output<br><div class="outline-text-5" id="text-org318e40c">
<p>
The function <code>char* fgets(char restrict * str, int n, FILE* restrict stream)</code> reads maximally <code>n-1</code> characters from the file <code>stream</code> into a character string that is pointed to by <code>str</code>. The reading proccess ends with the end of the line/file or when an error occurs. When no error occurs <code>\0</code> is appended to <code>str</code> and the return value points to <code>str</code> (and to <code>NULL</code> if there was an error). Beware that it is the duty of the programmer to guarantee that <code>str</code> points to an character array which has a size of at least <code>n</code> characters.
</p>

<p>
The function <code>int fputs(char* str, FILE* stream)</code> writes the (zero-terminated) string <code>str</code> into the file <code>stream</code>. It returns a non-negative integer on success and <code>EOF</code> in case of an error (old C versions used to return <code>0</code> on success)
</p>
</div>
</li>

<li>
<a id="org8d872f6"></a>Binary data input &amp; output<br><div class="outline-text-5" id="text-org8d872f6">
<p>
The function <code>size_t fread(void* ptr, size_t size, size_t nitems, FILE* stream)</code> reads <code>nitems</code> of size <code>size</code> from the file <code>stream</code> and stores them at the address specified by <code>ptr</code>. It then returns the count of successfully read items/elements (not bytes!). 
</p>

<p>
The function <code>size_t fwrite(void* ptr, size_t size, size_t nitems, FILE* stream)</code> writes <code>nitems</code> from the address <code>ptr</code> of size <code>size</code> in the file <code>stream</code> and also returns the count of successfully written elements/items (not bytes).
</p>
</div>
</li>


<li>
<a id="org31cb6ba"></a>Standard Data Streams<br><div class="outline-text-5" id="text-org31cb6ba">
<p>
The standard input-output devices or the associated files or text streams, are referred to as:
</p>
<ul class="org-ul">
<li>
<b>stdin</b> - standard input file, normally connected to the keyboard</li>
<li>
<b>stdout</b> - standard output file, normally connected to the screen/console</li>
<li>
<b>stderr</b> - standard error display device file, normally connected to the screen/console</li>
</ul>
<p>
<code>stdin</code>, <code>stdout</code>, <code>stderr</code> don't need to be opened like other files/streams (and cannot be opened):
</p>

<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"This is usage data.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is status data.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<div id="outline-container-org2dcd619" class="outline-4">
<h4 id="org2dcd619">Manipulating the File Position Pointer</h4>
<div class="outline-text-4" id="text-org2dcd619">
<p>
See: <a href="https://stackoverflow.com/questions/39687795/what-is-file-position-pointer">https://stackoverflow.com/questions/39687795/what-is-file-position-pointer</a>
</p>

<p>
Usually files are treated as data stream, which are accessed <b>sequentally</b>. In case of "real files" it is possible to deviate from this sequential access. The following functions may be used to do so:
</p>
<ul class="org-ul">
<li>
<code>void rewind(FILE* stream)</code> → move the read or write position in the file <code>stream</code> back to the beginning of the file</li>
<li>
<code>void fseek(FILE* stream, long offset, int whence)</code> → moves the read or write position in the file <code>stream</code> to a position which is <code>offset</code> bytes shifted from <code>whence</code> (von wo/woher)
<ul class="org-ul">
<li>
<code>whence</code> shall be one of the following constants which are defined in <code>stdio.h</code>
<ul class="org-ul">
<li>
<code>SEEK_SET</code> = offset relative to the beginning of the file</li>
<li>
<code>SEEK_CUR</code> = offset relative to the current position in the file</li>
<li>
<code>SEEK_END</code> = offset relative to the end of the file</li>
</ul>
</li>
</ul>
</li>
<li>
<code>long ftell(FILE* stream)</code> → may be used to get the current position in the file relative to the beginning of the file</li>
</ul>
<p>
Slides 17-19 provide code examples for reading/writing a file.
</p>

<p>
A few other interesting functions in regards to files are:
</p>
<ul class="org-ul">
<li>
<code>int feof(FILE* stream)</code> returns a value ≠ 0 when at the end of the file</li>
<li>
<code>int ferror(FILE* stream)</code> returns a value ≠ 0 when an file error has occured before</li>
<li>
<code>int flush(FILE* stream)</code> forces a physical write (emptying the cache)</li>
<li>
<code>int remove(char* name)</code> deletes the file with a name of <code>name</code>
</li>
</ul>
</div>
</div>


<div id="outline-container-org521016c" class="outline-4">
<h4 id="org521016c">Files in Python</h4>
<div class="outline-text-4" id="text-org521016c">
<p>
F21
A file is a data type in Python. A data variable is created via <code>f = open(filename[, mode[, bufsize]])</code> .
The possible modes are a superset of the modes we know from C and with <code>bufsize</code> the cache size for the file can be set.
This is the Python 3 <a href="https://docs.python.org/3/library/functions.html#open">documentation</a> for <code>open</code> (which looks kinda different than the slides).
</p>

<p>
Here are a few common file operations in Python (<code>file</code> be a data variable):
</p>
<ul class="org-ul">
<li>
<code>S = file.read()</code> reads the whole file into a single string</li>
<li>
<code>S = file.read(N)</code> reads <code>N</code> bytes</li>
<li>
<code>S = file.readline()</code> reads the next line (until new line char)</li>
<li>
<code>L = file.readlines()</code> reads the whole file as a list of line strings</li>
<li>
<code>file.write(S)</code> writes the string <code>S</code> into the file</li>
<li>
<code>file.writeLines(L)</code> writes all strings in a list <code>L</code> into the file</li>
<li>
<code>file.close()</code> closes the file</li>
</ul>
<p>
Using iterations it is easy to work with a whole file in Python:
</p>
<div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"foo.txt"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">' '</span><span class="p">)</span>
</pre></div>

<p>
And Python provides more modules for file manipulations
</p>
<ul class="org-ul">
<li>module <code>os</code> for low level</li>
<li>module <code>shelve</code> and <code>pickle</code> for high level storage of complex objects</li>
<li>module <code>dbm</code> and <code>anydbm</code> for database interfaces</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgd886a42" class="outline-3">
<h3 id="orgd886a42">Simple Search</h3>
<div class="outline-text-3" id="text-orgd886a42">
<p>
Now with our newly acquired knowledge about files we can start looking into text search.
</p>

<p>
Our program should take the following parameters:
<code>./search &lt;searchText&gt; &lt;fileName&gt;</code>
</p>

<p>
And if the search text is found in the file, then the "surrounding" in which it was found should be returned, while the search text is wrapped in brackets to accentuate, eg
</p>
<div class="highlight"><pre><span></span>./search <span class="s2">"example"</span> lorem.txt

ullamcoprer subsciptit nisl ut aliqup <span class="o">[</span>example<span class="o">]</span> ea commodano
</pre></div>

<p>
One of the first problems we encounter is that we don't know the size/length of neither a line nor the whole file. Here a few solution approaches:
</p>
<ul class="org-ul">
<li>Approach 1: define a line buffer that is "sufficiently large" for all cases → not safe and not a good approach in general</li>
<li>Approach 2: don't always read in whole lines → complicates the search if the search text is between two read-in blocks</li>
<li>Approach 3: determine the file size, dynamically reserve space and read in the whole file → requires a lot of memory storage</li>
</ul>
<p>
We go with approach 3 since it also offers speed advantages.
</p>

<p>
So let's determine the file size first - how do we do that?
The unix C function <code>int stat(char* name, struct stat* buf)</code> which writes informations about the file <code>name</code> into <code>buf</code> is not compatible so we don't use it and instead rely on using a combination of functions from the standard library:
</p>
<div class="highlight"><pre><span></span><span class="kt">size_t</span> <span class="nf">filesize</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>
  <span class="n">fseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0L</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span> <span class="c1">// offset the file position pointer by 0 bytes relative to the eof</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">file</span><span class="p">);</span> <span class="c1">// get the current position relative to the beginning of the file</span>
  <span class="n">rewind</span><span class="p">(</span><span class="n">file</span><span class="p">);</span> <span class="c1">// move the file position pointer back to the beginning of the file</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>
By the way <code>size_t</code> is an OS dependant unsigned integer type that can store the maximum <i>size</i> of a theoretically possible object of any type (including array) and which is commonly used for array indexing and loop counting (Programs that use other types, such as <code>unsigned int</code>, for array indexing may fail on, e.g. 64-bit systems when the index exceeds <code>UINT_MAX</code> or if it relies on 32-bit modular arithmetic.).
</p>

<p>
And this will be our main function which uses our <code>filesize</code> function amongst other things:
</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// wrong number of params</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">"r"</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// open file</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// cant open file</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">filesize</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

  <span class="cm">/* allocate size+1 (for terminating 0) memory for our file buffer */</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">text</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// out of memory</span>
  <span class="p">}</span>

  <span class="cm">/* read one element of size 'size' into our text buffer (the whole file) */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span> <span class="c1">// can't read file</span>
  <span class="p">}</span>

  <span class="n">text</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// set the terminating 0;</span>

  <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">text</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// yet to implement!</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">presentResult</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// dito!</span>
  <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
This main function does the necessary preparations for the actual search. Besides the search function we also need a function for the presentation/output. We want to output 20 characters before and after the search string:
</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">presentResult</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pattern</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// pos is the start of match position, str is the file buffer and pattern our search text</span>
  <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">patlen</span><span class="p">,</span> <span class="n">prelen</span><span class="p">;</span>

  <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="o">?</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// output beginning</span>

  <span class="n">prelen</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="n">pos</span><span class="p">;</span> <span class="c1">// beginning of match</span>
  <span class="n">patternLength</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span> <span class="c1">// yet to implement!</span>

  <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">patternLength</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s[%s]%.20s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">pattern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">[</span><span class="n">end</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

<p>
As seen in the code listing above we also need a function to determine the length of a string. There's an function for that in the standard library but we'll use our own:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">len</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
Now we can finally turn our attention to the actual search algorithm. The idea is that we want to test for each position in the text <code>str</code>, if the searchstring <code>p</code> begins there. If that is the case, then we want to test the next character and so on..
</p>

<p>
Here's the pseudocode:
</p>
<div class="highlight"><pre><span></span><span class="c1">// str is file/text buffer and p is search string</span>
<span class="nl">Require</span><span class="p">:</span> <span class="n">str</span> <span class="n">and</span> <span class="n">p</span> <span class="n">is</span> <span class="n">text</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="nl">Ensure</span><span class="p">:</span> <span class="n">returns</span> <span class="n">index</span> <span class="n">of</span> <span class="n">first</span> <span class="n">appearance</span> <span class="n">of</span> <span class="n">p</span> <span class="n">in</span> <span class="n">str</span>

<span class="n">procedure</span> <span class="n">SIMPLE</span><span class="o">-</span><span class="n">SEARCH</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="n">and</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">j</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">then</span> <span class="c1">// found 1st occ of search string</span>
	<span class="k">return</span> <span class="n">pos</span>
      <span class="n">endif</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">end</span> <span class="k">while</span>
  <span class="k">return</span> <span class="s">"not found"</span>
<span class="n">end</span> <span class="n">procedure</span>
</pre></div>


<p>
The actual C implemenation is where we'll continue in the next lecture (19), have a nice day (◕‿‿◕)
</p>
</div>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="knowledge-database",
            disqus_url="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-18/",
        disqus_title="Algos & Programming - Lecture 18",
        disqus_identifier="cache/posts/algos_and_programming/18-lecture.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
