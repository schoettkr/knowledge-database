<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 10 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 10">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-10/">
<meta property="og:description" content='Introduction


How does the compiler know whether a program is "correct" (in the sense of compilable) or not?
We basically distinguish between grammar and semantics.



Grammar (like we know it from s'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-09T00:00:00+01:00">
<meta property="article:tag" content="A&amp;P">
<meta property="article:tag" content="university">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 10
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-11-09T00:00:00+01:00">2018/11/09</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../../categories/ap/" rel="tag">A&amp;P</a>
	    </div>
	    <div class="tag">
	      <a href="../../../categories/university/" rel="tag">university</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgcfa223a" class="outline-2">
<h2 id="orgcfa223a">Introduction</h2>
<div class="outline-text-2" id="text-orgcfa223a">
<p>
How does the compiler know whether a program is "correct" (in the sense of compilable) or not?
We basically distinguish between <b>grammar</b> and <b>semantics</b>.
</p>

<p>
<b>Grammar</b> (like we know it from school) consists of  <i>morphology</i> (Formenlehre v Wörtern) and syntax (Sätze). In the realm of programming morphology practically doesn't matter therefore <i>grammar</i> and <i>syntax</i> are mostly used interchangeably.
</p>

<p>
The <b>semantics</b> (<i>meaning of a sentence</i>) do not matter to the compiler.
</p>
</div>
</div>

<div id="outline-container-org0a1bb6a" class="outline-2">
<h2 id="org0a1bb6a">Syntax</h2>
<div class="outline-text-2" id="text-org0a1bb6a">
<p>
The <b>syntax</b> of a language is a <i>set of rules</i> after which <i>expressions</i> are built. This is true for natural languages like English and for formal languages likes C or Python, as well as mathematical logic or description languages etc.
</p>

<p>
Expressions in the above definition might be phrases, formulas are program/code statements.
</p>

<p>
Often times the better you understand the semantics the harder it gets to recognize the syntax (for example in my motherlanguage I don't think about the SPO-rule for subject-predicate-object at all).
</p>

<p>
Every formal language consists of <b>symbols/tokens</b>. A symbol is the <b>smallest</b> observable unit in a language (kleinste Einheit der Betrachtung innerhalb der Sprache). Symbols can be single tokens, combinations of such or whole words.
</p>

<p>
<i>Every finite, non-empty set \(\sum\) of symbols is called <b>alphabet</b>.</i>
</p>

<p>
With the elements in \(\sum\) we can build <b>expression</b>. The "empty expression" is represented as \(\epsilon\)  (epsilon).
</p>

<p>
The set \(\sum = {0,1,2,3,4,5,6,7,8,9}\) for example is sufficient to build all natural numbers in the decimal system.
</p>

<p>
/The set of all strings(combinations) (Zeichenketten) the symbols from \(\sum\) can build is called <b>Kleene star</b> \(\sum *\) of \(\sum\) (Kleenesche Hülle).
</p>

<p>
For example:
\[\sum = {a,b} \Rightarrow \sum * = {\epsilon, a, b, aa, bb, ab, ba, aaa, aab, aba,baa, ...} \\]
</p>

<p>
The set of all string without the empty string is represented as \(sum +\) Kleene Plus.
</p>

<p>
<i>Each subset \(L \subseteq \sum*\) is also a <b>formal language</b></i>.
</p>

<p>
In the following context we focus on formal languages and "languages" then refers to such.
</p>
</div>
</div>

<div id="outline-container-orgd7cff39" class="outline-2">
<h2 id="orgd7cff39">Formal languages and generative/formal grammar</h2>
<div class="outline-text-2" id="text-orgd7cff39">
<p>
How can the syntax of a language be described? Which expressions/strings in a language are valid and which aren't? An enumeration of valid expressions is usually unpractical because the quantity of expressions is often times enormously big or infinite. 
</p>

<p>
A solution to this is to <i>describe</i> how valid expressions can/may be <b>generated</b>. These "rules" are called <b>generative/formal grammar</b>. From wikipedia: "In formal language theory, a grammar (when the context is not given, often called a formal grammar for clarity) is a set of production rules for strings in a formal language. The rules describe how to form strings from the language's alphabet that are valid according to the language's syntax. A grammar does not describe the meaning of the strings or what can be done with them in whatever context—only their form."
</p>

<p>
For generative grammar of a language \(L\) a second alphabet \(V\) of variables is used in addition to the alphabet \(\sum\).
</p>
<ul class="org-ul">
<li>elements of \(\sum\) are called <b>terminal symbols</b>
<ul class="org-ul">
<li>elementary symbols of a language</li>
<li>cannot be replaced/reproduced via production rules</li>
<li>eg: "for", "if"</li>
</ul>
</li>
<li>elements of \(V\) are called <b>nonterminal symbols</b> (in some literature it is N instead of V)
<ul class="org-ul">
<li>are reproducable/replacable via production rules</li>
</ul>
</li>
</ul>
<p>
When speaking about those elements in an abstract way usually lower case letters (a,b,c..) are used for elements of \(\sum\) and uppercase letters for elements of \(V\).
</p>

<p>
A grammar is defined by production rules (or just 'productions') that specify which symbols may replace which other symbols; these rules may be used to generate strings, or to parse them. Each such rule has a head, or left-hand side, which consists of the string that may be replaced, and a body, or right-hand side, which consists of a string that may replace it. Rules are often written in the form head → body; e.g., the rule a → b specifies that a can be replaced by b.
</p>

<p>
To generate an expression we begin with a <b>start symbol</b> \(S \in V\).
</p>

<p>
Then depending on the nature of the rules \(P\) we distinguish between different kind of grammars (a regular grammar is a left or a right regular grammar):
</p>
<ul class="org-ul">
<li>a left regular grammar  is a formal grammar (V, Σ, P, S), such that all rules in P obey the forms:
<ul class="org-ul">
<li>A → a - where A is a non-terminal in V and a is a terminal in Σ</li>
<li>A → Ba - where A and B are in V and a is in Σ</li>
<li>A → ε - where A is in N and ε is the empty string.</li>
<li>so only <b>one nonterminal symbol</b> on the <i>left side</i> and on the <i>right side</i> <b>one terminal symbol</b> that <i>may be</i> <b>preceeded</b> by <i>one nonterminal symbol max</i>
</li>
</ul>
</li>
<li>a <b>right regular grammar</b> is a formal grammar (V, Σ, P, S) such that all the production rules in P are of one of the following forms:
<ul class="org-ul">
<li>B → a - where B is a non-terminal in V and a is a terminal in Σ</li>
<li>B → aC - where B and C are non-terminals in V and a is in Σ</li>
<li>B → ε - where B is in V and ε denotes the empty string, i.e. the string of length 0.</li>
<li>so only <b>one nonterminal symbol</b> on the <i>left side</i> and on the <i>right side</i> <b>one terminal symbol</b> that <i>may be</i> <b>followed</b> by <i>one nonterminal symbol max</i>
</li>
</ul>
</li>
</ul>
<p>
Types of grammars:
</p>
<ul class="org-ul">
<li>
<b>regular grammar</b> (reguläre Grammatik) → either <i>all</i> rules of P are of left regular grammar nature <i>or</i> right regular grammar nature (not both/mixed)</li>
<li>
<b>context-free grammar</b> (kontextfreie Grammatik) → a context-free grammar is a grammar in which the left-hand side of each production rule consists of <i>only a single nonterminal symbol</i>
</li>
<li>
<b>context-sensitive grammar</b> (kontextbehaftet/sensitive Grammatik) → a context-sensitive grammar is a formal grammar in which the left-hand sides and right-hand sides of any production rules may be surrounded by a context of <b>the same</b> terminal and nonterminal symbols <code>αAβ → αγβ</code>
</li>
<li>
<b>unrestricted grammar</b> (allgemeine Grammatik)</li>
</ul>
<p>
After the american linguist Noam Chomsky those grammars build the so called <b>Chomsky-Hierarchy</b> in which they're also called as:
</p>
<ul class="org-ul">
<li>
<b>Type-0 grammars</b> → <i>unrestricted grammars</i> (allgemeine Grammatiken)</li>
<li>
<b>Type-1 grammars</b> → <i>context-sensitive grammars</i>
</li>
<li>
<b>Type-2 grammars</b> → <i>context-free grammars</i>
</li>
<li>
<b>Type-3 grammars</b> → <i>regular grammars</i>
</li>
</ul>
<p>
Each n-1 grammar can "do everything and more" that a grammar of type n can do (a type 1 grammar can do everything a type 2 grammar can and so on; Grammatiken niedrigeren Typs sind erzeugungsmächtiger als die höherer Typen)
</p>
</div>
</div>

<div id="outline-container-org11cc094" class="outline-2">
<h2 id="org11cc094">Syntax Diagrams</h2>
<div class="outline-text-2" id="text-org11cc094">
<p>
How may we describe the rules of grammars? For the following we limit us to (maximal) contrext free grammars. To describe grammar rules there exist two main approaches:
</p>
<ul class="org-ul">
<li>syntax diagrams</li>
<li>(extended) Backus-Naur form</li>
</ul>
<p style="color:red;">
I was told that these were asked in last years exam
</p>

<p>
Syntax diagrams consist of of:
</p>
<ul class="org-ul">
<li>boxes with round corners → terminal symbols (lowercase, see above)</li>
<li>boxes with straight corners → nonterminal symbols (uppercase, see above)</li>
<li>connections via lines and arrows</li>
<li>each walkable way (in arrow direction) is valid a expression (Jeder (in Pfeilrichtung) begehbare Weg ist ein valider Ausdruck)</li>
</ul>
<p>
Components:
<img src="../../../images/syntax-diagram-intro.png" alt="nil"></p>

<p>
An example of a (simplified) function declaration in C in a syntax diagram:
<img src="../../../images/syntax-diagram-func-decl.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-org453a901" class="outline-2">
<h2 id="org453a901">Backus-Naur Form</h2>
<div class="outline-text-2" id="text-org453a901">
<p>
While syntax diagrams are easy to read, they're quite cumbersome and take a lot of space. A more compact alternative is the Backus-Naur form (BNF).
</p>

<p>
BNF uses meta symbols:
</p>
<ul class="org-ul">
<li>
<code>::=</code> definition symbol</li>
<li>
<code>|</code> alternative symbol</li>
<li>
<code>&lt; &gt;</code> nonterminal brackets which convert any sequence of letters, digits and spaces into a nonterminal symbol</li>
</ul>
<p>
All symbols which are neither meta symbols nor nonterminalsymbols are terminal symbols.
</p>

<p>
BNF is directly translatable into context-free grammar, but needs (for example for loops) syntactic helper variables.
</p>

<p>
That's why there's also the Extended Backus-Naur form (EBNF) which is like BNF plus:
</p>
<ul class="org-ul">
<li>
<code>[ ... ]</code> → description of <b>optional parts</b>
</li>
<li>
<code>{ ... }</code> → description of <b>repetitions</b>
</li>
</ul>
<p>
There are also some syntactic differences:
</p>
<ul class="org-ul">
<li>arbitrary paren placement (Klammerung)</li>
<li>definition symbol is <code>=</code>
</li>
<li>terminal symbols are wrapped in <code>""</code> or <code>''</code>
</li>
<li>nonterminal symbols arent specially marked
<ul class="org-ul">
<li>there also might be whitespaces in nonterminal symbol identifiers, the sequence is then separated via commas eg <code>signed integer = sign, integer</code>
</li>
</ul>
</li>
<li>expressions end with semicolons <code>;</code>
</li>
<li>specific repetitions via <code>4 * (...)</code>
</li>
<li>comments via <code>(* This is a comment*)</code>
</li>
</ul>
<p>
A (E)BNF defintion or a syntax diagram is <b>complete</b> (vollständig) if a rule exist on the left side for every nonterminal symbol on the right hand rule side.
</p>
</div>
</div>
<div id="outline-container-org2cc8986" class="outline-2">
<h2 id="org2cc8986">Regular Grammar in Action</h2>
<div class="outline-text-2" id="text-org2cc8986">
<p>
Now we'll introduce <b>regular expressions</b> which are a compact notation for regular grammars.
</p>

<p>
String searching or pattern matching in (certain) files is such a common task that "tools" using regular expression exist to help with it (for example grep, sed, awk, perl, Python, C#.. provide ways to pattern match with regular expressions).
</p>

<p>
Since the 1980s, different syntaxes for writing regular expressions exist, one being the POSIX standard and another, widely used, being the Perl syntax.
</p>

<p>
Because there is only a limited amount of symbols/characters/tokens (Zeichen) available regular expressions differentiate between regular("normal") (terminal)symbols and meta characters, with a special meaning. Common but not all meta characters are:
</p>
<ul class="org-ul">
<li>
<code>^</code> matches the starting position within the string</li>
<li>
<code>.</code> dot wildcard matches any single character (newlines sometimes excluded tho)</li>
<li>
<code>[ ]</code> a bracket expression matches a single character that is contained within the brackets eg <code>[abc]</code> matches "a", "b", or "c"
<ul class="org-ul">
<li>
<code>[^ ]</code> matches a single character that is <i>not</i> contained within the brackets</li>
</ul>
</li>
</ul>
<p>
= <code>$</code> matches the ending position of the string or the position just before a string-ending newline (in line-based tools, it matches the ending position of any line)
</p>
<ul class="org-ul">
<li>
<code>*</code> matches the preceding element <i>zero or more</i> times</li>
<li>
<code>+</code> matches the preceding element <i>one or more</i> times</li>
<li>
<code>{n,m}</code> matches the preceding element at least <code>n</code> and not more than <code>m</code> times (eg <code>a{1,3}</code> matches only <code>a</code>, <code>aa</code> and <code>aaa</code>)</li>
<li>
<code>\</code> escapes the previous meta character</li>
</ul>
<p>
There are also character classes which are the most basic regex concept after a literal match. It makes one small sequence of characters match a larget set of characters (eg in ASCII [a-z] for lowercase letters). Some examples of POSIX character classes:
</p>
<ul class="org-ul">
<li>
<code>[:alpha:]</code> for alphabetic characters (A-Z, a-z)</li>
<li>
<code>[:digit:]</code> for digits (0-9)</li>
<li>
<code>[:alnum:]</code> for alphanumeric characters (A-Z,a-z,0-9)</li>
<li>
<code>[:blank:]</code> for space and tab</li>
<li>
<code>[:print:]</code> visible characters and the space character (printable characters)</li>
</ul>
<p>
Example usage of grep which finds all defintions of <code>time_t</code> in header files (option -E stands for extended-regexp):
</p>
<div class="highlight"><pre><span></span>grep −E <span class="s2">"typedef ([_[:alpha:]][_[:alnum:]]*[[:blank:]]+)+time_t;"</span> *.h <span class="c1"># (copied from slides doesnt work for me :D)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org253815f" class="outline-2">
<h2 id="org253815f">Compiler</h2>
<div class="outline-text-2" id="text-org253815f">
<p>
F29
</p>
</div>
</div>
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2018         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
