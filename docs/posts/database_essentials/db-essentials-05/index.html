<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Database Essentials - Lecture 05 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-05/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Database Essentials - Lecture 05">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-05/">
<meta property="og:description" content="Relational Calculus (Relationenkalkül)


The expressions in relational algebra form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate rel">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-21T00:00:00+01:00">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right" role="search">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search">
</div>
  <button type="submit" class="btn btn-primary">
    <span class="glyphicon glyphicon-search"></span>
  </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Database Essentials - Lecture 05
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-11-21T00:00:00+01:00">2018/11/21</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgbec6786" class="outline-2">
<h2 id="orgbec6786">Relational Calculus (Relationenkalkül)</h2>
<div class="outline-text-2" id="text-orgbec6786">
<p>
The expressions in <i>relational algebra</i> form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate relation results. This way describes they way of <i>how</i> you come to the relation result.
</p>

<p>
There is an alternative however to describe a query result without specifying the derivation (Herleitungsvorschrift), which is called <b>relational calculus</b>. In relational calculus only the requirements of the desired resulting tuples are specified/described but not the way they are retrieved. This way describes <i>what</i> is contained in the result relation.
</p>

<p>
A calculus (Kalkül) is a method, that is determined by a set of rules, to deal with certain mathematical problems in a systematic manner and solve them automatically (slides: ist eine durch ein System von Regeln festgelegte Methode, mit deren Hilfe bestimmte mathematische Probleme systematisch behandelt und automatisch gelöst werden können) 
</p>

<p>
The basis for relational calculus is predicate/quantifier logic  of the first degree (Prädikatenlogik erster Ordnung) and the result of a query is a set of tuples. In relational calculus calculus expressions (Kalkülausdrücke) are used, in particular the <b>tuple calculus</b> and the <b>domain calculus</b>.
</p>
</div>

<div id="outline-container-orgaeab930" class="outline-3">
<h3 id="orgaeab930">Tuple Calculus</h3>
<div class="outline-text-3" id="text-orgaeab930">
<p>
The query notation for tuple calculus is {t | P(t)} where t is a tuple variable and P is a predicate over t. The result of such query is a set of all tuples for which the evaluation of the predicate P(t) yields <i>true</i>.
</p>

<p>
Take the following example relation "Student":
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">matrNr{PK}</th>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">major</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123456</td>
<td class="org-left">Archimedes</td>
<td class="org-left">Computer Science</td>
</tr>
<tr>
<td class="org-right">134534</td>
<td class="org-left">Sophokles</td>
<td class="org-left">Philosophy</td>
</tr>
<tr>
<td class="org-right">145698</td>
<td class="org-left">Cleopatra</td>
<td class="org-left">Computer Science</td>
</tr>
</tbody>
</table>
<p>
Query: {s | s ∈ Student ∧ s.major='Computer Science'}
</p>

<p>
Result: 
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">matrNr{PK}</th>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">major</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123456</td>
<td class="org-left">Archimedes</td>
<td class="org-left">Computer Science</td>
</tr>
<tr>
<td class="org-right">145698</td>
<td class="org-left">Cleopatra</td>
<td class="org-left">Computer Science</td>
</tr>
</tbody>
</table>
</div>

<ul class="org-ul">
<li>
<a id="orgd35aced"></a>Tuple Calculus - Atoms and Formulas<br><div class="outline-text-5" id="text-orgd35aced">
<p>
For the construction of formula we define sets of atomic formulas.
<b>Atoms</b> in tuple calculus:
</p>
<ul class="org-ul">
<li>t<sub>i</sub> ∈ R<sub>j</sub> → the relation R<sub>j</sub> is assigned as the codomain(Wertebereich) to the tuple variable t<sub>i</sub>
</li>
<li>t<sub>i.A</sub> Θ t<sub>j.B</sub> → comparison operation between two attributes A and B which are attributes of the relations that were assigned as codomains to t<sub>i</sub> and t<sub>j</sub>
</li>
<li>t<sub>i.A</sub> Θ c → comparison operation between attribute A and constant C</li>
<li>c Θ t<sub>i.A</sub> → comparison operation between constant c and attribute A</li>
</ul>
<p>
The comparison operation denoted by Θ encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &lt;, &gt;, ≤, ≥, =, ≠ and =, ≠ for boolean values.
</p>

<p>
Every atom is a <i>formula</i>. When F<sub>1</sub> and F<sub>2</sub> are formulas then the following constructs are formulas as well:
</p>
<ul class="org-ul">
<li>F<sub>1</sub> ∧ F<sub>2</sub> = Conjunction</li>
<li>F<sub>1</sub> ∨ F<sub>2</sub> = Disjunction</li>
<li>¬ F<sub>1</sub>  = Negation</li>
<li>(F<sub>1</sub>) = wrapping (Klammerung)</li>
</ul>
<p>
When F is a formula and t is a tuple variable in F then the following constructs are formulas:
</p>
<ul class="org-ul">
<li>(∃ t)(F) = existential quantifier (Existenzquantifizierung)</li>
<li>(∀ t)(F) = universal quantifier (Universalquantifizierung)</li>
</ul>
</div>
</li>

<li>
<a id="orgfb47392"></a>Tuple Calculus - Free and Bounded Tuple Variables<br><div class="outline-text-5" id="text-orgfb47392">
<p>
A tuple variable in an atom (respective in a formula consisting of one atom) is <b>free</b>.
</p>

<p>
A tuple variable in a formula that is composed via negation, conjunction or disconjuction of other partial formulas is <b>free</b> or <b>bound</b> depending on its state in the other partial formulas. In this case a tuple variable can be free and bound at the same time.
</p>

<p>
<b>Free</b> tuple variables t of a formula F get <b>bound</b> to the respective quantifier F' when they are embedded in one of the following formulas F':
</p>
<ul class="org-ul">
<li>F' = (∃ t)(F)</li>
<li>F' = (∀ t)(F)</li>
</ul>
<p>
Examples:
</p>
<ul class="org-ul">
<li>F<sub>1</sub>: s.name = 'Cleopatra'</li>
<li>F<sub>2</sub>: (∃ t)(s.matrNr = t.matrNr)</li>
<li>F<sub>3</sub>: (∀ s)(s.name = 'Cleopatra')</li>
</ul>
</div>
</li>

<li>
<a id="org60984c5"></a>Tuple Calculus - Computing Formulas (Substitution)<br><div class="outline-text-5" id="text-org60984c5">
<p>
Given that F(s) is a formula with the tuple variable s ∈ R and a tuple t ∈ R. Then the following happens in each atom of F(S) with a <i>free</i> s:
</p>
<ul class="org-ul">
<li>s ∈ R is replaced with true</li>
<li>s.A Θ u.B is replaced with t.A Θ u.B (A and B are atrtibutes, u is another tuple variable u ≠ s)</li>
<li>s.A Θ c is replaced with the concrete boolean value of the operation t.A Θ c</li>
</ul>
<p>
These steps are repeated for further tuple variables if necessary until F(s) only holds (possibly logically connected) boolean constants (true/false) and atoms with bound variables.
</p>

<p>
Example:
Given tuple variable s and t from a schema R(a,b) and the formula ∀ t(t ∈ R ∧ t.a = s.a ∧ t.b &lt; s.b) the substitution happens/looks like this:
</p>
<ul class="org-ul">
<li>the tuple s = (8, 12) → ∀ t(t ∈ R ∧ t.a = 8 ∧ t.b &lt; 12)</li>
<li>then the tuple t = (8, 9) → ∀ t(true ∧ 8 = 8 ∧ 9 &lt; 12) → ∀ t(true ∧ true ∧ true) → ∀ t(true)</li>
</ul>
</div>
</li>

<li>
<a id="orga48ad2d"></a>Tuple Calculus - Computing Formulas for bound Tuple Variables<br><div class="outline-text-5" id="text-orga48ad2d">
<p>
Given a tuple variable s ∈ R:
</p>
<ul class="org-ul">
<li>the formula (∃ t)(F) evaluates to <i>true</i> if F becomes true for at least one substitution of s and the formula evaluates to false otherwise
<ul class="org-ul">
<li>this means that at least one tuple can be associated with the free tuple variable s for which F becomes true</li>
</ul>
</li>
<li>the formular (∀ t)(F) evaluates to <i>true</i> if F becomes true for <i>all</i> substitutions of s
<ul class="org-ul">
<li>this means that F is true/fulfilled for all tuples that can be assigned to the free tuple variable s</li>
</ul>
</li>
</ul>
<p>
<b>Final Formula Computation</b> = formulas now only hold logically connected boolean values which can be evaluated accordingly.
</p>
</div>
</li>

<li>
<a id="orgd659ffd"></a>Tuple Calculus - Expressions and Queries<br><div class="outline-text-5" id="text-orgd659ffd">
<p>
In general an expression/query of the tuple calculus is of the following form: {t<sub>1.A</sub><sub>1</sub>, t<sub>2.A</sub><sub>2</sub>, …, t<sub>n.A</sub><sub>n</sub> | F(t<sub>1</sub>, …, t<sub>m</sub>)}
</p>

<p>
t<sub>i</sub> are tuple variables (which in general encompass all tuples of the so called univesere, that's why they are usually assigned to a relation) and A<sub>i</sub> are attributes of the relation that is assigned to the tuple variable t<sub>i</sub>, while F(t<sub>1</sub>, …, t<sub>m</sub>) is the formula of the tuple calculus.
</p>

<p>
Taking our previous student relation:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">matrNr{PK}</th>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">major</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123456</td>
<td class="org-left">Archimedes</td>
<td class="org-left">Computer Science</td>
</tr>
<tr>
<td class="org-right">134534</td>
<td class="org-left">Sophokles</td>
<td class="org-left">Philosophy</td>
</tr>
<tr>
<td class="org-right">145698</td>
<td class="org-left">Cleopatra</td>
<td class="org-left">Computer Science</td>
</tr>
</tbody>
</table>
<p>
Query: {s.matrNr, s.name | s ∈ Student ∧ s.major='Philosophy'} yields
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">matrNr{PK}</th>
<th scope="col" class="org-left">name</th>
</tr></thead>
<tbody><tr>
<td class="org-right">134534</td>
<td class="org-left">Sophokles</td>
</tr></tbody>
</table>
<hr>
<p>
Now onto another example. Given the relations teacher
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">persNr{PK}</th>
<th scope="col" class="org-left">name</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">3467</td>
<td class="org-left">Ares</td>
</tr>
<tr>
<td class="org-right">6897</td>
<td class="org-left">Zeus</td>
</tr>
<tr>
<td class="org-right">43467</td>
<td class="org-left">Hera</td>
</tr>
</tbody>
</table>
<p>
and lectures
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">number{PK}</th>
<th scope="col" class="org-left">title</th>
<th scope="col" class="org-right">persNr{FK}</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123</td>
<td class="org-left">Data Structures</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">234</td>
<td class="org-left">Databases in Praxis</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">345</td>
<td class="org-left">Database Essentials</td>
<td class="org-right">43467</td>
</tr>
<tr>
<td class="org-right">456</td>
<td class="org-left">Exercise Data Structures</td>
<td class="org-right">6897</td>
</tr>
</tbody>
</table>
<p>
we want to know the names of the teachers that hold at least one lecture:
{t.name | t ∈ Teacher ∧ (∃ l)(l ∈ lectures ∧ t.persNr = l.persNr)} which leads to this resulting relation
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="org-left"></colgroup>
<thead><tr>
<th scope="col" class="org-left">name</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Zeus</td>
</tr>
<tr>
<td class="org-left">Hera</td>
</tr>
</tbody>
</table>
<hr>
<p>
To query the lecture titles of lectures given by Zeus we'd use the following:
{t.title | t ∈ Lectures ∧ (∃ l)(l ∈ teacher ∧ t.persNr = l.persNr ∧ l.name='Zeus') } to get
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="org-left"></colgroup>
<thead><tr>
<th scope="col" class="org-left">title</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Data Structures</td>
</tr>
<tr>
<td class="org-left">Databases in Praxis</td>
</tr>
<tr>
<td class="org-left">Exercise Data Structures</td>
</tr>
</tbody>
</table>
<hr>
<p>
For the next example queries I embed the slides because it is more clearer and not so much overhead.
<img src="../../../images/tuple-calc-ex1.png" alt="nil"><img src="../../../images/tuple-calc-ex2.png" alt="nil"></p>

<p>
One problem with queries of tuple calculus is that they can sometimes produce an infinite result relation, eg { s | ≠(s ∈ Student) }.
</p>

<p>
The domain of a formula contains all constant values of a formula and all possible attribute values of all tuples in the referenced relations.
</p>

<p>
A <b>safe query</b> is a query where the result of the query stems from the domain of the formula → we only use safe queries (all queries we've seen so far are safe).
</p>

<p>
Also see <a href="https://en.wikipedia.org/wiki/Tuple_relational_calculus">https://en.wikipedia.org/wiki/Tuple_relational_calculus</a> for more
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org065eceb" class="outline-3">
<h3 id="org065eceb">Domain Calculus</h3>
<div class="outline-text-3" id="text-org065eceb">
<p>
The domain relational calculus is also a calculus that serves as a declarative database query language for the relational data model. In DRC queries have this form {d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub> | F(d<sub>1</sub>, d<sub>2</sub>, …, d<sub>m</sub>)} with m ≥ n where d<sub>i</sub> are domain variables which describe the values of attribute domains and F(d<sub>1</sub>, d<sub>2</sub>, …, d<sub>m</sub>) is the formula. The formula consists, like in the relational calculus (tuple?), of either a an atom, a logical connection of formulas or a formula with a domain variable which is existential quantified or universal quantified.
</p>
</div>
<ul class="org-ul">
<li>
<a id="org3529dfd"></a>Domain Calculus - Atoms and Comparison<br><div class="outline-text-5" id="text-org3529dfd">
<p>
Given the relation R of degree n where every d<sub>i</sub> is a domain variable, the atom \(R(d_1, d_2, ..., d_n)\) expresses that the codomain (Werteliste) &lt;d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub>&gt; has to be a tuple of the relation R.
</p>

<p>
Comparisons
</p>
<ul class="org-ul">
<li>d<sub>i</sub> θ d<sub>j</sub> → comparison operation between two domain variables d<sub>i</sub> and d<sub>j</sub>
</li>
<li>d<sub>i</sub> θ c → comparison operation between domain variable d<sub>i</sub> and constant c</li>
<li>c θ d<sub>i</sub> → comparison operation between constant c and domain variable d<sub>i</sub>
</li>
</ul>
<p>
The comparison operation denoted by Θ encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &lt;, &gt;, ≤, ≥, =, ≠ and =, ≠ for boolean values (required that the elements of the domain can be compared pairwise).
</p>
</div>
</li>

<li>
<a id="org8e57725"></a>Domain Calculus - Example Queries<br><div class="outline-text-5" id="text-org8e57725">
<p>
Given the relations teacher
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">persNr{PK}</th>
<th scope="col" class="org-left">name</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">43467</td>
<td class="org-left">Ares</td>
</tr>
<tr>
<td class="org-right">6897</td>
<td class="org-left">Zeus</td>
</tr>
<tr>
<td class="org-right">43424</td>
<td class="org-left">Hera</td>
</tr>
</tbody>
</table>
<p>
and lectures
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">number{PK}</th>
<th scope="col" class="org-left">title</th>
<th scope="col" class="org-right">persNr{FK}</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123</td>
<td class="org-left">Data Structures</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">234</td>
<td class="org-left">Databases in Praxis</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">345</td>
<td class="org-left">Database Essentials</td>
<td class="org-right">43467</td>
</tr>
<tr>
<td class="org-right">456</td>
<td class="org-left">Exercise Data Structures</td>
<td class="org-right">6897</td>
</tr>
</tbody>
</table>
<p>
<b>1.)</b> List the lecture titles that are held by teacher with persNr 6897?
</p>
<ul class="org-ul">
<li>The query {b | (∃ a) (∃ c) (Lecture(a,b,c) ∧ c=6897)} yields:</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="org-left"></colgroup>
<thead><tr>
<th scope="col" class="org-left">title</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Data Structures</td>
</tr>
<tr>
<td class="org-left">Databases in Praxis</td>
</tr>
<tr>
<td class="org-left">Exercise Data Structures</td>
</tr>
</tbody>
</table>
<p>
<b>2.)</b> What are the numbers and titles of lectures held by Zeus?
</p>
<ul class="org-ul">
<li>The query {a, b | (∃ c) (∃ d) (∃ e) (Lecture(a,b,c) ∧ teacher(d,e) ∧ c=d ∧ e='Zeus')} yields:</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">number{PK}</th>
<th scope="col" class="org-left">title</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123</td>
<td class="org-left">Data Structures</td>
</tr>
<tr>
<td class="org-right">234</td>
<td class="org-left">Databases in Praxis</td>
</tr>
<tr>
<td class="org-right">456</td>
<td class="org-left">Exercise Data Structures</td>
</tr>
</tbody>
</table>
<p>
<b>3.)</b> What's the title of lectures hold by teacher with persNr6987 with at least 5 Credits?
</p>

<p>
We now have an additional column in our lecture relation:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right">
<col class="org-right">
</colgroup>
<thead><tr>
<th scope="col" class="org-right">number{PK}</th>
<th scope="col" class="org-left">title</th>
<th scope="col" class="org-right">credits</th>
<th scope="col" class="org-right">persNr{FK}</th>
</tr></thead>
<tbody>
<tr>
<td class="org-right">123</td>
<td class="org-left">Data Structures</td>
<td class="org-right">5</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">234</td>
<td class="org-left">Databases in Praxis</td>
<td class="org-right">5</td>
<td class="org-right">6897</td>
</tr>
<tr>
<td class="org-right">345</td>
<td class="org-left">Database Essentials</td>
<td class="org-right">5</td>
<td class="org-right">43467</td>
</tr>
<tr>
<td class="org-right">456</td>
<td class="org-left">Exercise Data Structures</td>
<td class="org-right">2</td>
<td class="org-right">6897</td>
</tr>
</tbody>
</table>
<p>
Alternatively a query can be formulated with a direct specification of constant attribute values: {b | (Lecture(a, b, <i>5</i>, <i>6897</i>))} which yields
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="org-left"></colgroup>
<thead><tr>
<th scope="col" class="org-left">title</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Data Structures</td>
</tr>
<tr>
<td class="org-left">Databases in Praxis</td>
</tr>
</tbody>
</table>
<p>
(slides: alle Variablen, die nicht „links“ auftreten, sind hierbei automatisch existenzquantifiziert)
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org00f3352" class="outline-2">
<h2 id="org00f3352">Relational Languages</h2>
<div class="outline-text-2" id="text-org00f3352">
<p>
The following query languages possess the same expresiveness (Ausdrucksmächtigkeit):
</p>
<ul class="org-ul">
<li>relational algebra</li>
<li>tuple calculus (limited to safe queries)</li>
<li>domain calculus (limited to safe queries)</li>
</ul>
<p>
Queries can be converted between those languages at any time.
</p>

<p>
In praxis the <b>relational calculus</b> is the foundation for "real" query languages of relational DBMS:
</p>
<ul class="org-ul">
<li>tuple calculus is the foundation of SQL (Structured Query Language)</li>
<li>domain calculus is the foundation of QBE (Query By Example)</li>
</ul>
<p>
<b>Relational algebgra</b> is the foundation for the realisation of queries in the query languages. The sequence of operations describes the path to the result of a query (which can be optimized in some circumstances).
</p>
</div>
</div>

<div id="outline-container-org805185e" class="outline-2">
<h2 id="org805185e">Introduction to SQL</h2>
<div class="outline-text-2" id="text-org805185e">
</div>
<div id="outline-container-orge8aa45d" class="outline-4">
<h4 id="orge8aa45d">History</h4>
<div class="outline-text-4" id="text-orge8aa45d">
<ul class="org-ul">
<li>1970: Codd presents the relational model</li>
<li>1974: development of the relational query language SEQUEL (Structured English Query Language)</li>
<li>1976: further development (Weiterentwicklung) of SEQUEL served as a foundation of the DBMS prototype "System R" by IBM, which was later renamed to SQL (Structured Query Language)</li>
<li>in the early 80s: a lot of DBMS emerge by different commercial providers → standardization is needed</li>
<li>1987: first SQL Standard</li>
<li>1992: big expansion of the standard → SQL 2 (SQL-92)</li>
<li>since then continuous evolution: SQL-99 → SQL:2003 → SQL:2006 → SQL:2008 → SQL:2011</li>
</ul>
</div>
</div>

<div id="outline-container-org655834a" class="outline-4">
<h4 id="org655834a">Introduction to SQL - Components</h4>
<div class="outline-text-4" id="text-org655834a">
<p>
There two high level components of SQL:
</p>

<p>
<b>Data Definition Language (DDL)</b>
</p>
<ul class="org-ul">
<li>defines the database structure</li>
<li>manages the access rights to the data</li>
</ul>
<p>
and 
</p>

<p>
<b>Data Manipulation Language (DML)</b>
</p>
<ul class="org-ul">
<li>used to formulate queries for the data sets</li>
<li>create, read, update, delete of data</li>
</ul>
<p>
For now we'll focus on the Data Manipulation Language.
</p>

<p>
SQL does not operate on relations, but rather their physical representation form which are <b>tables</b>. In tables duplicate entries are possible which we may have to exclude. In contrast to relations there is one more advantage to table which is that they can be sorted.
</p>
</div>
</div>

<div id="outline-container-org0310734" class="outline-4">
<h4 id="org0310734">Introduction to SQL - Queries</h4>
<div class="outline-text-4" id="text-org0310734">
<p>
All queries to a database in SQL are realized via the <code>select</code> statement.
This is the general construction:
</p>
<ul class="org-ul">
<li>
<code>select</code> <code>attribute|expression</code> → which attributes should the result table contain?</li>
<li>
<code>from</code> <code>list of tables</code> → which tables are required for the query?</li>
<li>[ <code>where</code>  <code>condition</code> ] → which conditions should the result tuples fulfill?</li>
<li>[ <code>group by</code>  <code>list of attributes</code> ] → summarize/condense identical attribute values</li>
<li>[ <code>having</code>  <code>condition</code> ] → condition in regards to grouped tables</li>
<li>
<p>
[ <code>order by</code>  <code>sort</code> ] → specification of sorting for the resulting table
</p>

<p>
Now let's look at some simple example queries (mostly π projection and \roh rename at one point):
</p>
</li>
</ul>
<p>
I insert the slides here because they are visually more appealing/clear :D
</p>

<p>
Three simple queries:
<img src="../../../images/simple-sql-1.png" alt="nil"><img src="../../../images/simple-sql-2.png" alt="nil"><img src="../../../images/simple-sql-3.png" alt="nil"></p>

<p>
Sorting:
<img src="../../../images/simple-sql-4.png" alt="nil"><img src="../../../images/simple-sql-5.png" alt="nil"></p>

<p>
Simple query with <i>distinct</i>
<img src="../../../images/simple-sql-6.png" alt="nil"></p>
</div>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="knowledge-database",
            disqus_url="https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-05/",
        disqus_title="Database Essentials - Lecture 05",
        disqus_identifier="cache/posts/database_essentials/05-lecture.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2018         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
