<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Computer Science I - Lecture 05 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-05/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Computer Science I - Lecture 05">
<meta property="og:url" content="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-05/">
<meta property="og:description" content="A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier.
It is possible to do type definitio">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-11-09T00:00:00+01:00">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://schoettkr.github.io/knowledge-database/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
<form method="get" action="https://www.google.com/search" class="navbar-form navbar-right" role="search">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search">
</div>
  <button type="submit" class="btn btn-primary">
    <span class="glyphicon glyphicon-search"></span>
  </button>
  <input type="hidden" name="sitesearch" value="https://schoettkr.github.io/knowledge-database/">
</form>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Computer Science I - Lecture 05
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-11-09T00:00:00+01:00">2018/11/09</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <p>
A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier.
It is possible to do type definitions via the following syntax <code>typedef TYP typename;</code>, eg <code>typedef unsigned short ushort;</code>
</p>

<div id="outline-container-org94ab293" class="outline-2">
<h2 id="org94ab293">Enumerated Type</h2>
<div class="outline-text-2" id="text-org94ab293">
<p>
Enumerated types are types that are defined with a set of custom identifiers, known as enumerators, as possible values. Objects of these enumerated types can take any of these enumerators as value.
</p>

<p>
Their syntax is:
</p>

<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">type_name</span> <span class="p">{</span>
  <span class="n">value1</span><span class="p">,</span>
  <span class="n">value2</span><span class="p">,</span>
  <span class="n">value3</span><span class="p">,</span>
  <span class="p">.</span>
  <span class="p">.</span>
<span class="p">}</span> <span class="n">object_names</span><span class="p">;</span>
</pre></div>

<p>
This creates the type <code>type_name</code>, which can take any of <code>value1</code>, <code>value2</code>, <code>value3</code>, … as value. Objects (variables) of this type can directly be instantiated as <code>object_names</code>.
</p>

<p>
Notice that this declaration includes no other type, neither fundamental nor compound, in its definition. To say it another way, somehow, this creates a whole new data type from scratch without basing it on any other existing type. The possible values that variables of this new type <code>color_t</code> may take are the enumerators listed within braces. For example, once the <code>colors_t</code> enumerated type is declared, the following expressions will be valid:
</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="n">colors_t</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">}</span> <span class="n">testColor</span> <span class="o">=</span> <span class="n">green</span><span class="p">,</span> <span class="n">yourFavColor</span> <span class="o">=</span> <span class="n">blue</span><span class="p">;</span>

  <span class="n">colors_t</span> <span class="n">myFavColor</span><span class="p">;</span>
  <span class="n">myFavColor</span> <span class="o">=</span> <span class="n">blue</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">testColor</span> <span class="o">==</span> <span class="n">green</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// green is equivalent to 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"'testColor is "</span> <span class="o">&lt;&lt;</span> <span class="n">green</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">myFavColor</span> <span class="o">==</span> <span class="n">yourFavColor</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hey we have the same favorite colors :D"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre class="example">
'testColor is 1
Hey we have the same favorite colors :D

</pre>

<p>
Values of enumerated types declared with <code>enum</code> are implicitly convertible to an integer type, and vice versa. In fact, the elements of such an enum are always assigned an integer numerical equivalent internally, to which they can be implicitly converted to or from. If it is not specified otherwise, the integer value equivalent to the first possible value is <code>0</code>, the equivalent to the second is <code>1</code>, to the third is <code>2</code>, and so on… Therefore, in the data type <code>colors_t</code> defined above, <code>red</code> would be equivalent to <code>0</code>, <code>green</code> would be equivalent to <code>1</code>, blue to <code>2</code>, and so on…
</p>
</div>
</div>

<div id="outline-container-orgb3b4ad8" class="outline-2">
<h2 id="orgb3b4ad8">Arrays</h2>
<div class="outline-text-2" id="text-orgb3b4ad8">
<p>
An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.
</p>

<p>
That means that, for example, five values of type int can be declared as an array without having to declare 5 different variables (each with its own identifier). Instead, using an array, the five int values are stored in contiguous memory locations, and all five can be accessed using the same identifier, with the proper index.
</p>

<p>
A typical declaration for an array in C++ is <code>type name [elements num];</code> where <code>type</code> is a valid type (such as int, float…), <code>name</code> is a valid identifier and the <code>elements num</code> (which is always enclosed in square brackets <code>[]</code>), specifies the length of the array in terms of the number of elements.
</p>

<p>
Therefore, the <code>foo</code> array, with five elements of type <code>int</code>, can be declared as: <code>int foo [5];</code>
</p>

<p>
NOTE: The number of elements within square brackets <code>[]</code>, representing the number of elements in the array, must be a <i>constant expression</i>, since arrays are blocks of static memory whose size must be determined at compile time, before the program runs.
</p>

<p>
Elements in an array can be explicitly initialized to specific values when it is declared, by enclosing those initial values in braces <code>{}</code>. For example:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">foo</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">12071</span> <span class="p">};</span> 
</pre></div>
<p>
The number of values between braces <code>{}</code> shall not be greater than the number of elements in the array. For example, in the example above, <code>foo</code> was declared having 5 elements (as specified by the number enclosed in square brackets, []), and the braces {} contained exactly 5 values, one for each element. If declared with less, the remaining elements are set to their default values (which for fundamental types, means they are filled with zeroes). For example:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">bar</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span> 
</pre></div>
<p>
Results in bar consisting of <code>10, 20, 30, 0, 0</code>.
</p>

<p>
The initializer can even have no values, just the braces <code>int baz[5] = { };</code>.
This creates an array of five int values, each initialized with a value of zero:
</p>

<p>
When omitting the initialization completely by default, regular arrays of <i>local scope</i> (for example, those declared within a function) are left uninitialized. This means that none of its elements are set to any particular value; their contents are undetermined at the point the array is declared.
</p>

<p>
Static arrays, and those declared directly in a namespace (outside any function), are always initialized. If no explicit initializer is specified, all the elements are default-initialized (with zeroes, for fundamental types)
</p>

<p>
When an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets empty <code>[]</code>. In this case, the compiler will assume automatically a size for the array that matches the number of values included between the braces <code>{}</code>:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">12071</span> <span class="p">};</span>
</pre></div>

<p>
To access array values one uses the bracket notation:
</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">12071</span> <span class="p">};</span>
<span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// -&gt; 16</span>
<span class="n">foo</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="c1">// -&gt; 12071</span>
</pre></div>

<p>
Char arrays are somewhat a special case. There are multiple equivalent ways to define char arrays:
</p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">};</span>
<span class="kt">char</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span> <span class="c1">// 6 because of delimiting 0</span>
<span class="kt">char</span> <span class="n">greeting</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
</pre></div>

<p>
Functions to work with such strings in C++ are provided via the header file <code>&lt;cstring&gt;</code>
</p>
<ul class="org-ul">
<li>find out length via <code>int strlen(char *s)</code>
</li>
<li>comparison via <code>int strcmp(char *s1, char *s2)</code>
<ul class="org-ul">
<li>returns 0 for "equal" strings (equal string content)</li>
<li>returns &lt; 0 when <code>s1</code> is &lt; than <code>s2</code> eg s1 holds "a" which in ascii is smaller than "b" so <code>strcmp</code> would return <code>-1</code> because that is the difference</li>
<li>returns &gt; 0 when <code>s1</code> is &gt; than <code>s2</code> eg <code>s1</code> holds "c" and <code>s2</code> holds "a" then <code>strcmp</code> returns <code>2</code> because that is the ascii distance</li>
</ul>
</li>
<li>copy strings with <code>char * strcpy(char *destination, char *source)</code> and <code>char * strcat(char *destination, char *source)</code>
<ul class="org-ul">
<li>
<code>strcpy()</code> copies a string from source to destination. The function takes two string variables as arguments: the destination, and the source, then returns the updated destination variable.</li>
<li>
<code>strcat()</code> concatenates two strings. It appends a copy of the source string to the end of the destination string, and then returns the destination string.</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org283cc6e" class="outline-2">
<h2 id="org283cc6e">Struct</h2>
<div class="outline-text-2" id="text-org283cc6e">
<p>
A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps). There are many instances in programming where we need more than one variable in order to represent an object. For example, to represent yourself, you might want to store your name, your birthday, your height, your weight, or any other number of characteristics about yourself.
</p>

<p>
Fortunately, C++ allows us to create our own user-defined aggregate data types. An <i>aggregate data type</i> is a data type that groups multiple individual variables together. One of the simplest aggregate data types is the struct. A <b>struct</b> (short for structure) allows us to group variables of mixed data types together into a single unit.
</p>

<p>
Because structs are user-defined, we first have to tell the compiler what our struct looks like before we can begin using it. To do this, we declare our struct using the <code>struct</code> keyword. Here is an example of a struct declaration:
</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Employee</span>
<span class="p">{</span>
    <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">wage</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
This tells the compiler that we are defining a struct named Employee. The Employee struct contains 3 variables inside of it: a short named <code>id</code>, an int named <code>age</code>, and a double named <code>wage</code>. These variables that are part of the struct are called members (or fields). Keep in mind that Employee is just a declaration – even though we are telling the compiler that the struct will have member variables, no memory is allocated at this time. By convention, struct names start with a capital letter to distinguish them from variable names.
</p>

<p>
In order to use the Employee struct, we simply declare a variable of type Employee <code>Employee john;</code> . This defines a variable of type <code>Employee</code> named <code>john</code>. As with normal variables, defining a struct variable allocates memory for that variable.
</p>

<p>
When we define a variable such as <code>Employee john</code>, <code>john</code> refers to the entire struct (which contains the member variables). In order to access the individual members, we use the member selection operator <code>.</code> (which is a period). Here is an example of using the member selection operator to initialize each member variable:
</p>
<div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="n">john</span><span class="p">;</span> <span class="c1">// create an Employee struct for John</span>
<span class="n">john</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span> <span class="c1">// assign a value to member id within struct john</span>
<span class="n">john</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="c1">// assign a value to member age within struct john</span>
<span class="n">john</span><span class="p">.</span><span class="n">wage</span> <span class="o">=</span> <span class="mf">24.15</span><span class="p">;</span> <span class="c1">// assign a value to member wage within struct john</span>
</pre></div>
<p>
As with normal variables, struct member variables are not initialized, and will typically contain junk. We must initialize them manually.
</p>

<p>
Initializing structs by assigning values member by member is a little cumbersome, so C++ supports a faster way to initialize structs using an initializer list. This allows you to initialize some or all the members of a struct at declaration time.
</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Employee</span>
<span class="p">{</span>
    <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">wage</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Employee</span> <span class="n">john</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mf">60000.0</span> <span class="p">};</span> <span class="c1">// john.id = 1, john.age = 32, john.wage = 60000.0</span>
<span class="n">Employee</span> <span class="n">frank</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span> <span class="p">};</span> <span class="c1">// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)</span>
</pre></div>
<p>
If the initializer list does not contain an initializer for some elements, those elements are initialized to a default value (that generally corresponds to the zero state for that type). In the above example, we see that frank.wage gets default initialized to 0.0 because we did not specify an explicit initialization value for it.
</p>

<hr>
<p>
Source(s): <a href="https://www.learncpp.com/cpp-tutorial/47-structs/">https://www.learncpp.com/cpp-tutorial/47-structs/</a>
</p>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="knowledge-database",
            disqus_url="https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-05/",
        disqus_title="Computer Science I - Lecture 05",
        disqus_identifier="cache/posts/computer_science_I/05-lecture.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
