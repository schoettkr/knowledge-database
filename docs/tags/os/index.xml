<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>os on schoettkr</title>
    <link>https://schoettkr.github.io/knowledge-database/tags/os/</link>
    <description>Recent content in os on schoettkr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 May 2019 10:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://schoettkr.github.io/knowledge-database/tags/os/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Operating Systems - Address Mapping</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</link>
      <pubDate>Wed, 08 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</guid>
      <description>Intro Primary memory (RAM) is constituted via adress spaces
 address space = a range of discrete memory addresses logical address space = address(es) generated by a CPU and seen by programs physical address space = address(es) that are seen by the memory unit and used to access memory units  The physical and the logical/virtual address space (and virtual address spaces between each other) may differ in regards to their size and structure.</description>
    </item>
    
    <item>
      <title>Operating Systems - Linear Memory Model</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</link>
      <pubDate>Wed, 01 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</guid>
      <description>Intro When a program is executed the instruction are present in memory/storage and then the CPU loads those instructions and executes them (program counter, Assembler). Hardware is able to deal with absolute (direct) and relative adressing modes.
 absolute (direct) addressing = memory locations of operands are specified as a whole and completely relative addressing = memory locations are specified relative to the current PC (program counter) via on offset that is added to the address of the next instruction  Address Space Primary memory (RAM) is constituted via adress spaces</description>
    </item>
    
    <item>
      <title>Operating Systems - Scheduling</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</link>
      <pubDate>Thu, 25 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</guid>
      <description>Introduction A &amp;ldquo;process&amp;rdquo; is a concept of virtualization of the hardware resource CPU. There&amp;rsquo;s a strategy to decide which process is allowed to use the CPU at what time and there&amp;rsquo;s a mechanism which refers to the way the strategy is carried out. Dispatching as the mechanism is what we covered in the last lecture. In this lecture we take a look at the strategy.
Generally scheduling means the temporal assignment (zeitliche Zuordnung) of activities to ressources in regards.</description>
    </item>
    
    <item>
      <title>Operating Systems - Processes</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</link>
      <pubDate>Thu, 11 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</guid>
      <description>The term process serves as an abstraction for the cooporation between CPU, OS, resources and programs. There are different definitions in the literature tho:
 unit of an activity from the OS / programmers view executing instance of a program unit of protection (virtual) adress space collection of resources  Wiki: A process is the instance of a computer program that is being executed. It contains the program code and its activity.</description>
    </item>
    
    <item>
      <title>Operating Systems - Operating System Design</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</guid>
      <description>Complex systems consist of single component. Therefore the successfull design of a complex system requires knowledge about the variants and relations of the components.
There are some fundamental, reoccuring concepts when it comes to operating systems:
 virtualization  refers to the act of creating a virtual (rather than actual) version of something, including virtual computer hardware platforms, storage devices, and computer network resources the things &amp;ldquo;created&amp;rdquo; by virtualizing often don&amp;rsquo;t exist (or not the required amount or in the quality) for example relevant for processes, memory space  concurrency  ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome allows for parallel execution of the concurrent units, which can significantly improve overall speed of the execution in multi-processor and multi-core systems allows execution without a linear order for example relevant for threads, IPC, resource management  persistence  refers to the characteristic of state that outlives the process that created it achieved in practice by storing the state as data in computer data storage for example relevant for file systems, files, nonvolatile (persistent) storage   This course will mainly deal with virtualization and concurrency since persistence is a subject of the database modules.</description>
    </item>
    
    <item>
      <title>Operating Systems - Introduction</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</guid>
      <description>Although Operating Systems depend on the underlying hardware, there general principles that are common across different operating systems and this is the topic of this course. There are two different ways to &amp;ldquo;view&amp;rdquo; an operating system (2 Sichten):
 Top Down View (OS as a virtual machine)  offers an abstract view on the hardware real hardware characteristics are sort of hidden take for example the harddrive and the file system:  real machine (hardware): a sequence of data blocks of fixed size virtual machine: named files of variable size   Bottom Up View (OS as a resource manager)  OS coordinates the access on CPU, Memory, Storage etc.</description>
    </item>
    
  </channel>
</rss>