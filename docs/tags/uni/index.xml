<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>uni on schoettkr</title>
    <link>https://schoettkr.github.io/knowledge-database/tags/uni/</link>
    <description>Recent content in uni on schoettkr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 May 2019 10:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://schoettkr.github.io/knowledge-database/tags/uni/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Operating Systems - Coordination</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/09_lecture/</link>
      <pubDate>Wed, 29 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/09_lecture/</guid>
      <description>Introduction In the last chapter we looked at communication and cooperation to exchange information/data between processes. In this chapter we take a look at the timely aspect &amp;rarr; coordination which is also often called synchronization. We focus on coordination between processes as we&amp;rsquo;ve already kind of covered coordination in the kernel via suspension etc.
Elementary Coordination Many coordination problems can be solved with a uniform concept &amp;rarr; signaling:
 signaling uses signals to create a sequence relationship (Reihenfolgebeziehung) ATTENTION: this has nothing to do with UNIX-signals!</description>
    </item>
    
    <item>
      <title>Operating Systems - Interprocess Communication</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/08_lecture/</link>
      <pubDate>Wed, 22 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/08_lecture/</guid>
      <description>Introduction Processes are usually a part of more complex systems. Therefore they sometimes have to exchange data between each other (inter process communication, IPC). Operations to achieve inter process communication are besides process management one of the major tasks of an OS kernel.
There&amp;rsquo;s a functional and a timely aspect when it comes to inter process communication. In this chapter we will cover the functional aspect and the timely aspect will be covered in the next chapter.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/08_lecture/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/08_lecture/</guid>
      <description>Internet Firewalls (Chapter 6) Definition: Firewalls are hard- or software components, which control the interconnection point between two network areas and implement security strategies by restricting packet forwarding.
Fundamentals:
 Packet filter  entity, which selectively processes flowing packets according to predefined rules, in particular, preventing packet forwarding  Proxy approaches  representative of a client process  Network Address Translation (NAT)  address translation, public and private addresses are distinguished  Bastion Host  computer with particularly high protection requirements; vulnerability mainly results from the computer&amp;rsquo;s exposed location  Dual-Homed Host  computer with at least two network interfaces for two different subnets   These approaches are now covered in more detail.</description>
    </item>
    
    <item>
      <title>Operating Systems - Efficient Memory Management</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/07_lecture/</link>
      <pubDate>Wed, 15 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/07_lecture/</guid>
      <description>Virtualization and Caching Hierarchy of storages:
 in this chapter we deal with the interaction of these hierarchies  Locality of reference (Lokalitaetsprinzip) The storage hierarchy is based on the principle of locality. The principle of locality states that only a small part of the address space \(A\) is accessed in small intervalls \(\delta t\) and that there is a tendency of a processor to access the same set of memory locations repetitively over a short period of time.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/07_lecture/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/07_lecture/</guid>
      <description>Management of Access Rights Authorization is the process of verification and access right assignment for a resource/service to a subject and is not to be confused with Authentication which is the process of verificating claimed properties. Access Control is a process of access rights management and control.
Access Matrix
 group- and role-based access rights management:  complexity reduction by clustering users into &amp;lsquo;role groups&amp;rsquo; inheritance relationships in rights management permissions based on roles   Access Control Lists</description>
    </item>
    
    <item>
      <title>Operating Systems - Address Mapping</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</link>
      <pubDate>Wed, 08 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</guid>
      <description>Intro Primary memory (RAM) is constituted via adress spaces
 address space = a range of discrete memory addresses logical address space = address(es) generated by a CPU and seen by programs physical address space = address(es) that are seen by the memory unit and used to access memory units  The physical and the logical/virtual address space (and virtual address spaces between each other) may differ in regards to their size and structure.</description>
    </item>
    
    <item>
      <title>Computer Networks - Chapter 04 Netz-Zugang</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/chapter-04/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/chapter-04/</guid>
      <description>DLC-Protokolle: Uebersicht
Data Link Control
 asynchrone Uebertragung  Uebertragung nicht innerhalb eines groesseren Uebertragungsrahmen, sondern zeichenweiser Start-Stop-Betrieb (Telexdienst)  synchrone Uebertragung  zeichenorientiert = kleinste Uebertragungseinheit ist ein Zeichen, zB 8 Bit  zB PPP  bitorientiert = kleinste Uebertragungseinheit ist 1 Bit  zB HDLDC, LLC (LAN), LAPD (ISDN)    4.1 Synchronisation Asynchrone Uebertragung (zeichenweiser Start/Stop Betrieb)
 setzt Ruhepegel und feste Zahl von Nutzschritten voraus 3 aus 11 Overhead (8 Nutzbitz bei 11 zu uebertragenen Bits)  Synchrone Uebertragung (Blocksynchronisation)</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/05-lecture/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/05-lecture/</guid>
      <description>Modems Modem = MOdulator/DEmodulator
 basieren urspruenglich uaf der klassischen Teilnehmeranschlussleitung des Fernsprechnetzes     Leistungsanschaltung = signaltechnische (Sende- und Empfangs-) Verstaerkung der zu uebertragenen Signale Modulationsteil = Modulation/Demodulation (zB Amplitude, Frequenz, &amp;hellip;)  Modulation beschreibt einen Vorgang, bei dem ein zu uebertragendes Nutzsignal einen sog. Traeger veraendert (moduliert), dadurch wird eine hochfrequente Uebertragung des niederfrequenten Nutzsignals ermoeglicht die Nachricht wird empfangsseitig durch einen Demodulator zurueck gewonnen, beispielsweise um ein Audiosignal in UKW-Empfaengern aus dem hochfrequenten, frequenzmodulierten Signal (87,5-108 MHz) zurueckzugewinnen (Radio)  Steuer-/Meldeteil = Analyse der vom Netz kommenden Dienstsignale, An-/Abschaltung des Modems an Steuerfunktionen (zB Betriebs-, Sendebereitschaft)  Mehrfachnutzung von Medien Multiplexverfahren (lat.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/06_lecture/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/06_lecture/</guid>
      <description>Authentication Introduction Authentication is the process of verficating if someone is the one who he claims to be. There are different kinds of authenticators:
 knowledge-based  PIN, passwords Challenge-Response  biometrics  fingerprint, iris, voice, signature, keystroke behavior  ownership-based  something that you do not notice, but what is stored on a medium IDs, magnetic cards, certificates, smart cards  multi-factor authentication  combination of different types of authentication 2 Factors: eg deposit card + PIN, credit card + signature, password + PIN sent by SMS 3 Factors: eg password + smart card + fingerprint   Knowledge-based Authentication Knowledge-based Authentication using passwords</description>
    </item>
    
    <item>
      <title>Operating Systems - Linear Memory Model</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</link>
      <pubDate>Wed, 01 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</guid>
      <description>Intro When a program is executed the instruction are present in memory/storage and then the CPU loads those instructions and executes them (program counter, Assembler). Hardware is able to deal with absolute (direct) and relative adressing modes.
 absolute (direct) addressing = memory locations of operands are specified as a whole and completely relative addressing = memory locations are specified relative to the current PC (program counter) via on offset that is added to the address of the next instruction  Address Space Primary memory (RAM) is constituted via adress spaces</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/04_lecture/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/04_lecture/</guid>
      <description>Signals and Bit Transmission Introduction Data Transmission - Bit to Signal to Bit:
 sits directly on the physical medium (eg cable) Layer 1 in the ISO/OSI and Internet Reference (TCP/IP) Model transmission of unstructured bit sequences via physical medium data transmission entails the physical connection and the conversion between data &amp;lt;-&amp;gt; signals there are norms for interfaces (especially for physical interfaces)  Signals and their Parameters A signal is a state or a modification of material systems.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/05_lecture/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/05_lecture/</guid>
      <description>SSL/TLS Wiki: Transport Layer Security (TLS), and its now-deprecated predecessor, Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. Several versions of the protocols find widespread use in applications such as web browsing, email, instant messaging, and voice over IP (VoIP). Websites can use TLS to secure all communications between their servers and web browsers.
The TLS protocol aims primarily to provide privacy and data integrity between two or more communicating computer applications.</description>
    </item>
    
    <item>
      <title>Operating Systems - Scheduling</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</link>
      <pubDate>Thu, 25 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</guid>
      <description>Introduction A &amp;ldquo;process&amp;rdquo; is a concept of virtualization of the hardware resource CPU. There&amp;rsquo;s a strategy to decide which process is allowed to use the CPU at what time and there&amp;rsquo;s a mechanism which refers to the way the strategy is carried out. Dispatching as the mechanism is what we covered in the last lecture. In this lecture we take a look at the strategy.
Generally scheduling means the temporal assignment (zeitliche Zuordnung) of activities to ressources in regards.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/04_lecture/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/04_lecture/</guid>
      <description>Not so much related to rest of lecture:
OWASP The Open Web Application Security Project is a worldwide not-for-profit charitable organization focusing on improving the security of software, which issues software tools and knowledge-based documentation on application security
Security Mechanisms for Distributed Software Cryptography Cryptography is a broad field, which is only briefly touched in this lecture. The methods we&amp;rsquo;ll use in this lecure are:
 one key (symmetric algorithms)     both participants use the same key (for de- and encryption) the key therefore has to be transmitted aswell (risk)  two keys (asymmetric algorithms)     a public key is used to encrypt a message which can only be decrypted with the according private key &amp;rarr; private key is not submitted (thus more secure)  hybrid methods     session key is encrypted with public key and transmitted and then gets decrypted with private key session key is used to encrypt data/message and now the receiver can decrypt it with the earlier decrypted session key  one-way hash functions  compression  inputs of arbitrary length are mapped to outputs with fixed length  irreversibility (surjective function)  input can not be inferred from the output  collision-resistant  a hash function \(h()\) is called collision resistant - if it is hard to find to find two inputs \(a\) and \(b\) such that \(h(a)=h(b)\) and \(a \neq b\)    Public key cryptography visualized</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/03_lecture/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/03_lecture/</guid>
      <description>Basic model of (tele)communication    participants act either as a sender or receiver usage of the service occurs at a special interface (API) and by using a service address point the medium bridges the spatial (raeumlich) distance  The following image shows a layer model which shows the reduction of deficits from bottom to top:
There are certain principles to structure communication. These principles are also called communication protocols or short protocols and define a set of rules which communication between two or more parties has to follow/obey.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/03_lecture/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/03_lecture/</guid>
      <description>Attacks on End Systems Attacks on end systems via
 computer viruses computer worms trojan horses exploits cracking systems  might focus on
 unsecured computer systems exploiting programming errors bad security measures weak passwords  Computer Virus
 based on biological model infects resources of the host system to replicate itself malicious functions  load generation data corruption spying  various types  boot sector viruses file viruses macro viruses script viruses composites  self-defense mechanisms of viruses:  stealth modification cryptographic methods polymorphism retroviruses (against anti-virus programs)  passive distribution: by embedding into other programs and execution by the host system  Computer Worm</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/04_lecture/</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/04_lecture/</guid>
      <description>Efficient Sorting Algorithms 1. Quicksort For applying the quicksort sorting algorithm we first choose a (random) pivot element (Drehpunkt/Mittelpunkt/Achse). The array gets partitioned into two virtual arrays. Virtual in this case means that the original array and the allocated memory for the original array is used for virtual subarrays. The first &amp;ldquo;subarray&amp;rdquo; holds all elements which are less than or equal to the pivot element, the other &amp;ldquo;subarray&amp;rdquo; holds all elements which are greater than or equal to the pivot element.</description>
    </item>
    
    <item>
      <title>Operating Systems - Processes</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</link>
      <pubDate>Thu, 11 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</guid>
      <description>The term process serves as an abstraction for the cooporation between CPU, OS, resources and programs. There are different definitions in the literature tho:
 unit of an activity from the OS / programmers view executing instance of a program unit of protection (virtual) adress space collection of resources  Wiki: A process is the instance of a computer program that is being executed. It contains the program code and its activity.</description>
    </item>
    
    <item>
      <title>Computer Science II - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs2/02-lecture/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs2/02-lecture/</guid>
      <description>After repeating some pointer basics in the last lecture, we continued with some more pointer stuff in this lecture and also introduced C++ references.
Pointer to Functions What follows is an example that let&amp;rsquo;s the user choose a function which shall be executed (late binding, dynamic binding)
#include &amp;lt;iostream&amp;gt; using namespace std; int max(int x, int y) { return x &amp;gt; y ? x : y; // ternary operator } int min(int x, int y) { return x &amp;lt; y ?</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/03_lecture/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/03_lecture/</guid>
      <description>Simple Sorting Algorithms In this lecture we&amp;rsquo;re looking at simple array sorting algorithms. There are multiple criteria for judging an (sorting) algorithm:
 performance  amount of comparison operations amount of data shifts (Datenverschiebungen) we neglect unimportant details and only count comparison and shifts of the data that we want to sort  data distribution  some of the algorithms differ in their efficiency in regards to how the data is sorted beforehand we distinguish between data that is already sorted (best case), data that is inversly sorted (worst case) and data that is unsorted (average case)  decomposability (Zerlegbarkeit)  is the sorting algorithm suitable for external sorting?</description>
    </item>
    
    <item>
      <title>Databases &amp; Webtechnology - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/dbw/02_lecture/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/dbw/02_lecture/</guid>
      <description>Client Webtechnology In the last lecture we looked at different kinds of server-side webtechnology. In this lecture we turn our attention to client-side webtechnology.
1. Persistent Code 1.1 External applications / Tools (Hilfsprogramme) External tools enable the display of non-HTML data / files and is (analogous to CGI on server-side) independant of the client process. External tools/application are full standalone programs that are called by the browser (client) to display data that&amp;rsquo;s not HTML.</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/02_lecture/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/02_lecture/</guid>
      <description>Back to the roots of the Internet
The internet consists of
 a set of computers which  use the same network protocol (TCP/IP) are somehow (directly or indirectly) connected to each other offer or use certain services  a set of (human or technical) users which access and use services and a set of further networks accessible via gateways  The most commonly used Internet services are:
 World Wide Web (www)  platform for hypermedial information exchange based on the Hypertext Transfer Protocol (HTTP)  Email  exchange of multimedial messages based on the Simple Mail Transfer Protocol (SMTP)  File Exchange  access and transmission of files based on File Transfer Protocol (FTP)  Network Management  surveillance and control of connected systems based on Simple Network Management Protocol (SNMP)   Model of a simple transmission system:</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/02_lecture/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/02_lecture/</guid>
      <description>We can achieve the security goals mentioned in the previours lecture by:
 information encryption implementation of authentication establishment of security activities monitoring of the system or the network in terms of attacks continous reduction of weak spots etc    In the data transfer model (2 users communicating) we can distinguish for example two types of attackers:
 passive attacker  can only listen, not manipulate confidentiality threat  active attacker  can listen, change, delete, duplicate threat for confidentiality, integrity and authenticity   The difference between authenticity and liability lays in the focus between internal and external relationships.</description>
    </item>
    
    <item>
      <title>Artificial Intelligence - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ai/01_lecture/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ai/01_lecture/</guid>
      <description>Not much to write about this lecture since it was mostly an introduction and generic overview of the field. The lecturant was also half an hour late so that didn&amp;rsquo;t help either. There won&amp;rsquo;t be posts about this course if the input does not increase :P</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/02_lecture/</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/02_lecture/</guid>
      <description>Continuing the repetition of some Algorithm lectures we went over pointers again.
int* pi; // pointer to int value (undefined) char** ppc; // pointer to char pointer (= pointer that points to a pointer pointing to a char :D) int i = 1; pi = &amp;amp;i; // assign address of i to pi int x = 1, y; int* px = &amp;amp;x; // pointer to x int** ppx = &amp;amp;px; // pointer to pointer of x **ppx = *px + 1; // double deferencing via &#39;**&#39;, equals x = x + 1 y = **ppx + 2; // double deferencing via &#39;**&#39;, equals y = x + 2  Now onto some new stuff!</description>
    </item>
    
    <item>
      <title>Operating Systems - Operating System Design</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</guid>
      <description>Complex systems consist of single component. Therefore the successfull design of a complex system requires knowledge about the variants and relations of the components.
There are some fundamental, reoccuring concepts when it comes to operating systems:
 virtualization  refers to the act of creating a virtual (rather than actual) version of something, including virtual computer hardware platforms, storage devices, and computer network resources the things &amp;ldquo;created&amp;rdquo; by virtualizing often don&amp;rsquo;t exist (or not the required amount or in the quality) for example relevant for processes, memory space  concurrency  ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome allows for parallel execution of the concurrent units, which can significantly improve overall speed of the execution in multi-processor and multi-core systems allows execution without a linear order for example relevant for threads, IPC, resource management  persistence  refers to the characteristic of state that outlives the process that created it achieved in practice by storing the state as data in computer data storage for example relevant for file systems, files, nonvolatile (persistent) storage   This course will mainly deal with virtualization and concurrency since persistence is a subject of the database modules.</description>
    </item>
    
    <item>
      <title>Computer Science II - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs2/01-lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs2/01-lecture/</guid>
      <description>Computer Science II basically continues where CS I left off. Both lectures are based on a script that is split into two parts. These weeks lecture introduced pointers. Therefore I&amp;rsquo;ll keep it short because there already a lot of posts for lectures regarding pointers on this page :) and at this point is not really a new or special topic.
Pointers Every variable has a memory adress. In case of arrays the base adress of the variable points to the beginning of an array eg the &amp;amp;a is the same adress as &amp;amp;a[0].</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/01_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/01_lecture/</guid>
      <description>In the first lectures of the datastructures we&amp;rsquo;ll repeat a few things that were already covered in the Algorithm &amp;amp; Programming Lecture so you may want to refer those blog posts as well. After all both courses belong to the same module.
Computational Effort &amp;amp; Complexity To compare datastructures and algorithms in regards to efficiency we need a way to measure the &amp;ldquo;cost&amp;rdquo; / computational effort. This is done by counting the required computing &amp;ldquo;steps&amp;rdquo; (Rechenschritte).</description>
    </item>
    
    <item>
      <title>Operating Systems - Introduction</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</guid>
      <description>Although Operating Systems depend on the underlying hardware, there general principles that are common across different operating systems and this is the topic of this course. There are two different ways to &amp;ldquo;view&amp;rdquo; an operating system (2 Sichten):
 Top Down View (OS as a virtual machine)  offers an abstract view on the hardware real hardware characteristics are sort of hidden take for example the harddrive and the file system:  real machine (hardware): a sequence of data blocks of fixed size virtual machine: named files of variable size   Bottom Up View (OS as a resource manager)  OS coordinates the access on CPU, Memory, Storage etc.</description>
    </item>
    
    <item>
      <title>Databases &amp; Webtechnology - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/dbw/01_lecture/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/dbw/01_lecture/</guid>
      <description>Organizational Tutorial Dates: 09.04, 16.04, 23.04, 30.04, 07.05, 14.05, 20.05 (Project Start), 23.06 (Project End), 01.07-12.07 (Project Presentation ~15 minutes)
IT-Architectures Throughout times there where different architectures favored or dominant. In the beginning there were mostly monolithic architectures. Mainframes are an example of monolithic architecture and are nowadays used primarily by large organizations for critical applications; bulk data processing, such as census, industry and consumer statistics, enterprise resource planning; and transaction processing.</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/01_lecture/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/01_lecture/</guid>
      <description>This was the first lecture in the new summer semester and therefore it was mostly about organizational stuff. Here are the most important points:
 the exam is gonna be a written one and might be open-book the start of the tutorials will be announced on the course website sometime in April (registration via opal) there are gonna be exercises to hand in  those can be found here  the main programming language used will be python  Fundamental literature:</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/01_lecture/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/01_lecture/</guid>
      <description>This was the first lecture in the new summer semester and therefore it was mostly about organizational stuff. Here are the most important points:
 the exam is gonna be a written one and might be open-book the start of the tutorials will be announced on the course website sometime in April (registration via opal) there are gonna be exercises to hand in  those can be found here   Distributed Solution Design</description>
    </item>
    
    <item>
      <title>Course Information Summer 19</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/org/sose19/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/org/sose19/</guid>
      <description>Dates Okay so the new semester started (01.04.19). Here&amp;rsquo;s an overview of the most important stuff:
Start Lecture Period: 01.04.2019 End Lecture Period: 12.07.2019
Beginn of central examination period: 15.07.2019 End of central examination period: 10.08.2019
Re-matriculation Period: 03.06. - 13.09.2019
Courses and related links  Datastructures  Material PVL: at least 50% of homework correct and handed in here Exam type: written  Operating Systems  Course Homepage Tutorial Page Exam type: written  Artificial Intelligence  Course Homepage Exam type: written  Security of Distributed Software  Course Homepage Tutorial Page Exam type: written (might be open-book)  Media Encoding  Course Homepage Exam type: written  Databases &amp;amp; Webtechnology  Material Exam type: project until 23.</description>
    </item>
    
  </channel>
</rss>