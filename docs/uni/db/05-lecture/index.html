<!doctype html>
<html>
  <head>
    <title>Database Essentials - Lecture 05 // schoettkr</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.60.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Schoettkr" />
    <meta name="description" content="" />
    <base href="https://schoettkr.github.io/knowledge-database/" />
    <link rel="stylesheet" href="https://schoettkr.github.io/knowledge-database/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="./avatar.png" /></a>
      <h1>schoettkr</h1>
      <p>Software developer currently pursuing a master&#39;s degree in Germany</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/schoettkr"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Database Essentials - Lecture 05</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 21, 2018
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="relational-calculus--relationenkalkül">Relational Calculus (Relationenkalkül)</h2>
<p>The expressions in <em>relational algebra</em> form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate relation results. This way describes they way of <em>how</em> you come to the relation result.</p>
<p>There is an alternative however to describe a query result without specifying the derivation (Herleitungsvorschrift), which is called <strong>relational calculus</strong>. In relational calculus only the requirements of the desired resulting tuples are specified/described but not the way they are retrieved. This way describes <em>what</em> is contained in the result relation.</p>
<p>A calculus (Kalkül) is a method, that is determined by a set of rules, to deal with certain mathematical problems in a systematic manner and solve them automatically (slides: ist eine durch ein System von Regeln festgelegte Methode, mit deren Hilfe bestimmte mathematische Probleme systematisch behandelt und automatisch gelöst werden können)</p>
<p>The basis for relational calculus is predicate/quantifier logic  of the first degree (Prädikatenlogik erster Ordnung) and the result of a query is a set of tuples. In relational calculus calculus expressions (Kalkülausdrücke) are used, in particular the <strong>tuple calculus</strong> and the <strong>domain calculus</strong>.</p>
<h3 id="tuple-calculus">Tuple Calculus</h3>
<p>The query notation for tuple calculus is {t | P(t)} where t is a tuple variable and P is a predicate over t. The result of such query is a set of all tuples for which the evaluation of the predicate P(t) yields <em>true</em>.</p>
<p>Take the following example relation &ldquo;Student&rdquo;:</p>
<table>
<thead>
<tr>
<th>matrNr{PK}</th>
<th>name</th>
<th>major</th>
</tr>
</thead>
<tbody>
<tr>
<td>123456</td>
<td>Archimedes</td>
<td>Computer Science</td>
</tr>
<tr>
<td>134534</td>
<td>Sophokles</td>
<td>Philosophy</td>
</tr>
<tr>
<td>145698</td>
<td>Cleopatra</td>
<td>Computer Science</td>
</tr>
</tbody>
</table>
<p>Query: {s | s ∈ Student ∧ s.major='Computer Science&rsquo;}</p>
<p>Result:</p>
<table>
<thead>
<tr>
<th>matrNr{PK}</th>
<th>name</th>
<th>major</th>
</tr>
</thead>
<tbody>
<tr>
<td>123456</td>
<td>Archimedes</td>
<td>Computer Science</td>
</tr>
<tr>
<td>145698</td>
<td>Cleopatra</td>
<td>Computer Science</td>
</tr>
</tbody>
</table>
<ul>
<li>Tuple Calculus - Atoms and Formulas</li>
</ul>
<pre><code>For the construction of formula we define sets of atomic formulas.
**Atoms** in tuple calculus:

-   t\_i &amp;isin; R\_j &amp;rarr; the relation R\_j is assigned as the codomain(Wertebereich) to the tuple variable t\_i
-   t\_i.A &amp;Theta; t\_j.B &amp;rarr; comparison operation between two attributes A and B which are attributes of the relations that were assigned as codomains to t\_i and t\_j
-   t\_i.A &amp;Theta; c &amp;rarr; comparison operation between attribute A and constant C
-   c &amp;Theta; t\_i.A &amp;rarr; comparison operation between constant c and attribute A

The comparison operation denoted by &amp;Theta; encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &lt;, &gt;, &amp;le;, &amp;ge;, =, &amp;ne; and =, &amp;ne; for boolean values.

Every atom is a _formula_. When F\_1 and F\_2 are formulas then the following constructs are formulas as well:

-   F\_1 &amp;and; F\_2 = Conjunction
-   F\_1 &amp;or; F\_2 = Disjunction
-   &amp;not; F\_1  = Negation
-   (F\_1) = wrapping (Klammerung)

When F is a formula and t is a tuple variable in F then the following constructs are formulas:

-   (&amp;exist; t)(F) = existential quantifier (Existenzquantifizierung)
-   (&amp;forall; t)(F) = universal quantifier (Universalquantifizierung)
</code></pre>
<ul>
<li>Tuple Calculus - Free and Bounded Tuple Variables</li>
</ul>
<pre><code>A tuple variable in an atom (respective in a formula consisting of one atom) is **free**.

A tuple variable in a formula that is composed via negation, conjunction or disconjuction of other partial formulas is **free** or **bound** depending on its state in the other partial formulas. In this case a tuple variable can be free and bound at the same time.

**Free** tuple variables t of a formula F get **bound** to the respective quantifier F' when they are embedded in one of the following formulas F':

-   F' = (&amp;exist; t)(F)
-   F' = (&amp;forall; t)(F)

Examples:

-   F\_1: s.name = 'Cleopatra'
-   F\_2: (&amp;exist; t)(s.matrNr = t.matrNr)
-   F\_3: (&amp;forall; s)(s.name = 'Cleopatra')
</code></pre>
<ul>
<li>Tuple Calculus - Computing Formulas (Substitution)</li>
</ul>
<pre><code>Given that F(s) is a formula with the tuple variable s &amp;isin; R and a tuple t &amp;isin; R. Then the following happens in each atom of F(S) with a _free_ s:

-   s &amp;isin; R is replaced with true
-   s.A &amp;Theta; u.B is replaced with t.A &amp;Theta; u.B (A and B are atrtibutes, u is another tuple variable u &amp;ne; s)
-   s.A &amp;Theta; c is replaced with the concrete boolean value of the operation t.A &amp;Theta; c

These steps are repeated for further tuple variables if necessary until F(s) only holds (possibly logically connected) boolean constants (true/false) and atoms with bound variables.

Example:
Given tuple variable s and t from a schema R(a,b) and the formula &amp;forall; t(t &amp;isin; R &amp;and; t.a = s.a &amp;and; t.b &lt; s.b) the substitution happens/looks like this:

-   the tuple s = (8, 12) &amp;rarr; &amp;forall; t(t &amp;isin; R &amp;and; t.a = 8 &amp;and; t.b &lt; 12)
-   then the tuple t = (8, 9) &amp;rarr; &amp;forall; t(true &amp;and; 8 = 8 &amp;and; 9 &lt; 12) &amp;rarr; &amp;forall; t(true &amp;and; true &amp;and; true) &amp;rarr; &amp;forall; t(true)
</code></pre>
<ul>
<li>Tuple Calculus - Computing Formulas for bound Tuple Variables</li>
</ul>
<pre><code>Given a tuple variable s &amp;isin; R:

-   the formula (&amp;exist; t)(F) evaluates to _true_ if F becomes true for at least one substitution of s and the formula evaluates to false otherwise
    -   this means that at least one tuple can be associated with the free tuple variable s for which F becomes true
-   the formular (&amp;forall; t)(F) evaluates to _true_ if F becomes true for _all_ substitutions of s
    -   this means that F is true/fulfilled for all tuples that can be assigned to the free tuple variable s

**Final Formula Computation** = formulas now only hold logically connected boolean values which can be evaluated accordingly.
</code></pre>
<ul>
<li>Tuple Calculus - Expressions and Queries</li>
</ul>
<pre><code>In general an expression/query of the tuple calculus is of the following form: {t\_1.A\_1, t\_2.A\_2, ..., t\_n.A\_n | F(t\_1, ..., t\_m)}

t\_i are tuple variables (which in general encompass all tuples of the so called univesere, that's why they are usually assigned to a relation) and A\_i are attributes of the relation that is assigned to the tuple variable t\_i, while F(t\_1, ..., t\_m) is the formula of the tuple calculus.

Taking our previous student relation:

| matrNr{PK} | name       | major            |
|------------|------------|------------------|
| 123456     | Archimedes | Computer Science |
| 134534     | Sophokles  | Philosophy       |
| 145698     | Cleopatra  | Computer Science |

Query: {s.matrNr, s.name | s &amp;isin; Student &amp;and; s.major='Philosophy'} yields

| matrNr{PK} | name      |
|------------|-----------|
| 134534     | Sophokles |

---

Now onto another example. Given the relations teacher

| persNr{PK} | name |
|------------|------|
| 3467       | Ares |
| 6897       | Zeus |
| 43467      | Hera |

and lectures

| number{PK} | title                    | persNr{FK} |
|------------|--------------------------|------------|
| 123        | Data Structures          | 6897       |
| 234        | Databases in Praxis      | 6897       |
| 345        | Database Essentials      | 43467      |
| 456        | Exercise Data Structures | 6897       |

we want to know the names of the teachers that hold at least one lecture:
{t.name | t &amp;isin; Teacher &amp;and; (&amp;exist; l)(l &amp;isin; lectures &amp;and; t.persNr = l.persNr)} which leads to this resulting relation

| name |
|------|
| Zeus |
| Hera |

---

To query the lecture titles of lectures given by Zeus we'd use the following:
{t.title | t &amp;isin; Lectures &amp;and; (&amp;exist; l)(l &amp;isin; teacher &amp;and; t.persNr = l.persNr &amp;and; l.name='Zeus') } to get

| title                    |
|--------------------------|
| Data Structures          |
| Databases in Praxis      |
| Exercise Data Structures |

---

For the next example queries I embed the slides because it is more clearer and not so much overhead.
&lt;/knowledge-database/images/tuple-calc-ex1.png &gt;
&lt;/knowledge-database/images/tuple-calc-ex2.png &gt;

One problem with queries of tuple calculus is that they can sometimes produce an infinite result relation, eg { s | &amp;ne;(s &amp;isin; Student) }.

The domain of a formula contains all constant values of a formula and all possible attribute values of all tuples in the referenced relations.

A **safe query** is a query where the result of the query stems from the domain of the formula &amp;rarr; we only use safe queries (all queries we've seen so far are safe).

Also see &lt;https://en.wikipedia.org/wiki/Tuple%5Frelational%5Fcalculus&gt; for more
</code></pre>
<h3 id="domain-calculus">Domain Calculus</h3>
<p>The domain relational calculus is also a calculus that serves as a declarative database query language for the relational data model. In DRC queries have this form {d_1, d_2, &hellip;, d_n | F(d_1, d_2, &hellip;, d_m)} with m ≥ n where d_i are domain variables which describe the values of attribute domains and F(d_1, d_2, &hellip;, d_m) is the formula. The formula consists, like in the relational calculus (tuple?), of either a an atom, a logical connection of formulas or a formula with a domain variable which is existential quantified or universal quantified.</p>
<ul>
<li>Domain Calculus - Atoms and Comparison</li>
</ul>
<pre><code>Given the relation R of degree n where every d\_i is a domain variable, the atom \\(R(d\_1, d\_2, ..., d\_n)\\) expresses that the codomain (Werteliste) &lt;d\_1, d\_2, ..., d\_n&gt; has to be a tuple of the relation R.

Comparisons

-   d\_i &amp;theta; d\_j &amp;rarr; comparison operation between two domain variables d\_i and d\_j
-   d\_i &amp;theta; c &amp;rarr; comparison operation between domain variable d\_i and constant c
-   c &amp;theta; d\_i &amp;rarr; comparison operation between constant c and domain variable d\_i

The comparison operation denoted by &amp;Theta; encompasses the usual comparison operators that are valid on the respective attribute domains. Usually these are &lt;, &gt;, &amp;le;, &amp;ge;, =, &amp;ne; and =, &amp;ne; for boolean values (required that the elements of the domain can be compared pairwise).
</code></pre>
<ul>
<li>Domain Calculus - Example Queries</li>
</ul>
<pre><code>Given the relations teacher

| persNr{PK} | name |
|------------|------|
| 43467      | Ares |
| 6897       | Zeus |
| 43424      | Hera |

and lectures

| number{PK} | title                    | persNr{FK} |
|------------|--------------------------|------------|
| 123        | Data Structures          | 6897       |
| 234        | Databases in Praxis      | 6897       |
| 345        | Database Essentials      | 43467      |
| 456        | Exercise Data Structures | 6897       |

**1.)** List the lecture titles that are held by teacher with persNr 6897?

-   The query {b | (&amp;exist; a) (&amp;exist; c) (Lecture(a,b,c) &amp;and; c=6897)} yields:

| title                    |
|--------------------------|
| Data Structures          |
| Databases in Praxis      |
| Exercise Data Structures |

**2.)** What are the numbers and titles of lectures held by Zeus?

-   The query {a, b | (&amp;exist; c) (&amp;exist; d) (&amp;exist; e) (Lecture(a,b,c) &amp;and; teacher(d,e) &amp;and; c=d &amp;and; e='Zeus')} yields:

| number{PK} | title                    |
|------------|--------------------------|
| 123        | Data Structures          |
| 234        | Databases in Praxis      |
| 456        | Exercise Data Structures |

**3.)** What's the title of lectures hold by teacher with persNr6987 with at least 5 Credits?

We now have an additional column in our lecture relation:

| number{PK} | title                    | credits | persNr{FK} |
|------------|--------------------------|---------|------------|
| 123        | Data Structures          | 5       | 6897       |
| 234        | Databases in Praxis      | 5       | 6897       |
| 345        | Database Essentials      | 5       | 43467      |
| 456        | Exercise Data Structures | 2       | 6897       |

Alternatively a query can be formulated with a direct specification of constant attribute values: {b | (Lecture(a, b, _5_, _6897_))} which yields

| title               |
|---------------------|
| Data Structures     |
| Databases in Praxis |

(slides: alle Variablen, die nicht „links“ auftreten, sind hierbei automatisch existenzquantifiziert)
</code></pre>
<h2 id="relational-languages">Relational Languages</h2>
<p>The following query languages possess the same expresiveness (Ausdrucksmächtigkeit):</p>
<ul>
<li>relational algebra</li>
<li>tuple calculus (limited to safe queries)</li>
<li>domain calculus (limited to safe queries)</li>
</ul>
<p>Queries can be converted between those languages at any time.</p>
<p>In praxis the <strong>relational calculus</strong> is the foundation for &ldquo;real&rdquo; query languages of relational DBMS:</p>
<ul>
<li>tuple calculus is the foundation of SQL (Structured Query Language)</li>
<li>domain calculus is the foundation of QBE (Query By Example)</li>
</ul>
<p><strong>Relational algebgra</strong> is the foundation for the realisation of queries in the query languages. The sequence of operations describes the path to the result of a query (which can be optimized in some circumstances).</p>
<h2 id="introduction-to-sql">Introduction to SQL</h2>
<h4 id="history">History</h4>
<ul>
<li>1970: Codd presents the relational model</li>
<li>1974: development of the relational query language SEQUEL (Structured English Query Language)</li>
<li>1976: further development (Weiterentwicklung) of SEQUEL served as a foundation of the DBMS prototype &ldquo;System R&rdquo; by IBM, which was later renamed to SQL (Structured Query Language)</li>
<li>in the early 80s: a lot of DBMS emerge by different commercial providers → standardization is needed</li>
<li>1987: first SQL Standard</li>
<li>1992: big expansion of the standard → SQL 2 (SQL-92)</li>
<li>since then continuous evolution: SQL-99 → SQL:2003 → SQL:2006 → SQL:2008 → SQL:2011</li>
</ul>
<h4 id="introduction-to-sql-components">Introduction to SQL - Components</h4>
<p>There two high level components of SQL:</p>
<p><strong>Data Definition Language (DDL)</strong></p>
<ul>
<li>defines the database structure</li>
<li>manages the access rights to the data</li>
</ul>
<p>and</p>
<p><strong>Data Manipulation Language (DML)</strong></p>
<ul>
<li>used to formulate queries for the data sets</li>
<li>create, read, update, delete of data</li>
</ul>
<p>For now we'll focus on the Data Manipulation Language.</p>
<p>SQL does not operate on relations, but rather their physical representation form which are <strong>tables</strong>. In tables duplicate entries are possible which we may have to exclude. In contrast to relations there is one more advantage to table which is that they can be sorted.</p>
<h4 id="introduction-to-sql-queries">Introduction to SQL - Queries</h4>
<p>All queries to a database in SQL are realized via the <code>select</code> statement.
This is the general construction:</p>
<ul>
<li>
<p><code>select` </code>attribute|expression` → which attributes should the result table contain?</p>
</li>
<li>
<p><code>from` </code>list of tables` → which tables are required for the query?</p>
</li>
<li>
<p>[ <code>where</code>  <code>condition</code> ] → which conditions should the result tuples fulfill?</p>
</li>
<li>
<p>[ <code>group by</code>  <code>list of attributes</code> ] → summarize/condense identical attribute values</p>
</li>
<li>
<p>[ <code>having</code>  <code>condition</code> ] → condition in regards to grouped tables</p>
</li>
<li>
<p>[ <code>order by</code>  <code>sort</code> ] → specification of sorting for the resulting table</p>
<p>Now let's look at some simple example queries (mostly π projection and \roh rename at one point):</p>
</li>
</ul>
<p>I insert the slides here because they are visually more appealing/clear :D</p>
<p>Three simple queries:
&lt;/knowledge-database/images/simple-sql-1.png &gt;
&lt;/knowledge-database/images/simple-sql-2.png &gt;
&lt;/knowledge-database/images/simple-sql-3.png &gt;</p>
<p>Sorting:
&lt;/knowledge-database/images/simple-sql-4.png &gt;
&lt;/knowledge-database/images/simple-sql-5.png &gt;</p>
<p>Simple query with <em>distinct</em>
&lt;/knowledge-database/images/simple-sql-6.png &gt;</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  </body>
</html>
