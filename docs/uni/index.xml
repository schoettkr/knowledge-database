<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unis on schoettkr</title>
    <link>https://schoettkr.github.io/knowledge-database/uni/</link>
    <description>Recent content in Unis on schoettkr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Oct 2019 00:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://schoettkr.github.io/knowledge-database/uni/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Einführung in die Funktion von Computersystemen - Lecture 05: Systemsoftware - Prozesse und Prozesswechsel</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/fcs/05_lecture/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/fcs/05_lecture/</guid>
      <description>Betriebsssytem  das Laden von Programmen ist ein Dienst, der zur Laufzeit (im Gegensatz zur Übersetzungszeit) die Programmausführung unterstützt es gibt mehrere solcher Dienste und zusammengefasst werden sie zu einem Betriebssystem allgemein hat ein Betriebsssytem zwei Aufgaben:  abstrakter Computer: es bietet den Programmen &amp;ldquo;schönere&amp;rdquo; Interfaces &amp;amp; Abstraktionen als ein realer Computer Ressourcenmanager: es koordiniert den (konkurrierenden) Zugriff auf Ressourcen    Arten von Betriebsssytem  Batch OS (Stapelbetriebsysteme)  verschiedene Programme (Jobs) werden nacheinander abgearbeitet meist keine Interaktion   Multitasking OS (Mehrprogrammbetriebssysteme)  verschiedene Programme laufen (quasi) gleichzeitig ab (nebenläufig) Interaktion ist möglich   Multiuser OS (Mehrnutzerbetriebssysteme)  mehrere Nutzer können gleichzeitig interaktiv am System arbeiten Time Sharing (Zeitscheibenbetrieb)   Real Time OS (Echtzeit- oder Prozesssteuerbetriebssystem)  Einsatz für Steuerungsaufgaben bestimmte Zeitanforderungen müssen einhaltbar sein    Heutige Betriebsssyteme vereinen meist mehrere der obigen Aspekte</description>
    </item>
    
    <item>
      <title>Einführung in die Funktion von Computersystemen - Lecture 04: Von der Befehls- zur Programmausführung</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/fcs/04_lecture/</link>
      <pubDate>Tue, 22 Oct 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/fcs/04_lecture/</guid>
      <description>Programmierung  wir können nun prinzipiell arithmetisch &amp;amp; logische Operationen ausführen und mit dem Speicher kommunizieren Problem: Was genau soll wann gemacht werden?  Makroebene: Programm (durch Nutzer/Programmierer)  Programm liegt in durch den Prozessor &amp;ldquo;lesbarer&amp;rdquo; Form im Speicher     Problem: Wie wird es &amp;ldquo;verstanden&amp;rdquo;?  Mikroebene: Sequencing (durch Hersteller)  automatische Interpretation des Nutzerprogramms      → gemeinsame Schnittstelle: Rechnerorganisation (zB Register, Befehle, &amp;hellip;)</description>
    </item>
    
    <item>
      <title>Einführung in die Funktion von Computersystemen - Lecture 03: Von Neumann Rechner</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/fcs/03_lecture/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/fcs/03_lecture/</guid>
      <description>Von-Neumann-Architektur  1946: ENIAC als erster vollständiger Rechner aus den USA EDVAC: Konzept des stored program computer von John von Neumann  Speicher enthält Programm &amp;amp; Daten      Abstrakt gesehen besteht die Informationsverarbeitung in der Von-Neumann-Architektur aus drei Stufen:
 Datengewinnung und -eingabe Verarbeitung und Speicherung Datenausgabe  Diese Stufen sollten sich in Geräten zur Informationsverarbeitung wiederspiegeln.
   John v. Neumann veröffentlichte erstmals die nach ihm benannten Prinzipien des Rechnerentwurfs, nachdem er für das Manhattan-Projekt beim Entwurf des EDVAC (Electronic Discrete Variable Automatic Computer) mitgearbeitet hatte  Von-Neumann-Prinzipien  ein Rechner besteht aus Rechenwerk, Steuerwerk, Speicher und Ein-/Ausgabegeräten die Zentraleinheit arbeitet taktgesteuert die Signale werden binär kodiert der Inhalt eines Speicherwortes wird über eine Adresse angesprochen der Rechner verarbeitet externe Programme die intern gespeichert werden Programmbefehle und Daten werden im einheitlichen Hauptspeicher gespeichert Programme und Daten werden sequentiell abgearbeitet; der sequentielle Programmfluss kann durch (bedingte oder unbedingte) Sprünge verändert werden jede theoretisch mögliche Berechnung ist (im Rahmen der Kapazität des Rechners) berechenbar  Harvard Architektur vs Von Neumann Architektur:Komponenten des von Neumann Rechners Komponenten: Bus  ein Bus (bidirectional universal switch) ist eine Verbindungseinheit zwischen verschiedenen logisch getrennten Funktionseinheiten    Komponenten: Zentrale Verarbeitungseinheit (CPU)  ist Kernstück eines jeden Von-Neumann-Rechners CPU = central processing unit (ZVE, zentrale Verarbeitungseinheit) liegt häufig als ein IC (integrated circuit, integrierte Schaltung) vor  Mikroprozessor (microprocessor)   bekannte Prozessorfamilien sind:  x86, IA-32, Intel-64 m68k, m88k PowerPC ARM MIPS SPARC   in der CPU findet die eigentliche Informationsverarbeitung statt die CPU besteht mindestens aus Rechenwerk (ALU) und Steuerwerk  Rechenwerk macht die Arbeit Steuerwerk bestimmt welche Arbeit gemacht werden soll   neben der CPU kann es noch andere Prozessoren geben die spezialisierte Aufgaben erfüllen (Koprozessoren) zb für: Gleitkommaarithmetik, Speichermanagement, Bus-Controller  ALU / Rechenwerk</description>
    </item>
    
    <item>
      <title>Einführung in die Funktion von Computersystemen - Lecture 02: Von der Schaltungslogik zur Informationsverarbeitung</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/fcs/02_lecture/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/fcs/02_lecture/</guid>
      <description>Schaltungslogik   Schaltnetze Sogenannte Gatter implementieren die booleschen Funktionen. Signale werden dabei durch elektrische Spannungen dargestellt. Durch die Zusammensetzung von Gattern entstehen Logikschaltungen. Ein Schaltnetz ist eine Zusammensetzung von Verknüpfungsschaltungen ohne Speicherverhalten.Durch logisch vollständige Funktionen können beliebige andere Funktionen &amp;ldquo;gebaut&amp;rdquo; werden. Zum Beispiel lässt sich die XOR-Funktion (\(x \oplus y\)) durch NAND-Gatter wie folgt realisieren:Optimierung Eine Schaltung ist nicht immer optimal (zB zuviel Gatter), daher gibt es Methoden zur Optimierung, die da wären Verfahren nach McCluskey und das Verfahren nach Karnaugh und Veitch, welches wir im folgenden betrachten.</description>
    </item>
    
    <item>
      <title>Einführung in die Funktion von Computersystemen - Lecture 01: Informationen und ihre Darstellung</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/fcs/01_lecture/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/fcs/01_lecture/</guid>
      <description>Äquivalente Informationen können in vielen verschiedenen Darstellungen übermittelt werden. Eine symbolische Darstellung entspricht dabei der Syntax, welche via Interpretation Semantik (Bedeutung) erlangt. Bei unbekannten Interpretationsregeln kann Bedeutung jedoch nicht erkannt werden.Eine symbolische Darstellung erfolgt mittels Symbolen. Jene Symbole werden in einem Alphabet festgehalten. Ein Alphabet ist eine endliche Menge von Symbolen. Das kleinste Alphabet ist das der Binärzahlen \({0,1}\). Mit sogenannten Binärcodes also Zusammensetzungen der Symbole \(0\) und \(1\) lassen sich die Symbole aller denkbaren Alphabete ausdrücken (Binärcodierung).</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 10</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/10_lecture/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/10_lecture/</guid>
      <description>Part III: Trustworthy Software EngineeringIdentity in the Light of Privacy, Security and Trust (Chapter 2)  7 Laws of Identity define requirements of dealing with identities  first focus on conceptual/basic understanding   identity in global context has to comply with different levels  layered approach of identity management:       Identity - Security - Privacy  identity (in a digital setting) is often &amp;ldquo;only&amp;rdquo; closely linked to security, identity is more!</description>
    </item>
    
    <item>
      <title>Operating Systems - Services, Resources and Devices</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/11_lecture/</link>
      <pubDate>Wed, 12 Jun 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/11_lecture/</guid>
      <description>Services  services deal with resources we distinguish between active and passive resources services which are not offered by the kernel are realized via processes (or groups of processes) of the OS  this is the majority in a micro kernel system with the exception of process management, IPC and possibly memory management UNIX concept for such processes are daemons clients utilize service via IPC (usually communication → via channels)   a process can be a client and a server at the same time  Service - Service Relationship    a server usually offers multiple operations that can be called by the client a &amp;ldquo;job&amp;rdquo; means the execution of such operation for example  file service: open, close, read, write name service: resolve, register, delete   the server operations can be realized in one or more processes  Service - Time  the service relationship has an influence on the progress  client has to wait (blocked) until the result comes from the server server is not available to other clients until the next round (limited throughput)   improvement via  drifting the communication buffering parallelism in the server    Service - Drifting  goal: overlap between client and server activity realization:  dispatch job at the earliest possible point in time recieve/take back the result at the latest possible point in time   that means the job sending operation of the client should &amp;ldquo;drift forward&amp;rdquo; and the recieve operation should &amp;ldquo;drift backwards&amp;rdquo;  Service - Buffering  instead of having huge jobs it might make sense to divide jobs in smaller chunks → job processing can start earlier decoupling via buffering  increased parallelism between client and server avoid blocking   analagous for the result  especially useful for services that (directly or indirectly) access I/O devices since there are may occur huge delays   besides a higher parallelism there are other goals that can be achieved via buffering:  caching eg buffer for files changing data semantics eg character oriented I/O at blocked devices and vica versa or terminal modes (raw, cooked, halfcooked)    Different kinds of buffers:Service - Parallelism   parallelism between client and server improves the response time at the client (and therefore at the user)</description>
    </item>
    
    <item>
      <title>Operating Systems - Coordination Problems</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/10_lecture/</link>
      <pubDate>Wed, 05 Jun 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/10_lecture/</guid>
      <description>Coordination mechanisms and techniques can solve a lot of problems like guaranteeing data consistency when cooperating (guarding critical sections), managing exclusive ressource access etc. However new problems may occur when employing coordination mechanisms:
 priority inversion starving (verhungern) deadlock (verklemmen)  Priority Inversion In the case of priority based scheduling a process with higher priority may be blocked by a process with lower priority, for example:
 low-prio process \(P_L\) enters a critical section high-prio process \(P_H\) gets ready to execute and tries the same \(P_H\) is blocked  Now if a process with medium priority \(P_M\) suspenses the low-prio process \(P_L\) the blocking/stopping of \(P_H\) may continue.</description>
    </item>
    
    <item>
      <title>Operating Systems - Coordination</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/09_lecture/</link>
      <pubDate>Wed, 29 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/09_lecture/</guid>
      <description>Introduction In the last chapter we looked at communication and cooperation to exchange information/data between processes. In this chapter we take a look at the timely aspect → coordination which is also often called synchronization. We focus on coordination between processes as we&#39;ve already kind of covered coordination in the kernel via suspension etc.
Elementary Coordination Many coordination problems can be solved with a uniform concept → signaling:
 signaling uses signals to create a sequence relationship (Reihenfolgebeziehung) ATTENTION: this has nothing to do with UNIX-signals!</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 09</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/09_lecture/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/09_lecture/</guid>
      <description>Part III: Trustworthy Software EngineeringTrustworthy Software
 in Cordis.Europa.Eu security document defined as: Trustworthiness can be seen as software and infrastructure that is secure, reliable and resilient to attacks and operational failures; guaranteeing quality of service; protecting user data; ensuring privacy and providing usable and trusted tools to support the user in his/her security management. trustworthiness needs to be considered from the outset rather than being addressed as add-on feature  So we focus on: Identity &amp;amp; Security By Design (SBD)</description>
    </item>
    
    <item>
      <title>Operating Systems - Interprocess Communication</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/08_lecture/</link>
      <pubDate>Wed, 22 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/08_lecture/</guid>
      <description>Introduction Processes are usually a part of more complex systems. Therefore they sometimes have to exchange data between each other (inter process communication, IPC). Operations to achieve inter process communication are besides process management one of the major tasks of an OS kernel.There&#39;s a functional and a timely aspect when it comes to inter process communication. In this chapter we will cover the functional aspect and the timely aspect will be covered in the next chapter.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/08_lecture/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/08_lecture/</guid>
      <description>Internet Firewalls (Chapter 6) Definition: Firewalls are hard- or software components, which control the interconnection point between two network areas and implement security strategies by restricting packet forwarding.
Fundamentals:
 Packet filter  entity, which selectively processes flowing packets according to predefined rules, in particular, preventing packet forwarding   Proxy approaches  representative of a client process   Network Address Translation (NAT)  address translation, public and private addresses are distinguished   Bastion Host  computer with particularly high protection requirements; vulnerability mainly results from the computer&#39;s exposed location   Dual-Homed Host  computer with at least two network interfaces for two different subnets    These approaches are now covered in more detail.</description>
    </item>
    
    <item>
      <title>Operating Systems - Efficient Memory Management</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/07_lecture/</link>
      <pubDate>Wed, 15 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/07_lecture/</guid>
      <description>Virtualization and Caching Hierarchy of storages: in this chapter we deal with the interaction of these hierarchies  Locality of reference (Lokalitaetsprinzip) The storage hierarchy is based on the principle of locality. The principle of locality states that only a small part of the address space \(A\) is accessed in small intervalls \(\delta t\) and that there is a tendency of a processor to access the same set of memory locations repetitively over a short period of time.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/07_lecture/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/07_lecture/</guid>
      <description>Management of Access Rights Authorization is the process of verification and access right assignment for a resource/service to a subject and is not to be confused with Authentication which is the process of verificating claimed properties. Access Control is a process of access rights management and control.
Access Matrix group- and role-based access rights management:  complexity reduction by clustering users into &amp;lsquo;role groups&amp;rsquo; inheritance relationships in rights management permissions based on roles    Access Control Lists principal is a user, group or process that can be authenticated simply put: ACL is a set/list of resources, principals and corresponding access rights  Access Control Models Discretionary Access Control (DAC)  access rights are assigned per user owner of a resource can pass his own rights   Mandatory Access Control (MAC)  rights passing is not allowed the system alone decides on which user has access to which resources   Role-Based Access Control (RBAC)  user could potentially be assigned multiple roles access rights are role-based    Realization in Operating Systems Unix/Linux</description>
    </item>
    
    <item>
      <title>Operating Systems - Address Mapping</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</link>
      <pubDate>Wed, 08 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/06_lecture/</guid>
      <description>Intro Primary memory (RAM) is constituted via adress spaces
 address space = a range of discrete memory addresses logical address space = address(es) generated by a CPU and seen by programs physical address space = address(es) that are seen by the memory unit and used to access memory units  The physical and the logical/virtual address space (and virtual address spaces between each other) may differ in regards to their size and structure.</description>
    </item>
    
    <item>
      <title>Computer Networks - Chapter 04 Netz-Zugang</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/chapter-04/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/chapter-04/</guid>
      <description>DLC-Protokolle: UebersichtData Link Control
 asynchrone Uebertragung  Uebertragung nicht innerhalb eines groesseren Uebertragungsrahmen, sondern zeichenweiser Start-Stop-Betrieb (Telexdienst)   synchrone Uebertragung  zeichenorientiert = kleinste Uebertragungseinheit ist ein Zeichen, zB 8 Bit  zB PPP   bitorientiert = kleinste Uebertragungseinheit ist 1 Bit  zB HDLDC, LLC (LAN), LAPD (ISDN)      4.1 Synchronisation Asynchrone Uebertragung (zeichenweiser Start/Stop Betrieb) setzt Ruhepegel und feste Zahl von Nutzschritten voraus 3 aus 11 Overhead (8 Nutzbitz bei 11 zu uebertragenen Bits)  Synchrone Uebertragung (Blocksynchronisation) setzt Benutzung eindeutiger Blockstart- und/oder Blockendmuster voraus Modifikation / rueckgaengig machen entsprechender Muster im Block (Zeichen-/Bitstopfen)  Codetransparenz bei synchroner Uebertragung = Vereinbarung von Regeln zur codetransparenten Uebertragung von Nutzdaten (d.</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/05-lecture/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/05-lecture/</guid>
      <description>Modems Modem = MOdulator/DEmodulator
 basieren urspruenglich uaf der klassischen Teilnehmeranschlussleitung des Fernsprechnetzes     Leistungsanschaltung = signaltechnische (Sende- und Empfangs-) Verstaerkung der zu uebertragenen Signale Modulationsteil = Modulation/Demodulation (zB Amplitude, Frequenz, &amp;hellip;)  Modulation beschreibt einen Vorgang, bei dem ein zu uebertragendes Nutzsignal einen sog. Traeger veraendert (moduliert), dadurch wird eine hochfrequente Uebertragung des niederfrequenten Nutzsignals ermoeglicht die Nachricht wird empfangsseitig durch einen Demodulator zurueck gewonnen, beispielsweise um ein Audiosignal in UKW-Empfaengern aus dem hochfrequenten, frequenzmodulierten Signal (87,5-108 MHz) zurueckzugewinnen (Radio)   Steuer-/Meldeteil = Analyse der vom Netz kommenden Dienstsignale, An-/Abschaltung des Modems an Steuerfunktionen (zB Betriebs-, Sendebereitschaft)  Mehrfachnutzung von Medien Multiplexverfahren (lat.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/06_lecture/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/06_lecture/</guid>
      <description>Authentication Introduction Authentication is the process of verficating if someone is the one who he claims to be. There are different kinds of authenticators:
 knowledge-based  PIN, passwords Challenge-Response   biometrics  fingerprint, iris, voice, signature, keystroke behavior   ownership-based  something that you do not notice, but what is stored on a medium IDs, magnetic cards, certificates, smart cards   multi-factor authentication  combination of different types of authentication 2 Factors: eg deposit card + PIN, credit card + signature, password + PIN sent by SMS 3 Factors: eg password + smart card + fingerprint    Knowledge-based Authentication Knowledge-based Authentication using passwords</description>
    </item>
    
    <item>
      <title>Operating Systems - Linear Memory Model</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</link>
      <pubDate>Wed, 01 May 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/05_lecture/</guid>
      <description>Intro When a program is executed the instruction are present in memory/storage and then the CPU loads those instructions and executes them (program counter, Assembler). Hardware is able to deal with absolute (direct) and relative adressing modes.
 absolute (direct) addressing = memory locations of operands are specified as a whole and completely relative addressing = memory locations are specified relative to the current PC (program counter) via on offset that is added to the address of the next instruction  Address Space Primary memory (RAM) is constituted via adress spaces</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/04_lecture/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/04_lecture/</guid>
      <description>Signals and Bit Transmission Introduction Data Transmission - Bit to Signal to Bit: sits directly on the physical medium (eg cable) Layer 1 in the ISO/OSI and Internet Reference (TCP/IP) Model transmission of unstructured bit sequences via physical medium data transmission entails the physical connection and the conversion between data &amp;lt;-&amp;gt; signals there are norms for interfaces (especially for physical interfaces)  Signals and their Parameters A signal is a state or a modification of material systems.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/05_lecture/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/05_lecture/</guid>
      <description>SSL/TLS Wiki: Transport Layer Security (TLS), and its now-deprecated predecessor, Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. Several versions of the protocols find widespread use in applications such as web browsing, email, instant messaging, and voice over IP (VoIP). Websites can use TLS to secure all communications between their servers and web browsers.
The TLS protocol aims primarily to provide privacy and data integrity between two or more communicating computer applications.</description>
    </item>
    
    <item>
      <title>Operating Systems - Scheduling</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</link>
      <pubDate>Thu, 25 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/04_lecture/</guid>
      <description>Introduction A &amp;ldquo;process&amp;rdquo; is a concept of virtualization of the hardware resource CPU. There&#39;s a strategy to decide which process is allowed to use the CPU at what time and there&#39;s a mechanism which refers to the way the strategy is carried out. Dispatching as the mechanism is what we covered in the last lecture. In this lecture we take a look at the strategy.Generally scheduling means the temporal assignment (zeitliche Zuordnung) of activities to ressources in regards.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/04_lecture/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/04_lecture/</guid>
      <description>Not so much related to rest of lecture:
OWASP The Open Web Application Security Project is a worldwide not-for-profit charitable organization focusing on improving the security of software, which issues software tools and knowledge-based documentation on application security
Security Mechanisms for Distributed Software Cryptography Cryptography is a broad field, which is only briefly touched in this lecture. The methods we&#39;ll use in this lecure are:
 one key (symmetric algorithms)     both participants use the same key (for de- and encryption) the key therefore has to be transmitted aswell (risk)   two keys (asymmetric algorithms)     a public key is used to encrypt a message which can only be decrypted with the according private key → private key is not submitted (thus more secure)   hybrid methods     session key is encrypted with public key and transmitted and then gets decrypted with private key session key is used to encrypt data/message and now the receiver can decrypt it with the earlier decrypted session key   one-way hash functions  compression  inputs of arbitrary length are mapped to outputs with fixed length   irreversibility (surjective function)  input can not be inferred from the output   collision-resistant  a hash function \(h()\) is called collision resistant - if it is hard to find to find two inputs \(a\) and \(b\) such that \(h(a)=h(b)\) and \(a \neq b\)      Public key cryptography visualized</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/03_lecture/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/03_lecture/</guid>
      <description>Basic model of (tele)communication    participants act either as a sender or receiver usage of the service occurs at a special interface (API) and by using a service address point the medium bridges the spatial (raeumlich) distance  The following image shows a layer model which shows the reduction of deficits from bottom to top:There are certain principles to structure communication. These principles are also called communication protocols or short protocols and define a set of rules which communication between two or more parties has to follow/obey.</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/03_lecture/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/03_lecture/</guid>
      <description>Attacks on End Systems Attacks on end systems via
 computer viruses computer worms trojan horses exploits cracking systems  might focus on
 unsecured computer systems exploiting programming errors bad security measures weak passwords  Computer Virus
 based on biological model infects resources of the host system to replicate itself malicious functions  load generation data corruption spying   various types  boot sector viruses file viruses macro viruses script viruses composites   self-defense mechanisms of viruses:  stealth modification cryptographic methods polymorphism retroviruses (against anti-virus programs)   passive distribution: by embedding into other programs and execution by the host system  Computer Worm</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/04_lecture/</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/04_lecture/</guid>
      <description>Efficient Sorting Algorithms 1. Quicksort For applying the quicksort sorting algorithm we first choose a (random) pivot element (Drehpunkt/Mittelpunkt/Achse). The array gets partitioned into two virtual arrays. Virtual in this case means that the original array and the allocated memory for the original array is used for virtual subarrays. The first &amp;ldquo;subarray&amp;rdquo; holds all elements which are less than or equal to the pivot element, the other &amp;ldquo;subarray&amp;rdquo; holds all elements which are greater than or equal to the pivot element.</description>
    </item>
    
    <item>
      <title>Operating Systems - Processes</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</link>
      <pubDate>Thu, 11 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/03_lecture/</guid>
      <description>The term process serves as an abstraction for the cooporation between CPU, OS, resources and programs. There are different definitions in the literature tho:
 unit of an activity from the OS / programmers view executing instance of a program unit of protection (virtual) adress space collection of resources  Wiki: A process is the instance of a computer program that is being executed. It contains the program code and its activity.</description>
    </item>
    
    <item>
      <title>Computer Science II - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs2/02-lecture/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs2/02-lecture/</guid>
      <description>After repeating some pointer basics in the last lecture, we continued with some more pointer stuff in this lecture and also introduced C++ references.
Pointer to Functions What follows is an example that let&#39;s the user choose a function which shall be executed (late binding, dynamic binding)
#include &amp;lt;iostream&amp;gt; using namespace std; int max(int x, int y) { return x &amp;gt; y ? x : y; // ternary operator } int min(int x, int y) { return x &amp;lt; y ?</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/03_lecture/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/03_lecture/</guid>
      <description>Simple Sorting Algorithms In this lecture we&#39;re looking at simple array sorting algorithms. There are multiple criteria for judging an (sorting) algorithm:
 performance  amount of comparison operations amount of data shifts (Datenverschiebungen) we neglect unimportant details and only count comparison and shifts of the data that we want to sort   data distribution  some of the algorithms differ in their efficiency in regards to how the data is sorted beforehand we distinguish between data that is already sorted (best case), data that is inversly sorted (worst case) and data that is unsorted (average case)   decomposability (Zerlegbarkeit)  is the sorting algorithm suitable for external sorting?</description>
    </item>
    
    <item>
      <title>Databases &amp; Webtechnology - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/dbw/02_lecture/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/dbw/02_lecture/</guid>
      <description>Client Webtechnology In the last lecture we looked at different kinds of server-side webtechnology. In this lecture we turn our attention to client-side webtechnology.
1. Persistent Code 1.1 External applications / Tools (Hilfsprogramme) External tools enable the display of non-HTML data / files and is (analogous to CGI on server-side) independant of the client process. External tools/application are full standalone programs that are called by the browser (client) to display data that&#39;s not HTML.</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/02_lecture/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/02_lecture/</guid>
      <description>Back to the roots of the InternetThe internet consists of
 a set of computers which  use the same network protocol (TCP/IP) are somehow (directly or indirectly) connected to each other offer or use certain services   a set of (human or technical) users which access and use services and a set of further networks accessible via gateways  The most commonly used Internet services are:
 World Wide Web (www)  platform for hypermedial information exchange based on the Hypertext Transfer Protocol (HTTP)   Email  exchange of multimedial messages based on the Simple Mail Transfer Protocol (SMTP)   File Exchange  access and transmission of files based on File Transfer Protocol (FTP)   Network Management  surveillance and control of connected systems based on Simple Network Management Protocol (SNMP)    Model of a simple transmission system:</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/02_lecture/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/02_lecture/</guid>
      <description>We can achieve the security goals mentioned in the previours lecture by:
 information encryption implementation of authentication establishment of security activities monitoring of the system or the network in terms of attacks continous reduction of weak spots etc    In the data transfer model (2 users communicating) we can distinguish for example two types of attackers:
 passive attacker  can only listen, not manipulate confidentiality threat   active attacker  can listen, change, delete, duplicate threat for confidentiality, integrity and authenticity    The difference between authenticity and liability lays in the focus between internal and external relationships.</description>
    </item>
    
    <item>
      <title>Artificial Intelligence - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ai/01_lecture/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ai/01_lecture/</guid>
      <description>Not much to write about this lecture since it was mostly an introduction and generic overview of the field. The lecturant was also half an hour late so that didn&#39;t help either. There won&#39;t be posts about this course if the input does not increase :P</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/02_lecture/</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/02_lecture/</guid>
      <description>Continuing the repetition of some Algorithm lectures we went over pointers again.
int* pi; // pointer to int value (undefined) char** ppc; // pointer to char pointer (= pointer that points to a pointer pointing to a char :D)  int i = 1; pi = &amp;amp;i; // assign address of i to pi  int x = 1, y; int* px = &amp;amp;x; // pointer to x int** ppx = &amp;amp;px; // pointer to pointer of x **ppx = *px + 1; // double deferencing via &amp;#39;**&amp;#39;, equals x = x + 1 y = **ppx + 2; // double deferencing via &amp;#39;**&amp;#39;, equals y = x + 2 Now onto some new stuff!</description>
    </item>
    
    <item>
      <title>Operating Systems - Operating System Design</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 10:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/02_lecture/</guid>
      <description>Complex systems consist of single component. Therefore the successfull design of a complex system requires knowledge about the variants and relations of the components.There are some fundamental, reoccuring concepts when it comes to operating systems:
 virtualization  refers to the act of creating a virtual (rather than actual) version of something, including virtual computer hardware platforms, storage devices, and computer network resources the things &amp;ldquo;created&amp;rdquo; by virtualizing often don&#39;t exist (or not the required amount or in the quality) for example relevant for processes, memory space   concurrency  ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome allows for parallel execution of the concurrent units, which can significantly improve overall speed of the execution in multi-processor and multi-core systems allows execution without a linear order for example relevant for threads, IPC, resource management   persistence  refers to the characteristic of state that outlives the process that created it achieved in practice by storing the state as data in computer data storage for example relevant for file systems, files, nonvolatile (persistent) storage    This course will mainly deal with virtualization and concurrency since persistence is a subject of the database modules.</description>
    </item>
    
    <item>
      <title>Computer Science II - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs2/01-lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs2/01-lecture/</guid>
      <description>Computer Science II basically continues where CS I left off. Both lectures are based on a script that is split into two parts. These weeks lecture introduced pointers. Therefore I&#39;ll keep it short because there already a lot of posts for lectures regarding pointers on this page :) and at this point is not really a new or special topic.
Pointers Every variable has a memory adress. In case of arrays the base adress of the variable points to the beginning of an array eg the &amp;amp;a is the same adress as &amp;amp;a[0].</description>
    </item>
    
    <item>
      <title>Datastructures - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/01_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/01_lecture/</guid>
      <description>In the first lectures of the datastructures we&#39;ll repeat a few things that were already covered in the Algorithm &amp;amp; Programming Lecture so you may want to refer those blog posts as well. After all both courses belong to the same module.
Computational Effort &amp;amp; Complexity To compare datastructures and algorithms in regards to efficiency we need a way to measure the &amp;ldquo;cost&amp;rdquo; / computational effort. This is done by counting the required computing &amp;ldquo;steps&amp;rdquo; (Rechenschritte).</description>
    </item>
    
    <item>
      <title>Operating Systems - Introduction</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/os/01_lecture/</guid>
      <description>Although Operating Systems depend on the underlying hardware, there general principles that are common across different operating systems and this is the topic of this course. There are two different ways to &amp;ldquo;view&amp;rdquo; an operating system (2 Sichten):
 Top Down View (OS as a virtual machine)  offers an abstract view on the hardware real hardware characteristics are sort of hidden take for example the harddrive and the file system:  real machine (hardware): a sequence of data blocks of fixed size virtual machine: named files of variable size     Bottom Up View (OS as a resource manager)  OS coordinates the access on CPU, Memory, Storage etc.</description>
    </item>
    
    <item>
      <title>Databases &amp; Webtechnology - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/dbw/01_lecture/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/dbw/01_lecture/</guid>
      <description>Organizational Tutorial Dates: 09.04, 16.04, 23.04, 30.04, 07.05, 14.05, 20.05 (Project Start), 23.06 (Project End), 01.07-12.07 (Project Presentation ~15 minutes)
IT-Architectures Throughout times there where different architectures favored or dominant. In the beginning there were mostly monolithic architectures. Mainframes are an example of monolithic architecture and are nowadays used primarily by large organizations for critical applications; bulk data processing, such as census, industry and consumer statistics, enterprise resource planning; and transaction processing.</description>
    </item>
    
    <item>
      <title>Computer Networks - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cn/01_lecture/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cn/01_lecture/</guid>
      <description>This was the first lecture in the new summer semester and therefore it was mostly about organizational stuff. Here are the most important points:
 the exam is gonna be a written one and might be open-book the start of the tutorials will be announced on the course website sometime in April (registration via opal) there are gonna be exercises to hand in  those can be found here   the main programming language used will be python  Fundamental literature:</description>
    </item>
    
    <item>
      <title>Security of Distributed Software - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/sds/01_lecture/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/sds/01_lecture/</guid>
      <description>This was the first lecture in the new summer semester and therefore it was mostly about organizational stuff. Here are the most important points:
 the exam is gonna be a written one and might be open-book the start of the tutorials will be announced on the course website sometime in April (registration via opal) there are gonna be exercises to hand in  those can be found here    Distributed Solution DesignThe increasing decentralization of public networks by deregulation of telecommunications markets leads to increasingly extensive use of the Web and increasing usage of the open &amp;amp; decentralized Internet.</description>
    </item>
    
    <item>
      <title>Course Information Summer 19</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/org/sose19/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/org/sose19/</guid>
      <description>Dates Okay so the new semester started (01.04.19). Here&#39;s an overview of the most important stuff:
Start Lecture Period: 01.04.2019 End Lecture Period: 12.07.2019
Beginn of central examination period: 15.07.2019 End of central examination period: 10.08.2019
Re-matriculation Period: 03.06. - 13.09.2019
Courses and related links  Datastructures  Material PVL: at least 50% of homework correct and handed in here Exam type: written   Operating Systems  Course Homepage Tutorial Page Exam type: written   Artificial Intelligence  Course Homepage Exam type: written   Security of Distributed Software  Course Homepage Tutorial Page Exam type: written (might be open-book)   Media Encoding  Course Homepage Exam type: written   Databases &amp;amp; Webtechnology  Material Exam type: project until 23.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 22 &amp; 23</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/21-lecture/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/21-lecture/</guid>
      <description>This chapter spans two lectures so lecture 22 and 23 will be pooled into this single blog post.
Linker and Libraries In the last chapter where we built a game we split functionality into different modules which had their own source file. The linker was responsible for assembling the single modules together. We now want to take a more detailed look into the linker.
The following image shows where the linker is involved:</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 20 &amp; 21</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/20-lecture/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/20-lecture/</guid>
      <description>In this lecture chapter we turn our attention to a little project to use some of the learned skills together to build something. Therefore we build a &amp;ldquo;game&amp;rdquo;. Because the emphasis is on the development cycle, there will also be preliminary and &amp;ldquo;wrong&amp;rdquo; solutions.
I might refer to the slides more often in the next two posts that regard this &amp;ldquo;game&amp;rdquo; because it would get pretty messy else and just copy &amp;amp; pasting code is not a good use of time, so I might skip that at some points and tell you to look at the slides directly.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 10</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/10-lecture/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/10-lecture/</guid>
      <description>Development Cycle We&#39;re still in the realm of the development cycle (see post to last week&#39;s lecture) and continue with the next step which is &amp;ldquo;Implementation&amp;rdquo;.
Implementation Implementation is the step where the draft from the other steps is brought into a format that can be processed by the machine/computer. There&#39;s a concrete technical basis that has to be considered:
 detailed language specification (&amp;ldquo;detaillierter Sprachumfang&amp;rdquo;) implementation specifications ((co)domains, etc.) operating system usable standard software (eg libraries for arithmetic, graphics, string &amp;amp; list manipulation and data management)  Translation &amp;amp; Integration Here&#39;re some possible procedures when translating source code from programming languages:</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 19</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/19-lecture/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/19-lecture/</guid>
      <description>This lecture directly builds on lecture 18 so make sure to be in the picture about what we did there.
Text Search In lecture 18 we ended with the pseudocode implementation of our search algorithm and now we want to implement it in C. As a refresher here&#39;s the pseudocode once again:
// str is file/text buffer and p is search string Require: str and p is text, length(str) &amp;gt; length(p) Ensure: returns index of first appearance of p in str procedure SIMPLE-SEARCH(str, p) pos = 1 while pos &amp;lt; length(str) - length(p) do j = 1 while ((j &amp;lt;= length(p)) and (str[pos+j-1]) = p[j]) do if j = length(p) then // found 1st occ of search string  return pos endif j = j+1 end while pos = pos + 1 end while return &amp;#34;not found&amp;#34; end procedure As you can see in the line if j = length(p) then .</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 18</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/18-lecture/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/18-lecture/</guid>
      <description>Text Search Files Bigger volumes of data are usually not entered interactively but rather stored in files. That&#39;s why we take a look at files first: A file is a set of data that logically belongs together and is treated as a unit. Files are usually acessed by a file name that is known to the operating system and get stored on persistant data volumes (eg harddrives).
Files can be organized differently.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 09</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/09-lecture/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/09-lecture/</guid>
      <description>This post will be rather short (the CS posts usually are shorter anyway) because I already covered some of the stuff in the last post by accident because I wasn&#39;t able to attend the lecture and overestimated our progress.
Development Cycle Typically you don&#39;t hear the task/problem and start writing code immediately. Because usually real world problems are not trivial. Here&#39;s an outline of how things should/may go:
Specification (input = task/problem; resolve conflicts &amp;amp; misunderstandings; output = functional requirements) → Design (Entwurf; input = functional requirements; output = design) → Implementation (input = design output = source code) → Compilation (input = source code; possibly throw errors; output = executable)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/07-lecture/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/07-lecture/</guid>
      <description>This lecture is the third part of the Introduction to SQL that we began in lecture 5.
Introduction to SQL What we&#39;ll cover here:
 Data Manipulation  create, update, delete data   Data Definition  data integrity rules / constraints   Relational Views (Relationale Sichten)  Data Manipulation Create Data With the command insert tuples can be added to tables. There are different syntactical variants.
  insert a complete data set</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 17</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/17-lecture/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/17-lecture/</guid>
      <description>Recursion and Backtracking Recursion was already covered in previous lectures so you can find additional informations in those blog posts. Now we want to discuss one difference between loops and recursion and therefore we turn our attention to the datastructure stack which is used in many CPU&#39;s. The stack is a container for holding data and there are two operations associated with it:
 push → push(D, S) adds a data element D on top of the stack S (and &amp;lsquo;overlays&amp;rsquo; the other elements in S)  usually returns the modified stack S   pop → pop(S) the topmost and only visible element in S get&#39;s removed from the top of the stack and allows access to next element below it  usually returns the removed element D    A simple hardware implementation is achieved via a stack pointer that always points to the top of the stack (the topmost element).</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/08-lecture/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/08-lecture/</guid>
      <description>Disclaimer: I was not able to attend this and next weeks lectures that take place on friday because I am required to attend some course at another university in another city. That means that the blog posts 7th and 8th Computer Science I lecture and the blog posts to the 14th and 16th Algorithms &amp;amp; Programming lecture is not supplemented by the notes I usually take during the lecture. Also the slides that I cover in each post may be a bit off from what was actually covered (especially in CS01 because I &amp;ldquo;guess&amp;rdquo; what we covered, while for A&amp;amp;P a classmate hands me the covered slides)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/06-lecture/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/06-lecture/</guid>
      <description>In this lecture we continued the Introduction to SQL that we began in the last session.
Introduction to SQL Simple Queries (One Table) All queries to a database in SQL are realized via the select statement. This is the general construction:
 select` attribute|expression` → which attributes should the result table contain? from` list of tables` → which tables are required for the query? [ where condition ] → which conditions should the result tuples fulfill?</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 15 &amp; 16</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/15-lecture/</link>
      <pubDate>Mon, 26 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/15-lecture/</guid>
      <description>This blog post contains the material covered in lecture 15 and 16 because it is the same subject and it does not make sense to split it :P.
Complexity As you&#39;ve hopefully already noticed there are algorithms that differ in regards to efficiency. Algorithmic efficiency refers to the number of computational resources (computation time and memory space) used by the algorithm.
For maximum efficiency we wish to minimize resource usage. However, different resources such as time and space complexity cannot be compared directly, so which of two algorithms is considered to be more efficient often depends on which measure of efficiency is considered most important.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 14</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/14-lecture/</link>
      <pubDate>Sat, 24 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/14-lecture/</guid>
      <description>Design and Correctness of Algorithms Pseudocode As we&#39;ve learnt in the last lecture pseudocode is one of the most popular semiformal specification languages.
Pseudocode generally defines a set of instructions, there are no strict rules on how pseudocode needs to look like, therefore there are many forms of it, which is okay as long as it is intuitively readable.
Example pseudocode for the Euclidian Algorithm:
Require: A, B ∈ N, A &amp;gt; 0 ∩ B &amp;gt; 0Ensure: a = b = gcd(A, B)a ← A; b ← Bwhile a ≠ b doif a &amp;lt; b thenb ← b - aelsea ← a - bend ifend whileThe slides note at this point that in the future we&#39;ll often look at algorithms in pseudo code.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/07-lecture/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/07-lecture/</guid>
      <description>Disclaimer: I was not able to attend this and next weeks lectures that take place on friday because I am required to attend some course at another university in another city. That means that the blog posts 7th and 8th Computer Science I lecture and the blog posts to the 14th and 16th Algorithms &amp;amp; Programming lecture is not supplemented by the notes I usually take during the lecture. Also the slides that I cover in each post may be a bit off from what was actually covered (especially in CS01 because I &amp;ldquo;guess&amp;rdquo; what we covered, while for A&amp;amp;P a classmate hands me the covered slides)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/05-lecture/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/05-lecture/</guid>
      <description>Relational Calculus (Relationenkalkül) The expressions in relational algebra form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate relation results. This way describes they way of how you come to the relation result.
There is an alternative however to describe a query result without specifying the derivation (Herleitungsvorschrift), which is called relational calculus. In relational calculus only the requirements of the desired resulting tuples are specified/described but not the way they are retrieved.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 13</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/13-lecture/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/13-lecture/</guid>
      <description>Design and Correctness of Algorithms The first slides of this lecture chapter is just some meta information about the right mindset to create algorithms, which I find to be trivial, that&#39;s why I don&#39;t repeat that here (slides 1-5).
We usually create a model for a problem (Modellierung) to abstract and reduce it. Especially mathematical concepts are suited as modeling approaches (Modellierungsansätze):
 sets, multisets permutations trees/hierarchies graphs points (geometry) polygons strings  Excourse: Graphs Graphs are often used for modelling.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 12</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/12-lecture/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/12-lecture/</guid>
      <description>Bit Operators In this lecture we started by covering bit operators. I&#39;ve also written about those here. To keep it short (look at the link for more detailed explainations):
 &amp;amp; bitwise and | bitwise or ~ bitwise not ^ bitwise xor  &amp;lt;/knowledge-database/images/bitwise-op.png &amp;gt;
Then there are the bitshift operators as well:
 8 &amp;lt;&amp;lt; n leftshift which is like multiplication with 2^n 8 &amp;gt;&amp;gt; n rightshift which is like division with 2^n  There are more operators in C.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/06-lecture/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/06-lecture/</guid>
      <description>Okay so apparently I covered most of what we did in this lecture in the last blog post already (post about lecture 05).
I&#39;ll list what we did in this lecture so you can look at those parts in the last blog post (or elsewhere :D ):
 array initialization (+ with loops) string functions mutlidimensional arrays  Because I didn&#39;t really get into multidimensional arrays in the last post and because I don&#39;t think the slides are particulary useful on that topic I&#39;ll write a bit about them here.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 11</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/11-lecture/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/11-lecture/</guid>
      <description>Logic and Abstract Machines (Automaten) Boolean Algebra Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively. Propositional logic (Aussagenlogik) is a branch of logic which deals with propositions (which can be true or false) and argument flow. Compound propositions are formed by connecting propositions by logical connectives. The propositions without logical connectives are called atomic propositions.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 10</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/10-lecture/</link>
      <pubDate>Fri, 09 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/10-lecture/</guid>
      <description>Introduction How does the compiler know whether a program is &amp;ldquo;correct&amp;rdquo; (in the sense of compilable) or not? We basically distinguish between grammar and semantics.
Grammar (like we know it from school) consists of morphology (Formenlehre v Wörtern) and syntax (Sätze). In the realm of programming morphology practically doesn&#39;t matter therefore grammar and syntax are mostly used interchangeably.
The semantics (meaning of a sentence) do not matter to the compiler.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/05-lecture/</link>
      <pubDate>Fri, 09 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/05-lecture/</guid>
      <description>A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier. It is possible to do type definitions via the following syntax typedef TYP typename;, eg typedef unsigned short ushort;
Enumerated Type Enumerated types are types that are defined with a set of custom identifiers, known as enumerators, as possible values.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/04-lecture/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/04-lecture/</guid>
      <description>Well, to be honest I would have expected that we cover the physical design phase of our database design cycle in this lecture. Turns out we didn&#39;t. Did we? I don&#39;t know :D ! It seems that lecturers tend to provide some course outline which they then don&#39;t (explicitly) follow how you would expect it.
So in this lecture it was all about relational algebra, which I think can be associated to the logical design phase (remember that the RM relational model was the central topic there), so yeah there&#39;s that :D.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 09</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/09-lecture/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/09-lecture/</guid>
      <description>Complex Types in Python There are built-in types in Python which offer similar functionality to the complex types in C and more.
Python Strings Strings are character sequences of a fixed length and are to be precise not a complex type (why?). String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).
Python strings are &amp;ldquo;immutable&amp;rdquo; which means they cannot be changed after they are created.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/08-lecture/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/08-lecture/</guid>
      <description>Complex Types In C there are so called derived types. We already know one kind of a derived type, that is pointers. There are more types though:
 composite data types (Verbunddatentypen, struct and union) enumerated data types (Aufzählungstypen, enum) array data types (Felddatentypen, arrays)  Derived types are sometimes also called complex types.
Composite data type struct The struct type can be used to deal with variables (elements/members) of different types in combination.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/04-lecture/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/04-lecture/</guid>
      <description>Comparison There are the following comparison operators which yield a boolean value ( 0 for false and ≠0 for true usually 1): ==, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=.
Assignment Shortcuts a = a+5 can be written more concise as a+=5 this is possible with all operators (*, /, %, +, -). Yes this is also possible with %:
int a,b, c; a = 5; b = 2; a %= b; // -&amp;gt; a = a % b;  cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; Which yields 1 for a.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/07-lecture/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/07-lecture/</guid>
      <description>Storage and memory Parameters Besides the named variables for which memory is allocated at compile time and anonymous variables for which memory is allocated at runtime, there is a third kind of variables → parameters.
Parameters are variables that are automatically created and initialized when a function is called.
 lifecycle → retention time (Verweilzeit) of the program in that function instance (the surrounding function) visibility → whole function body as long as it&#39;s not shadowed  Parameters are declared and defined whith the function definition.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/03-lecture/</link>
      <pubDate>Sat, 27 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/03-lecture/</guid>
      <description>Characteristics of a language Languages consist of three main characteristics:
 Lexis (specification on formation of words) Syntax (specification on formation of sentences) Semantic (meaning)  Lexis and lexical elements of C++  keywords: if, else predefined identifiers: int, char identifiers: temp1, diff  have to start with a letter (_ is allowed aswell) can then contain arbitrary amount of characters/numbers are case sensitive   special symbols: ; , : .</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/06-lecture/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/06-lecture/</guid>
      <description>Storage and memory Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:
 storing in the file system (good for big data sets but slow) storing in memory (faster but limited in some aspects as well)  We continue with the latter option (ᵔᴥᵔ).
C is theoretically able to write to and acces every place in memory.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/03-lecture/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/03-lecture/</guid>
      <description>As we have learned in the last lecture there are three distinct phases of database design:
 Conceptual Design (Lecture 02)  creation of a semantic data model that describes all important aspects from the requirement analysis primarily serves the purpose to clearly (eindeutig) communicate the data that is to be stored and its realationships in a nontechnical way   Logical Design (this lecture until ???)  transforms the conceptual model into a concrete data model, which can be implemented in a database system the logical design / data model also does not hold cocrete implementation details such as DBMS, programming language(s) or hardware   Physical Design (Lecture ?</description>
    </item>
    
    <item>
      <title>Design of Distributed Systems - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/02-lecture/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/02-lecture/</guid>
      <description>System Architectures Architecture is the fundamental organizsation of a system embodied in its components, their relationships to each other and to the environment and the principles guiding its design and evolution (Source: IEEE 1471 ← seems to be superseded by ISO/IEEE 42010).
A system is a collection of components organized to accomplish a specific function or set of functions. The term &amp;ldquo;system&amp;rdquo; encompasses individual applications, systems in the traditional sense, subsystems, systems of systems, product lines, product families, whole enterprises and other aggregations of interet.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/05-lecture/</link>
      <pubDate>Mon, 22 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/05-lecture/</guid>
      <description>Type and signature Similar to functions in math functions in C (or programming for that matter) have a domain (Defintionsbereich/Definitionsmenge) and a codomain (Wertebereich/Zielmenge). Additionally to the name a function declaration (respective definiton) contains the domain and codomain:
int euclid(int, int); The type of the return value of euclid is int and defines the codomain, which in this case is a set of integers. The domain is specified via the parameter types in this case int and int so also sets of integers.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/04-lecture/</link>
      <pubDate>Fri, 19 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/04-lecture/</guid>
      <description>Libraries and Linker In the last A&amp;amp;P post we ended with this example:
// declarations extern int printf(const char*, ...); // print format -&amp;gt; write to output extern int atoi(const char*); // ascii to integer static int euclid(int, int); int main(const int c, const char* v[]) { printf(&amp;#34;c is %d\n&amp;#34;, c); // number of command line arguments passed  printf(&amp;#34;v[0] is %s\n&amp;#34;, v[0]); // path the program  const char* arg1 = v[1]; // const because declared as const in the parameter list  const char* arg2 = v[2]; printf(&amp;#34;GCD of %s and %s is %d.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/02-lecture/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/02-lecture/</guid>
      <description>There wasn&#39;t much new stuff in this lecture because a wrong announcement was made leading to students missing the first week&#39;s lecture. Therefore we did mostly repetitions that I&#39;ll skip now and summarize the additional slides.
Data types in C++ The data type constitutes three things:
 memory mapping codomain/target set (Wertevorrat) valid operations  Standard data types:
 int = whole integers, usually 4 byte float = real numbers, usually 4-8 byte char = character (in single quotes!</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/02-lecture/</link>
      <pubDate>Wed, 17 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/02-lecture/</guid>
      <description>Information Systems The task of information systems is to save, manage, organize, distribute and steer informations in an organization. The components of such information system are the DB, DBMS, Application Software, Hardware, Developers and Users.
Databases historically developed out of the needs of operational information systems. That&#39;s why we look at the database development lifecycle with the usual requirements of information systems in mind. For smaller DBS and databases for the management of smaller data sets e.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/03-lecture/</link>
      <pubDate>Mon, 15 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/03-lecture/</guid>
      <description>Script (1-28)
Terms  CPU = A central processing unit (CPU) is the electronic circuitry within a computer that carries out the instructions of a computer program by performing the basic arithmetic, logical, control and input/output (I/O) operations specified by the instructions. The computer industry has used the term &amp;ldquo;central processing unit&amp;rdquo; at least since the early 1960s. Traditionally, the term &amp;ldquo;CPU&amp;rdquo; refers to a processor, more specifically to its processing unit and control unit (CU), distinguishing these core elements of a computer from external components such as main memory and I/O circuitry.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/02-lecture/</link>
      <pubDate>Fri, 12 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/02-lecture/</guid>
      <description>&amp;ldquo;Algorithm&amp;rdquo; - History &amp;amp; Definition The term &amp;ldquo;algorithm&amp;rdquo; goes back to a persian scholar who wrote a book with the latinized title of &amp;lsquo;Algoritmi de numero indorum&amp;rsquo;. One generic defintion of the term algorithm is that an algorithm is an instruction consisting of an finite amount of well-defined and effective steps (to achieve a certain goal).
Finitness Algorithms can be described in different ways, however it has to be guaranteed that their representation is finite, meaning it can be stored on a medium with a limited amount of space and that they have a certain maximum size that is defined.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/01-lecture/</link>
      <pubDate>Fri, 12 Oct 2018 10:35:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/01-lecture/</guid>
      <description>Organization  Course Page: tu-chemnitz.de/fritz/course Script: tu-chemnitz.de/fritz/script Lecture: Friday 07:30AM - 09:00AM Excercise/Field work: Friday 09:30AM-10:00AM  Introduction An algorithm is an ordered sequence of instructions, that can deliver a certain result with a finite amount of steps.
The binary system is a numeral system that represents numbers with 0 and 1. It therefore is base-2 while our common day to day decimal numeral system is base-10, consisting of the 10 digits: 0,1,2,3,4,5,6,8,9.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/01-lecture/</link>
      <pubDate>Wed, 10 Oct 2018 13:28:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/01-lecture/</guid>
      <description>Organization The &amp;ldquo;Database Essentials&amp;rdquo; course does not use the centralized eLearning platform as most other courses do. The lecture slides and exercise materials are instead uploaded here: https://www.tu-chemnitz.de/informatik/DVS/lehre/DBG/.
To get the credit points in this course one has first to do succeed in the prerequisites before he&#39;s allowed to participate in the written exam at the end of the semester. The prerequisites consist of homework and more details regarding those will follow when the first task is due.</description>
    </item>
    
    <item>
      <title>Design of Distributed Systems - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/01-lecture/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/01-lecture/</guid>
      <description>Definitions of Distributed Systems  Andrew S. Tanenbaum and Maarten van Steen:  „A distributed system is a collection of independent computers that appears to its users as a single coherent system.“   Alexander Schill and Thomas Springer:  „Ein Verteiltes System setzt sich aus mehreren Einzelkomponenten auf unterschiedlichen Rechnern zusammen, die in der Regel nicht über gemeinsamen Speicher verfügen und somit mittels Nachrichtenaustausch kommunizieren, um in Kooperation eine gemeinsame Zielsetzung – etwa die Realisierung eines Geschäftsablaufs – zu erreichen.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/01-lecture/</link>
      <pubDate>Mon, 08 Oct 2018 15:24:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/01-lecture/</guid>
      <description>Today was the first lecture of &amp;ldquo;Algorithms and Programming&amp;rdquo;, which is part of the module &amp;ldquo;Algorithms and Datastructures&amp;rdquo;. As it is with most lectures in the first week, we mainly talked about organizational stuff. That&#39;s probably not interesting at all for anyone besides myself so you might aswell skip this.
Links:
 Course Website: mytuc.org/smzl Opal Page: mytuc.org/lyph Complete script: AuP-Skript Rated excercise submission: Opal Link  There&#39;s accompanied programming on tuesdays and a Q &amp;amp; A session on wednesdays.</description>
    </item>
    
  </channel>
</rss>