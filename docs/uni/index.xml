<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unis on My New Hugo Site</title>
    <link>https://schoettkr.github.io/knowledge-database/uni/</link>
    <description>Recent content in Unis on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Jan 2019 00:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://schoettkr.github.io/knowledge-database/uni/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algos &amp; Programming - Lecture 22 &amp; 23</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/21-lecture/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/21-lecture/</guid>
      <description>This chapter spans two lectures so lecture 22 and 23 will be pooled into this single blog post.
Linker and Libraries In the last chapter where we built a game we split functionality into different modules which had their own source file. The linker was responsible for assembling the single modules together. We now want to take a more detailed look into the linker.
The following image shows where the linker is involved:</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 20 &amp; 21</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/20-lecture/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/20-lecture/</guid>
      <description>In this lecture chapter we turn our attention to a little project to use some of the learned skills together to build something. Therefore we build a &amp;ldquo;game&amp;rdquo;. Because the emphasis is on the development cycle, there will also be preliminary and &amp;ldquo;wrong&amp;rdquo; solutions.
I might refer to the slides more often in the next two posts that regard this &amp;ldquo;game&amp;rdquo; because it would get pretty messy else and just copy &amp;amp; pasting code is not a good use of time, so I might skip that at some points and tell you to look at the slides directly.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 10</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/10-lecture/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/10-lecture/</guid>
      <description>Development Cycle We&amp;rsquo;re still in the realm of the development cycle (see post to last week&amp;rsquo;s lecture) and continue with the next step which is &amp;ldquo;Implementation&amp;rdquo;.
Implementation Implementation is the step where the draft from the other steps is brought into a format that can be processed by the machine/computer. There&amp;rsquo;s a concrete technical basis that has to be considered:
 detailed language specification (&amp;ldquo;detaillierter Sprachumfang&amp;rdquo;) implementation specifications ((co)domains, etc.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 19</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/19-lecture/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/19-lecture/</guid>
      <description>This lecture directly builds on lecture 18 so make sure to be in the picture about what we did there.
Text Search In lecture 18 we ended with the pseudocode implementation of our search algorithm and now we want to implement it in C. As a refresher here&amp;rsquo;s the pseudocode once again:
// str is file/text buffer and p is search string Require: str and p is text, length(str) &amp;gt; length(p) Ensure: returns index of first appearance of p in str procedure SIMPLE-SEARCH(str, p) pos = 1 while pos &amp;lt; length(str) - length(p) do j = 1 while ((j &amp;lt;= length(p)) and (str[pos+j-1]) = p[j]) do if j = length(p) then // found 1st occ of search string return pos endif j = j+1 end while pos = pos + 1 end while return &amp;quot;not found&amp;quot; end procedure  As you can see in the line if j = length(p) then .</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 18</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/18-lecture/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/18-lecture/</guid>
      <description>Text Search Files Bigger volumes of data are usually not entered interactively but rather stored in files. That&amp;rsquo;s why we take a look at files first: A file is a set of data that logically belongs together and is treated as a unit. Files are usually acessed by a file name that is known to the operating system and get stored on persistant data volumes (eg harddrives).
Files can be organized differently.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 09</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/09-lecture/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/09-lecture/</guid>
      <description>This post will be rather short (the CS posts usually are shorter anyway) because I already covered some of the stuff in the last post by accident because I wasn&amp;rsquo;t able to attend the lecture and overestimated our progress.
Development Cycle Typically you don&amp;rsquo;t hear the task/problem and start writing code immediately. Because usually real world problems are not trivial. Here&amp;rsquo;s an outline of how things should/may go:
Specification (input = task/problem; resolve conflicts &amp;amp; misunderstandings; output = functional requirements) &amp;rarr; Design (Entwurf; input = functional requirements; output = design) &amp;rarr; Implementation (input = design output = source code) &amp;rarr; Compilation (input = source code; possibly throw errors; output = executable)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/07-lecture/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/07-lecture/</guid>
      <description>This lecture is the third part of the Introduction to SQL that we began in lecture 5.
Introduction to SQL What we&amp;rsquo;ll cover here:
 Data Manipulation  create, update, delete data  Data Definition  data integrity rules / constraints  Relational Views (Relationale Sichten)  Data Manipulation Create Data With the command insert tuples can be added to tables. There are different syntactical variants.
 insert a complete data set</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 17</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/17-lecture/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/17-lecture/</guid>
      <description>Recursion and Backtracking Recursion was already covered in previous lectures so you can find additional informations in those blog posts. Now we want to discuss one difference between loops and recursion and therefore we turn our attention to the datastructure stack which is used in many CPU&amp;rsquo;s. The stack is a container for holding data and there are two operations associated with it:
 push &amp;rarr; push(D, S) adds a data element D on top of the stack S (and &amp;lsquo;overlays&amp;rsquo; the other elements in S)  usually returns the modified stack S  pop &amp;rarr; pop(S) the topmost and only visible element in S get&amp;rsquo;s removed from the top of the stack and allows access to next element below it  usually returns the removed element D   A simple hardware implementation is achieved via a stack pointer that always points to the top of the stack (the topmost element).</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/08-lecture/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/08-lecture/</guid>
      <description>Disclaimer: I was not able to attend this and next weeks lectures that take place on friday because I am required to attend some course at another university in another city. That means that the blog posts 7th and 8th Computer Science I lecture and the blog posts to the 14th and 16th Algorithms &amp;amp; Programming lecture is not supplemented by the notes I usually take during the lecture. Also the slides that I cover in each post may be a bit off from what was actually covered (especially in CS01 because I &amp;ldquo;guess&amp;rdquo; what we covered, while for A&amp;amp;P a classmate hands me the covered slides)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/06-lecture/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/06-lecture/</guid>
      <description>In this lecture we continued the Introduction to SQL that we began in the last session.
Introduction to SQL Simple Queries (One Table) All queries to a database in SQL are realized via the select statement. This is the general construction:
 select attribute|expression &amp;rarr; which attributes should the result table contain? from list of tables &amp;rarr; which tables are required for the query? [ where condition ] &amp;rarr; which conditions should the result tuples fulfill?</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 15 &amp; 16</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/15-lecture/</link>
      <pubDate>Mon, 26 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/15-lecture/</guid>
      <description>This blog post contains the material covered in lecture 15 and 16 because it is the same subject and it does not make sense to split it :P.
Complexity As you&amp;rsquo;ve hopefully already noticed there are algorithms that differ in regards to efficiency. Algorithmic efficiency refers to the number of computational resources (computation time and memory space) used by the algorithm.
For maximum efficiency we wish to minimize resource usage.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 14</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/14-lecture/</link>
      <pubDate>Sat, 24 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/14-lecture/</guid>
      <description>Design and Correctness of Algorithms Pseudocode As we&amp;rsquo;ve learnt in the last lecture pseudocode is one of the most popular semiformal specification languages.
Pseudocode generally defines a set of instructions, there are no strict rules on how pseudocode needs to look like, therefore there are many forms of it, which is okay as long as it is intuitively readable.
Example pseudocode for the Euclidian Algorithm:
 Require: A, B &amp;isin; N, A &amp;gt; 0 &amp;cap; B &amp;gt; 0</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/07-lecture/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/07-lecture/</guid>
      <description>Disclaimer: I was not able to attend this and next weeks lectures that take place on friday because I am required to attend some course at another university in another city. That means that the blog posts 7th and 8th Computer Science I lecture and the blog posts to the 14th and 16th Algorithms &amp;amp; Programming lecture is not supplemented by the notes I usually take during the lecture. Also the slides that I cover in each post may be a bit off from what was actually covered (especially in CS01 because I &amp;ldquo;guess&amp;rdquo; what we covered, while for A&amp;amp;P a classmate hands me the covered slides)</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/05-lecture/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/05-lecture/</guid>
      <description>Relational Calculus (Relationenkalkül) The expressions in relational algebra form a procedural way of describing the way to an result. The resulting relation is in turn derived from intermediate relation results. This way describes they way of how you come to the relation result.
There is an alternative however to describe a query result without specifying the derivation (Herleitungsvorschrift), which is called relational calculus. In relational calculus only the requirements of the desired resulting tuples are specified/described but not the way they are retrieved.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 13</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/13-lecture/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/13-lecture/</guid>
      <description>Design and Correctness of Algorithms The first slides of this lecture chapter is just some meta information about the right mindset to create algorithms, which I find to be trivial, that&amp;rsquo;s why I don&amp;rsquo;t repeat that here (slides 1-5).
We usually create a model for a problem (Modellierung) to abstract and reduce it. Especially mathematical concepts are suited as modeling approaches (Modellierungsansätze):
 sets, multisets permutations trees/hierarchies graphs points (geometry) polygons strings  Excourse: Graphs Graphs are often used for modelling.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 12</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/12-lecture/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/12-lecture/</guid>
      <description>Bit Operators In this lecture we started by covering bit operators. I&amp;rsquo;ve also written about those here. To keep it short (look at the link for more detailed explainations):
 &amp;amp; bitwise and | bitwise or ~ bitwise not ^ bitwise xor  Then there are the bitshift operators as well:
 8 &amp;lt;&amp;lt; n leftshift which is like multiplication with 2^n 8 &amp;gt;&amp;gt; n rightshift which is like division with 2^n  There are more operators in C.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/06-lecture/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/06-lecture/</guid>
      <description>Okay so apparently I covered most of what we did in this lecture in the last blog post already (post about lecture 05).
I&amp;rsquo;ll list what we did in this lecture so you can look at those parts in the last blog post (or elsewhere :D ):
 array initialization (+ with loops) string functions mutlidimensional arrays  Because I didn&amp;rsquo;t really get into multidimensional arrays in the last post and because I don&amp;rsquo;t think the slides are particulary useful on that topic I&amp;rsquo;ll write a bit about them here.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 11</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/11-lecture/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/11-lecture/</guid>
      <description>Logic and Abstract Machines (Automaten) Boolean Algebra Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively. Propositional logic (Aussagenlogik) is a branch of logic which deals with propositions (which can be true or false) and argument flow. Compound propositions are formed by connecting propositions by logical connectives. The propositions without logical connectives are called atomic propositions.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 10</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/10-lecture/</link>
      <pubDate>Fri, 09 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/10-lecture/</guid>
      <description>Introduction How does the compiler know whether a program is &amp;ldquo;correct&amp;rdquo; (in the sense of compilable) or not? We basically distinguish between grammar and semantics.
Grammar (like we know it from school) consists of morphology (Formenlehre v Wörtern) and syntax (Sätze). In the realm of programming morphology practically doesn&amp;rsquo;t matter therefore grammar and syntax are mostly used interchangeably.
The semantics (meaning of a sentence) do not matter to the compiler.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/05-lecture/</link>
      <pubDate>Fri, 09 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/05-lecture/</guid>
      <description>A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier. It is possible to do type definitions via the following syntax typedef TYP typename;, eg typedef unsigned short ushort;
Enumerated Type Enumerated types are types that are defined with a set of custom identifiers, known as enumerators, as possible values.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/04-lecture/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/04-lecture/</guid>
      <description>Well, to be honest I would have expected that we cover the physical design phase of our database design cycle in this lecture. Turns out we didn&amp;rsquo;t. Did we? I don&amp;rsquo;t know :D ! It seems that lecturers tend to provide some course outline which they then don&amp;rsquo;t (explicitly) follow how you would expect it.
So in this lecture it was all about relational algebra, which I think can be associated to the logical design phase (remember that the RM relational model was the central topic there), so yeah there&amp;rsquo;s that :D.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 09</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/09-lecture/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/09-lecture/</guid>
      <description>Complex Types in Python There are built-in types in Python which offer similar functionality to the complex types in C and more.
Python Strings Strings are character sequences of a fixed length and are to be precise not a complex type (why?). String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).
Python strings are &amp;ldquo;immutable&amp;rdquo; which means they cannot be changed after they are created.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 08</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/08-lecture/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/08-lecture/</guid>
      <description>Complex Types In C there are so called derived types. We already know one kind of a derived type, that is pointers. There are more types though:
 composite data types (Verbunddatentypen, struct and union) enumerated data types (Aufzählungstypen, enum) array data types (Felddatentypen, arrays)  Derived types are sometimes also called complex types.
Composite data type struct The struct type can be used to deal with variables (elements/members) of different types in combination.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/04-lecture/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/04-lecture/</guid>
      <description>Comparison There are the following comparison operators which yield a boolean value ( 0 for false and ≠0 for true usually 1): ==, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=.
Assignment Shortcuts a = a+5 can be written more concise as a+=5 this is possible with all operators (*, /, %, +, -). Yes this is also possible with %:
int a,b, c; a = 5; b = 2; a %= b; // -&amp;gt; a = a % b; cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;  Which yields 1 for a.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 07</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/07-lecture/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0100</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/07-lecture/</guid>
      <description>Storage and memory Parameters Besides the named variables for which memory is allocated at compile time and anonymous variables for which memory is allocated at runtime, there is a third kind of variables &amp;rarr; parameters.
Parameters are variables that are automatically created and initialized when a function is called.
 lifecycle &amp;rarr; retention time (Verweilzeit) of the program in that function instance (the surrounding function) visibility &amp;rarr; whole function body as long as it&amp;rsquo;s not shadowed  Parameters are declared and defined whith the function definition.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/03-lecture/</link>
      <pubDate>Sat, 27 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/03-lecture/</guid>
      <description>Characteristics of a language Languages consist of three main characteristics:
 Lexis (specification on formation of words) Syntax (specification on formation of sentences) Semantic (meaning)  Lexis and lexical elements of C++  keywords: if, else predefined identifiers: int, char identifiers: temp1, diff  have to start with a letter (_ is allowed aswell) can then contain arbitrary amount of characters/numbers are case sensitive  special symbols: ; , : .</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 06</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/06-lecture/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/06-lecture/</guid>
      <description>Storage and memory Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:
 storing in the file system (good for big data sets but slow) storing in memory (faster but limited in some aspects as well)  We continue with the latter option (ᵔᴥᵔ).
C is theoretically able to write to and acces every place in memory.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/03-lecture/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/03-lecture/</guid>
      <description>As we have learned in the last lecture there are three distinct phases of database design:
 Conceptual Design (Lecture 02)  creation of a semantic data model that describes all important aspects from the requirement analysis primarily serves the purpose to clearly (eindeutig) communicate the data that is to be stored and its realationships in a nontechnical way  Logical Design (this lecture until ???)  transforms the conceptual model into a concrete data model, which can be implemented in a database system the logical design / data model also does not hold cocrete implementation details such as DBMS, programming language(s) or hardware  Physical Design (Lecture ?</description>
    </item>
    
    <item>
      <title>Design of Distributed Systems - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/02-lecture/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/02-lecture/</guid>
      <description>System Architectures Architecture is the fundamental organizsation of a system embodied in its components, their relationships to each other and to the environment and the principles guiding its design and evolution (Source: IEEE 1471 &amp;larr; seems to be superseded by ISO/IEEE 42010).
A system is a collection of components organized to accomplish a specific function or set of functions. The term &amp;ldquo;system&amp;rdquo; encompasses individual applications, systems in the traditional sense, subsystems, systems of systems, product lines, product families, whole enterprises and other aggregations of interet.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 05</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/05-lecture/</link>
      <pubDate>Mon, 22 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/05-lecture/</guid>
      <description>Type and signature Similar to functions in math functions in C (or programming for that matter) have a domain (Defintionsbereich/Definitionsmenge) and a codomain (Wertebereich/Zielmenge). Additionally to the name a function declaration (respective definiton) contains the domain and codomain:
int euclid(int, int);  The type of the return value of euclid is int and defines the codomain, which in this case is a set of integers. The domain is specified via the parameter types in this case int and int so also sets of integers.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 04</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/04-lecture/</link>
      <pubDate>Fri, 19 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/04-lecture/</guid>
      <description>Libraries and Linker In the last A&amp;amp;P post we ended with this example:
// declarations extern int printf(const char*, ...); // print format -&amp;gt; write to output extern int atoi(const char*); // ascii to integer static int euclid(int, int); int main(const int c, const char* v[]) { printf(&amp;quot;c is %d\n&amp;quot;, c); // number of command line arguments passed printf(&amp;quot;v[0] is %s\n&amp;quot;, v[0]); // path the program const char* arg1 = v[1]; // const because declared as const in the parameter list const char* arg2 = v[2]; printf(&amp;quot;GCD of %s and %s is %d.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/02-lecture/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/02-lecture/</guid>
      <description>There wasn&amp;rsquo;t much new stuff in this lecture because a wrong announcement was made leading to students missing the first week&amp;rsquo;s lecture. Therefore we did mostly repetitions that I&amp;rsquo;ll skip now and summarize the additional slides.
Data types in C++ The data type constitutes three things:
 memory mapping codomain/target set (Wertevorrat) valid operations  Standard data types:
 int = whole integers, usually 4 byte float = real numbers, usually 4-8 byte char = character (in single quotes!</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/02-lecture/</link>
      <pubDate>Wed, 17 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/02-lecture/</guid>
      <description>Information Systems The task of information systems is to save, manage, organize, distribute and steer informations in an organization. The components of such information system are the DB, DBMS, Application Software, Hardware, Developers and Users.
Databases historically developed out of the needs of operational information systems. That&amp;rsquo;s why we look at the database development lifecycle with the usual requirements of information systems in mind. For smaller DBS and databases for the management of smaller data sets e.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 03</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/03-lecture/</link>
      <pubDate>Mon, 15 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/03-lecture/</guid>
      <description>Script (1-28)
Terms  CPU = A central processing unit (CPU) is the electronic circuitry within a computer that carries out the instructions of a computer program by performing the basic arithmetic, logical, control and input/output (I/O) operations specified by the instructions. The computer industry has used the term &amp;ldquo;central processing unit&amp;rdquo; at least since the early 1960s. Traditionally, the term &amp;ldquo;CPU&amp;rdquo; refers to a processor, more specifically to its processing unit and control unit (CU), distinguishing these core elements of a computer from external components such as main memory and I/O circuitry.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 02</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/02-lecture/</link>
      <pubDate>Fri, 12 Oct 2018 14:57:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/02-lecture/</guid>
      <description>&amp;ldquo;Algorithm&amp;rdquo; - History &amp;amp; Definition The term &amp;ldquo;algorithm&amp;rdquo; goes back to a persian scholar who wrote a book with the latinized title of &amp;lsquo;Algoritmi de numero indorum&amp;rsquo;. One generic defintion of the term algorithm is that an algorithm is an instruction consisting of an finite amount of well-defined and effective steps (to achieve a certain goal).
Finitness Algorithms can be described in different ways, however it has to be guaranteed that their representation is finite, meaning it can be stored on a medium with a limited amount of space and that they have a certain maximum size that is defined.</description>
    </item>
    
    <item>
      <title>Computer Science I - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/cs1/01-lecture/</link>
      <pubDate>Fri, 12 Oct 2018 10:35:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/cs1/01-lecture/</guid>
      <description>Organization  Course Page: tu-chemnitz.de/fritz/course Script: tu-chemnitz.de/fritz/script Lecture: Friday 07:30AM - 09:00AM Excercise/Field work: Friday 09:30AM-10:00AM  Introduction An algorithm is an ordered sequence of instructions, that can deliver a certain result with a finite amount of steps.
The binary system is a numeral system that represents numbers with 0 and 1. It therefore is base-2 while our common day to day decimal numeral system is base-10, consisting of the 10 digits: 0,1,2,3,4,5,6,8,9.</description>
    </item>
    
    <item>
      <title>Database Essentials - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/db/01-lecture/</link>
      <pubDate>Wed, 10 Oct 2018 13:28:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/db/01-lecture/</guid>
      <description>Organization The &amp;ldquo;Database Essentials&amp;rdquo; course does not use the centralized eLearning platform as most other courses do. The lecture slides and exercise materials are instead uploaded here: https://www.tu-chemnitz.de/informatik/DVS/lehre/DBG/.
To get the credit points in this course one has first to do succeed in the prerequisites before he&amp;rsquo;s allowed to participate in the written exam at the end of the semester. The prerequisites consist of homework and more details regarding those will follow when the first task is due.</description>
    </item>
    
    <item>
      <title>Design of Distributed Systems - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/ds/01-lecture/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/ds/01-lecture/</guid>
      <description>Definitions of Distributed Systems  Andrew S. Tanenbaum and Maarten van Steen:  „A distributed system is a collection of independent computers that appears to its users as a single coherent system.“  Alexander Schill and Thomas Springer:  „Ein Verteiltes System setzt sich aus mehreren Einzelkomponenten auf unterschiedlichen Rechnern zusammen, die in der Regel nicht über gemeinsamen Speicher verfügen und somit mittels Nachrichtenaustausch kommunizieren, um in Kooperation eine gemeinsame Zielsetzung – etwa die Realisierung eines Geschäftsablaufs – zu erreichen.</description>
    </item>
    
    <item>
      <title>Algos &amp; Programming - Lecture 01</title>
      <link>https://schoettkr.github.io/knowledge-database/uni/algos/01-lecture/</link>
      <pubDate>Mon, 08 Oct 2018 15:24:00 +0200</pubDate>
      
      <guid>https://schoettkr.github.io/knowledge-database/uni/algos/01-lecture/</guid>
      <description>Today was the first lecture of &amp;ldquo;Algorithms and Programming&amp;rdquo;, which is part of the module &amp;ldquo;Algorithms and Datastructures&amp;rdquo;. As it is with most lectures in the first week, we mainly talked about organizational stuff. That&amp;rsquo;s probably not interesting at all for anyone besides myself so you might aswell skip this.
Links:
 Course Website: mytuc.org/smzl Opal Page: mytuc.org/lyph Complete script: AuP-Skript Rated excercise submission: Opal Link  There&amp;rsquo;s accompanied programming on tuesdays and a Q &amp;amp; A session on wednesdays.</description>
    </item>
    
  </channel>
</rss>