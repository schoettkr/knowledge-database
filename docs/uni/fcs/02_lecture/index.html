<!doctype html>
<html>
  <head>
    <title>Einführung in die Funktion von Computersystemen - Lecture 02: Von der Schaltungslogik zur Informationsverarbeitung // schoettkr</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.60.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Schoettkr" />
    <meta name="description" content="" />
    <base href="https://schoettkr.github.io/knowledge-database/" />
    <link rel="stylesheet" href="https://schoettkr.github.io/knowledge-database/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="./avatar.png" /></a>
      <h1>schoettkr</h1>
      <p>Software developer currently pursuing a master&#39;s degree in Germany</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/schoettkr"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Einführung in die Funktion von Computersystemen - Lecture 02: Von der Schaltungslogik zur Informationsverarbeitung</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 8, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://schoettkr.github.io/knowledge-database/tags/uni/">uni</a><a class="tag" href="https://schoettkr.github.io/knowledge-database/tags/funktion-computersysteme/">funktion-computersysteme</a></div></div>
    </header>
    <div class="post-content">
      <h2 id="schaltungslogik">Schaltungslogik</h2>
<figure>
    <img src="/knowledge-database/images/schaltungslogik.png"/> 
</figure>

<h2 id="schaltnetze">Schaltnetze</h2>
<p>Sogenannte Gatter implementieren die booleschen Funktionen. Signale werden dabei durch elektrische Spannungen dargestellt. Durch die Zusammensetzung von Gattern entstehen Logikschaltungen. Ein Schaltnetz ist eine Zusammensetzung von Verknüpfungsschaltungen ohne Speicherverhalten.<!-- raw HTML omitted -->
<img src="/knowledge-database/images/gatter.png" alt=""><!-- raw HTML omitted -->
Durch logisch vollständige Funktionen können beliebige andere Funktionen &ldquo;gebaut&rdquo; werden. Zum Beispiel lässt sich die XOR-Funktion (\(x \oplus y\)) durch NAND-Gatter wie folgt realisieren:<!-- raw HTML omitted -->
<img src="/knowledge-database/images/xor-nand.png" alt=""><!-- raw HTML omitted --></p>
<h3 id="optimierung">Optimierung</h3>
<p>Eine Schaltung ist nicht immer optimal (zB zuviel Gatter), daher gibt es Methoden zur Optimierung, die da wären Verfahren nach McCluskey und das Verfahren nach Karnaugh und Veitch, welches wir im folgenden betrachten.</p>
<h4 id="karnaugh-and-veitch-diagramm">Karnaugh &amp; Veitch - Diagramm</h4>
<ul>
<li>Funktionswerte werden in einer Matrix so angeordnet, dass sich benachbarte Felder um einen Funktionsparameter unterscheiden</li>
<li>Matrix ist als Oberfläche eines Torus aufzufassen (Ränder oben/unten sowie rechts/links sind verbunden)</li>
<li>Werte werden in Matrix eingetragen, unbekannte (don't care) werden mit φ bezeichnet</li>
<li>Blöcke gleichen Werts zu Rechtecken mit 2^n Kantenlänge zusammenfassen</li>
<li>Block entspricht Ausdruck, der von weniger Variablen abhängig ist</li>
</ul>
<p><img src="/knowledge-database/images/kv-beispiel.png" alt=""><!-- raw HTML omitted --></p>
<h2 id="schaltwerk">Schaltwerk</h2>
<ul>
<li>ein Schaltwerk zeigt (im Gegensatz zum Schaltnetz) <strong>Speicherverhalten</strong> (→ es besitzt einen Zustand)</li>
<li>durch Eingangssignale ändert sich der Zustand der Schaltung</li>
<li>einfachstes Speicherelement speichert die Zustände 0/1 → Flip-Flop</li>
</ul>
<p><img src="/knowledge-database/images/schaltwerk.png" alt=""><!-- raw HTML omitted --></p>
<h4 id="taktsteuerung-binäre-signale">Taktsteuerung / Binäre Signale</h4>
<ul>
<li>Abstraktion von Signalübergängen: Takt
<ul>
<li>Signale können dann als Rechtecksignale betrachtet werden</li>
</ul>
</li>
<li>synchrone Schaltungen: hier D-Flip-Flop (auch &ldquo;Latch&rdquo;)</li>
<li>auf die fallende Flanke an T wird der an D anliegende Datenwert (0 oder 1) &ldquo;eingefroren&rdquo;</li>
</ul>
<p><img src="/knowledge-database/images/d-flip-flop.png" alt=""><!-- raw HTML omitted --></p>
<p>Beispiel: Master-Slave-Flip-Flop<!-- raw HTML omitted --></p>
<ul>
<li>mit der steigenden Flanke des Taktes wird der gesetzte Wert in die erste Stufe übernommen</li>
<li>derweil liegt am Ausgang noch der alte Wert an</li>
<li>mit der fallenden Flanke des wird die Eingangsstufe &ldquo;versiegelt&rdquo; und der gesetzte Wert in die zweite Stufe (und den Ausgang) geschrieben</li>
</ul>
<p><img src="/knowledge-database/images/master-slave-flip-flop.png" alt=""><!-- raw HTML omitted --></p>
<h4 id="zustandsbehaftete-vs-zustandslose-schaltungen">Zustandsbehaftete vs zustandslose Schaltungen</h4>
<ul>
<li>in zustandslosen Schaltungen hängt das Ausgangssignal auschließlich vom Eingangssignal ab</li>
<li>dagegen geht in das Ausgangssignal von zustandsbehafteten Schaltungen die &ldquo;Vorgeschichte&rdquo; ein, die sich im Zustand manifestiert (hat) (→ Automatenmodell)</li>
</ul>
<p><img src="/knowledge-database/images/zustandslos-zustandsbehaftet.png" alt=""><!-- raw HTML omitted --></p>
<p><strong>Register</strong></p>
<ul>
<li>Speicherzellen für logisch zusammengehörende Einzelbits werden zu <strong>Registern</strong> zusammengefasst</li>
<li>Register bestehen aus unverbundenen Flip-Flops, die gemeinsam getaktet werden</li>
</ul>
<p><img src="/knowledge-database/images/register.png" alt=""><!-- raw HTML omitted --></p>
<p><strong>Arbeitsspeicher</strong></p>
<ul>
<li>abstraktes Modell: lineare Liste von Speicherzellen, auf die unter Angabe einer Adresse zugegriffen werden kann</li>
<li>Halbleiterspeicher: Millionen von Flip-Flops auf einem Chip</li>
<li>das Zugangssignal für jede Speicherzelle wird aus dem Wert, der auf den Adressleitungen liegt, decodiert</li>
<li>typisches Beispiel:
<ul>
<li>m = 32 (Datenwortbreite ist 32 Bit)</li>
<li>n = 24 (es können 2^24 = 16 M Worte angesprochen werden)</li>
</ul>
</li>
</ul>
<p><img src="/knowledge-database/images/arbeitsspeicher.png" alt=""><!-- raw HTML omitted --></p>
<p>Neben dem hier beschriebenen Prinzip des Speicherns durch Flip-Flops gibt es auch andere Speichertechnologien. Die Struktur (Speicherzellen, Zusammenfassung zu einem Speicherwort, Addressierung über Adressdecodierer) ist aber immer gleich.</p>
<p><strong>Schieberegister</strong></p>
<ul>
<li>mit jedem Takt wird das Datenwort um eine Stelle verschoben und das in in das &ldquo;freigewordene&rdquo; Bit der Wert des Eingangsbits \(d_{in}\) geschrieben:
<ul>
<li>\(t=t_0\), \(d_{in} = 1\): \(D=0000\)</li>
<li>\(t=t_0+1\), \(d_{in} = 1\): \(D=0001\)</li>
<li>\(t=t_0+2\), \(d_{in} = 0\): \(D=0011\)</li>
<li>\(t=t_0+3\), \(d_{in} = 1\): \(D=0110\)</li>
<li>\(t=t_0+4\), \(d_{in} = 1\): \(D=1101\)</li>
</ul>
</li>
<li>ist \(d_{in} = 0\)  so entspricht das Schieben in Richtung MSB (most significant Bit) einer <strong>Multiplikation</strong> mit 2, das Schieben in Richtung LSB (least significant Bit) einer Division mit 2</li>
</ul>
<p><img src="/knowledge-database/images/schieberegister.png" alt=""><!-- raw HTML omitted --></p>
<h4 id="addition">Addition</h4>
<ul>
<li>Addition zweier Binärzahlen kann durch logische Verknüpfungen realisiert werden (→ <strong>Halbaddierer/Half-Adder</strong>)</li>
</ul>
<p><img src="/knowledge-database/images/halfadder.png" alt=""><!-- raw HTML omitted --></p>
<ul>
<li>Berechnung von \(x+y=z+\) Übertrag (carry)</li>
<li>Übertrag zur naechsthoeheren Stelle</li>
</ul>
<p>Zur vollständigen Addition einer Stelle zweier mehrstelliger Dualzahlen muss noch der Übertrag \(c_{in}\) von vorheriger Stelle berücksichtigt werden (<strong>Volladdierer</strong>, <strong>Full Adder</strong>)<!-- raw HTML omitted -->
<img src="/knowledge-database/images/fulladder.png" alt=""><!-- raw HTML omitted --></p>
<p>Durch Zusammenschaltung mehrerer Volladdierer können zwei Datenworte <strong>beliebiger Breite</strong> addiert werden (<strong>n-Bit-Addierer</strong>).</p>
<ul>
<li>Daten werden dabei als Zahlen im Zweierkomplement aufgefasst</li>
<li>das Carry-Bit muss immer zur nächsthöheren Stufe weitergereicht werden
<ul>
<li>es muss das &ldquo;Einschwingen/pendeln&rdquo; aller n Stufen abgewartet werden, ehe das Ergebnis gültig ist</li>
</ul>
</li>
<li>es gibt spezielle Schaltungen, um die Überträge &ldquo;vorherzusagen&rdquo; und damit die Addition zu beschleunigen (schnelle Addierer)</li>
</ul>
<p><img src="/knowledge-database/images/n-bit-addierer1.png" alt="">
<img src="/knowledge-database/images/n-bit-addierer2.png" alt=""><!-- raw HTML omitted --></p>
<h4 id="akkumulation">Akkumulation</h4>
<ul>
<li>Addition mehrerer Zahlen zusammengeschalteter Addierkette und Register (<strong>Akkumulator</strong>)</li>
<li>fortgesetzte Addition beliebig vieler Zahlen möglich</li>
<li>Akkumulator sammelt Ergebnisse vorheriger Additionen</li>
</ul>
<figure>
    <img src="/knowledge-database/images/akkumulator.png"/> 
</figure>

<p>Vorgehen:</p>
<ol>
<li>AC löschen (AC := 0)</li>
<li>Addiere x zum Inhalt von AC (AC := AC + x)</li>
<li>wenn nicht fertig, gehe zu 2)</li>
</ol>
<h4 id="multiplikation">Multiplikation</h4>
<ul>
<li>&ldquo;Papier &amp; Bleistift&rdquo; Methode:</li>
</ul>
<figure>
    <img src="/knowledge-database/images/papier-bleistift.png"/> 
</figure>

<p><strong>Multiplikationsarray</strong></p>
<ul>
<li>das Papier &amp; Bleistift Verfahren wird nachempfunden
<ul>
<li>Produkt ist die Summe von Partialprodukten</li>
</ul>
</li>
<li>Nachteil: sehr hoher Aufwand, für n Bit Multiplikation werden n^2 Zellen gebraucht</li>
</ul>
<figure>
    <img src="/knowledge-database/images/multiplikationsarray.png"/> 
</figure>

<p><strong>Multiplikation mit Schieberegister</strong></p>
<ul>
<li>Faktoren in \(f\) und \(g\)</li>
<li>\(a\) und \(c = 0\)</li>
<li>wenn \(g_0\) gleich \(1\) ist wird \(f\) nach \(a\) geladen</li>
<li>das Doppelregister \(ag\) wird um eine Stelle nach rechts geschoben, das LSB des Ergebnis steht damit in \(g_{n-1}\)</li>
<li>wenn (das neue) \(g_0\) gleich \(1\) ist wird \(f\) zu dem Wert in \(a\) addiert und das Ergebnis nach \(a\) geladen</li>
<li>das Doppelregister \(ag\) wird um eine Stelle nach rechts geschoben etc</li>
<li>das Gesamtergebnis steht am Ende in \(ag\)</li>
</ul>
<figure>
    <img src="/knowledge-database/images/mult-schieberegister.png"/> 
</figure>

<hr>
<p>Additional Resources:</p>
<ul>
<li>KV Diagramm: <a href="https://www.youtube.com/watch?v=RON2FmNrR58">https://www.youtube.com/watch?v=RON2FmNrR58</a></li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  </body>
</html>
