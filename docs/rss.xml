<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knowledge Database</title><link>https://schoettkr.github.io/knowledge-database/</link><description>This is my personal knowledge database / blog.</description><atom:link href="https://schoettkr.github.io/knowledge-database/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:schoettkr@gmail.com"&gt;schoettkr&lt;/a&gt; </copyright><lastBuildDate>Fri, 09 Nov 2018 18:36:17 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Computer Science I - Lecture 05</title><link>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-05/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier.
It is possible to do type definitions via the following syntax &lt;code&gt;typedef TYP typename;&lt;/code&gt;, eg &lt;code&gt;typedef unsigned short ushort;&lt;/code&gt;
&lt;/p&gt;

&lt;div id="outline-container-orgcd6eb0d" class="outline-2"&gt;
&lt;h2 id="orgcd6eb0d"&gt;Enumerated Type&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcd6eb0d"&gt;
&lt;p&gt;
Enumerated types are types that are defined with a set of custom identifiers, known as enumerators, as possible values. Objects of these enumerated types can take any of these enumerators as value.
&lt;/p&gt;

&lt;p&gt;
Their syntax is:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;value3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;object_names&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This creates the type &lt;code&gt;type_name&lt;/code&gt;, which can take any of &lt;code&gt;value1&lt;/code&gt;, &lt;code&gt;value2&lt;/code&gt;, &lt;code&gt;value3&lt;/code&gt;, … as value. Objects (variables) of this type can directly be instantiated as &lt;code&gt;object_names&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Notice that this declaration includes no other type, neither fundamental nor compound, in its definition. To say it another way, somehow, this creates a whole new data type from scratch without basing it on any other existing type. The possible values that variables of this new type &lt;code&gt;color_t&lt;/code&gt; may take are the enumerators listed within braces. For example, once the &lt;code&gt;colors_t&lt;/code&gt; enumerated type is declared, the following expressions will be valid:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;colors_t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;testColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yourFavColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;colors_t&lt;/span&gt; &lt;span class="n"&gt;myFavColor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;myFavColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testColor&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// green is equivalent to 1&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"'testColor is "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFavColor&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;yourFavColor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"Hey we have the same favorite colors :D"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
'testColor is 1
Hey we have the same favorite colors :D

&lt;/pre&gt;

&lt;p&gt;
Values of enumerated types declared with &lt;code&gt;enum&lt;/code&gt; are implicitly convertible to an integer type, and vice versa. In fact, the elements of such an enum are always assigned an integer numerical equivalent internally, to which they can be implicitly converted to or from. If it is not specified otherwise, the integer value equivalent to the first possible value is &lt;code&gt;0&lt;/code&gt;, the equivalent to the second is &lt;code&gt;1&lt;/code&gt;, to the third is &lt;code&gt;2&lt;/code&gt;, and so on… Therefore, in the data type &lt;code&gt;colors_t&lt;/code&gt; defined above, &lt;code&gt;red&lt;/code&gt; would be equivalent to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt; would be equivalent to &lt;code&gt;1&lt;/code&gt;, blue to &lt;code&gt;2&lt;/code&gt;, and so on…
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0f5f262" class="outline-2"&gt;
&lt;h2 id="org0f5f262"&gt;Arrays&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0f5f262"&gt;
&lt;p&gt;
An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.
&lt;/p&gt;

&lt;p&gt;
That means that, for example, five values of type int can be declared as an array without having to declare 5 different variables (each with its own identifier). Instead, using an array, the five int values are stored in contiguous memory locations, and all five can be accessed using the same identifier, with the proper index.
&lt;/p&gt;

&lt;p&gt;
A typical declaration for an array in C++ is &lt;code&gt;type name [elements num];&lt;/code&gt; where &lt;code&gt;type&lt;/code&gt; is a valid type (such as int, float…), &lt;code&gt;name&lt;/code&gt; is a valid identifier and the &lt;code&gt;elements num&lt;/code&gt; (which is always enclosed in square brackets &lt;code&gt;[]&lt;/code&gt;), specifies the length of the array in terms of the number of elements.
&lt;/p&gt;

&lt;p&gt;
Therefore, the &lt;code&gt;foo&lt;/code&gt; array, with five elements of type &lt;code&gt;int&lt;/code&gt;, can be declared as: &lt;code&gt;int foo [5];&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
NOTE: The number of elements within square brackets &lt;code&gt;[]&lt;/code&gt;, representing the number of elements in the array, must be a &lt;i&gt;constant expression&lt;/i&gt;, since arrays are blocks of static memory whose size must be determined at compile time, before the program runs.
&lt;/p&gt;

&lt;p&gt;
Elements in an array can be explicitly initialized to specific values when it is declared, by enclosing those initial values in braces &lt;code&gt;{}&lt;/code&gt;. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12071&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The number of values between braces &lt;code&gt;{}&lt;/code&gt; shall not be greater than the number of elements in the array. For example, in the example above, &lt;code&gt;foo&lt;/code&gt; was declared having 5 elements (as specified by the number enclosed in square brackets, []), and the braces {} contained exactly 5 values, one for each element. If declared with less, the remaining elements are set to their default values (which for fundamental types, means they are filled with zeroes). For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Results in bar consisting of &lt;code&gt;10, 20, 30, 0, 0&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The initializer can even have no values, just the braces &lt;code&gt;int baz[5] = { };&lt;/code&gt;.
This creates an array of five int values, each initialized with a value of zero:
&lt;/p&gt;

&lt;p&gt;
When omitting the initialization completely by default, regular arrays of &lt;i&gt;local scope&lt;/i&gt; (for example, those declared within a function) are left uninitialized. This means that none of its elements are set to any particular value; their contents are undetermined at the point the array is declared.
&lt;/p&gt;

&lt;p&gt;
Static arrays, and those declared directly in a namespace (outside any function), are always initialized. If no explicit initializer is specified, all the elements are default-initialized (with zeroes, for fundamental types)
&lt;/p&gt;

&lt;p&gt;
When an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets empty &lt;code&gt;[]&lt;/code&gt;. In this case, the compiler will assume automatically a size for the array that matches the number of values included between the braces &lt;code&gt;{}&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12071&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
To access array values one uses the bracket notation:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12071&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;// -&amp;gt; 16&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;// -&amp;gt; 12071&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Char arrays are somewhat a special case. There are multiple equivalent ways to define char arrays:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;'H'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 6 because of delimiting 0&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Functions to work with such strings in C++ are provided via the header file &lt;code&gt;&amp;lt;cstring&amp;gt;&lt;/code&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;find out length via &lt;code&gt;int strlen(char *s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;comparison via &lt;code&gt;int strcmp(char *s1, char *s2)&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;returns 0 for "equal" strings (equal string content)&lt;/li&gt;
&lt;li&gt;returns &amp;lt; 0 when &lt;code&gt;s1&lt;/code&gt; is &amp;lt; than &lt;code&gt;s2&lt;/code&gt; eg s1 holds "a" which in ascii is smaller than "b" so &lt;code&gt;strcmp&lt;/code&gt; would return &lt;code&gt;-1&lt;/code&gt; because that is the difference&lt;/li&gt;
&lt;li&gt;returns &amp;gt; 0 when &lt;code&gt;s1&lt;/code&gt; is &amp;gt; than &lt;code&gt;s2&lt;/code&gt; eg &lt;code&gt;s1&lt;/code&gt; holds "c" and &lt;code&gt;s2&lt;/code&gt; holds "a" then &lt;code&gt;strcmp&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; because that is the ascii distance&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;copy strings with &lt;code&gt;char * strcpy(char *destination, char *source)&lt;/code&gt; and &lt;code&gt;char * strcat(char *destination, char *source)&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;strcpy()&lt;/code&gt; copies a string from source to destination. The function takes two string variables as arguments: the destination, and the source, then returns the updated destination variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcat()&lt;/code&gt; concatenates two strings. It appends a copy of the source string to the end of the destination string, and then returns the destination string.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdfb20a9" class="outline-2"&gt;
&lt;h2 id="orgdfb20a9"&gt;Struct&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdfb20a9"&gt;
&lt;p&gt;
A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps). There are many instances in programming where we need more than one variable in order to represent an object. For example, to represent yourself, you might want to store your name, your birthday, your height, your weight, or any other number of characteristics about yourself.
&lt;/p&gt;

&lt;p&gt;
Fortunately, C++ allows us to create our own user-defined aggregate data types. An &lt;i&gt;aggregate data type&lt;/i&gt; is a data type that groups multiple individual variables together. One of the simplest aggregate data types is the struct. A &lt;b&gt;struct&lt;/b&gt; (short for structure) allows us to group variables of mixed data types together into a single unit.
&lt;/p&gt;

&lt;p&gt;
Because structs are user-defined, we first have to tell the compiler what our struct looks like before we can begin using it. To do this, we declare our struct using the &lt;code&gt;struct&lt;/code&gt; keyword. Here is an example of a struct declaration:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Employee&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;wage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This tells the compiler that we are defining a struct named Employee. The Employee struct contains 3 variables inside of it: a short named &lt;code&gt;id&lt;/code&gt;, an int named &lt;code&gt;age&lt;/code&gt;, and a double named &lt;code&gt;wage&lt;/code&gt;. These variables that are part of the struct are called members (or fields). Keep in mind that Employee is just a declaration – even though we are telling the compiler that the struct will have member variables, no memory is allocated at this time. By convention, struct names start with a capital letter to distinguish them from variable names.
&lt;/p&gt;

&lt;p&gt;
In order to use the Employee struct, we simply declare a variable of type Employee &lt;code&gt;Employee john;&lt;/code&gt; . This defines a variable of type &lt;code&gt;Employee&lt;/code&gt; named &lt;code&gt;john&lt;/code&gt;. As with normal variables, defining a struct variable allocates memory for that variable.
&lt;/p&gt;

&lt;p&gt;
When we define a variable such as &lt;code&gt;Employee john&lt;/code&gt;, &lt;code&gt;john&lt;/code&gt; refers to the entire struct (which contains the member variables). In order to access the individual members, we use the member selection operator &lt;code&gt;.&lt;/code&gt; (which is a period). Here is an example of using the member selection operator to initialize each member variable:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;john&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// create an Employee struct for John&lt;/span&gt;
&lt;span class="n"&gt;john&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// assign a value to member id within struct john&lt;/span&gt;
&lt;span class="n"&gt;john&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// assign a value to member age within struct john&lt;/span&gt;
&lt;span class="n"&gt;john&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;24.15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// assign a value to member wage within struct john&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
As with normal variables, struct member variables are not initialized, and will typically contain junk. We must initialize them manually.
&lt;/p&gt;

&lt;p&gt;
Initializing structs by assigning values member by member is a little cumbersome, so C++ supports a faster way to initialize structs using an initializer list. This allows you to initialize some or all the members of a struct at declaration time.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Employee&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;wage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;john&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;60000.0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// john.id = 1, john.age = 32, john.wage = 60000.0&lt;/span&gt;
&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;frank&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
If the initializer list does not contain an initializer for some elements, those elements are initialized to a default value (that generally corresponds to the zero state for that type). In the above example, we see that frank.wage gets default initialized to 0.0 because we did not specify an explicit initialization value for it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-05/</guid><pubDate>Thu, 08 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 09</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgff91f12" class="outline-2"&gt;
&lt;h2 id="orgff91f12"&gt;Complex Types in Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgff91f12"&gt;
&lt;p&gt;
There are built-in types in Python which offer similar functionality to the complex types in C and more.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb8819a5" class="outline-3"&gt;
&lt;h3 id="orgb8819a5"&gt;Python Strings&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb8819a5"&gt;
&lt;p&gt;
Strings are character sequences of a fixed length and are to be precise &lt;b&gt;not&lt;/b&gt; a complex type (why?).
String literals are enclosed by double or single quotes (and triple quotes to span eg multiple lines; single quotes are most used).
&lt;/p&gt;

&lt;p&gt;
Python strings are "immutable" which means they cannot be changed after they are created. Since strings can't be changed, we construct &lt;b&gt;new&lt;/b&gt; strings as we go to represent computed values. So for example the expression &lt;code&gt;'hello' + 'there'&lt;/code&gt; takes in the 2 strings &lt;code&gt;'hello'&lt;/code&gt; and &lt;code&gt;'there'&lt;/code&gt; and builds a new string &lt;code&gt;'hellothere'&lt;/code&gt;. The resulting string has a different &lt;code&gt;id()&lt;/code&gt; because a new object is created and the others may then be garbage collected.
&lt;/p&gt;

&lt;p&gt;
Python string also recognize escape sequences similarly to C for example &lt;code&gt;'\n'&lt;/code&gt;  is recognized as a ASCII Linefeed. To prevent parsing of those one may use a &lt;i&gt;raw string&lt;/i&gt; by prepending and &lt;code&gt;r&lt;/code&gt; or &lt;code&gt;R&lt;/code&gt; to the string:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"H&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;i"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;"H\ni"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Hello"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;" World"&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Id of "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
H
i
H\ni
Id of Hello 139710321381872
Id of Hello World 139710321440048

&lt;/pre&gt;

&lt;p&gt;
Individual characters of a string can be accessed via &lt;code&gt;[]&lt;/code&gt; bracket notation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org43685ae" class="outline-3"&gt;
&lt;h3 id="org43685ae"&gt;Python Lists&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org43685ae"&gt;
&lt;p&gt;
Python has a great built-in list type named "list". List literals are written within square brackets &lt;code&gt;[ ]&lt;/code&gt;. Lists work similarly to strings - use the &lt;code&gt;len()&lt;/code&gt; function and square brackets [ ] to access data, with the first element at index &lt;code&gt;0&lt;/code&gt;. To access elements from the back use negative indices.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'red'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'green'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'red'&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Assignment with an &lt;code&gt;=&lt;/code&gt; on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.
&lt;/p&gt;

&lt;p&gt;
The "empty list" is just an empty pair of brackets &lt;code&gt;[ ]&lt;/code&gt;. The &lt;code&gt;+&lt;/code&gt; works to append two lists, so &lt;code&gt;[1, 2] + [3, 4]&lt;/code&gt; yields &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; (this is just like &lt;code&gt;+&lt;/code&gt; with strings).
&lt;/p&gt;

&lt;p&gt;
Lists in Python can (in contrast to arrays in C) hold values of different types.
&lt;/p&gt;

&lt;p&gt;
Python lists are also &lt;i&gt;mutable&lt;/i&gt;. In fact there are a lot of &lt;i&gt;methods&lt;/i&gt; to modify lists eg &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9736347" class="outline-3"&gt;
&lt;h3 id="org9736347"&gt;Python Tuples&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9736347"&gt;
&lt;p&gt;
Tuples in Python are similar to lists with the difference that they are &lt;b&gt;immutable&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.
&lt;/p&gt;

&lt;p&gt;
Creating a tuple is as simple as putting different comma-separated values. Optionally you can put these comma-separated values between parentheses also. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tup1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'physics'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'chemistry'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1997&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"b"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"c"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The empty tuple is written as two parens containing nothing &lt;code&gt;tup1 = ()&lt;/code&gt;. To write a tuple containing a single value you have to include a comma, even though there is only one value &lt;code&gt;(77,)&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Like string indices, tuple indices start at 0, and they can be sliced, concatenated, and so on.
&lt;/p&gt;

&lt;p&gt;
However if tuples are eg concatenated via &lt;code&gt;+&lt;/code&gt; a new tuple is created:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"tuple: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"with id: "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
tuple:  (1, 2) with id:  140056518200328
tuple:  (1, 2, 3, 4) with id:  140056518172568

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org468d535" class="outline-3"&gt;
&lt;h3 id="org468d535"&gt;Python Sets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org468d535"&gt;
&lt;p&gt;
Since Python 2.6 there are set types (Mengentypen). 
A Set in Python is a data structure equivalent to sets in mathematics. It may consist of various elements; the order of elements in a set is undefined. You can add and delete elements of a set, you can iterate the elements of the set, you can perform standard operations on sets (union, intersection, difference). Besides that, you can check if an element belongs to a set.
&lt;/p&gt;

&lt;p&gt;
Unlike arrays, where the elements are stored as ordered list, the order of elements in a set is undefined (moreover, the set elements are usually not stored in order of appearance in the set; this allows checking if an element belongs to a set faster than just going through all the elements of the set).
&lt;/p&gt;

&lt;p&gt;
Any immutable data type can be an element of a set: a number, a string, a tuple. Mutable (changeable) data types cannot be elements of the set. In particular, lists cannot be an element of a set (but tuple can), and another set cannot be an element of a set. The requirement of immutability follows from the way how do computers represent sets in memory.
&lt;/p&gt;

&lt;p&gt;
Sets unlike lists or tuples can't have multiple occurrences of the same element → &lt;code&gt;set('a','b','c','a','b','c')&lt;/code&gt; → &lt;code&gt;{'a','b','c'}&lt;/code&gt; no values are duplicated.
&lt;/p&gt;

&lt;p&gt;
To create a set the &lt;code&gt;set()&lt;/code&gt; is called which constructs a Python set from the given iterable and returns it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# empty set&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="c1"&gt;# from string&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Python'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# from tuple&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;# from list&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'i'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'u'&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="c1"&gt;# from range&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
set()
{'t', 'y', 'h', 'o', 'n', 'P'}
{'e', 'u', 'o', 'a', 'i'}
{'e', 'u', 'o', 'a', 'i'}
{0, 1, 2, 3, 4}

&lt;/pre&gt;

&lt;p&gt;
Sets are implemented in a way, which doesn't allow mutable objects. The following example demonstrates that we cannot include, for example, lists as elements:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="c1"&gt;# valid set of tuples&lt;/span&gt;

&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="s2"&gt;"Python"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Perl"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Berlin"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="c1"&gt;# -&amp;gt; TypeError: unhashable type: 'list'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Although sets can't contain mutable objects, sets are mutable themselves. Elements may for example added via the &lt;code&gt;add&lt;/code&gt; method (&lt;code&gt;cities.add("Tokyo")&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Frozensets are like sets except that they cannot be changed so they are immutable:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;frozenset&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;"Frankfurt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Basel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Freiburg"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Strasbourg"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# AttributeError: 'frozenset' object  has no attribute 'add'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There's also a simplified shorter notation to construct sets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"London"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paris"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Madrid"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cities&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;class 'set'&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
The known operations from set theory are also available via Python Sets (following part in German xD):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;len(s)&lt;/code&gt; gibt Mächtigkeit der Menge &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 | s2&lt;/code&gt; gibt Vereinigungsmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 &amp;amp; s2&lt;/code&gt; gibt Schnittmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 - s2&lt;/code&gt; gibt Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1 ^ s2&lt;/code&gt; gibt symmetrische Differenzmenge von &lt;code&gt;s1&lt;/code&gt; und &lt;code&gt;s1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb5b1dde" class="outline-3"&gt;
&lt;h3 id="orgb5b1dde"&gt;Python Dictionaries&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb5b1dde"&gt;
&lt;p&gt;
A dictionary is a collection which is unordered, changeable (mutable) and indexed. In Python dictionaries are written with curly brackets, and they have keys and values.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can access the items of a dictionary by referring to its key name, inside square brackets:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"brand"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Ford"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Mustang"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1964&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"key"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"model"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisdict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"year"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
value
Mustang
1964

&lt;/pre&gt;

&lt;p&gt;
More on dictionaries and how to work with them / their methods &lt;a href="https://www.w3schools.com/python/python_dictionaries.asp"&gt;here&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1933cd6" class="outline-2"&gt;
&lt;h2 id="org1933cd6"&gt;Loops and Iterations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1933cd6"&gt;
&lt;p&gt;
In C there are three types of loops:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;while loop&lt;/li&gt;
&lt;li&gt;do while loop&lt;/li&gt;
&lt;li&gt;for loop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
All of these loops use conditions are able to simulate one another. Which one to use is often a matter of personal taste.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4dfcad5" class="outline-3"&gt;
&lt;h3 id="org4dfcad5"&gt;While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4dfcad5"&gt;
&lt;p&gt;
The while loop executes as long as a conditions is true resp. until a condition is false. This is the procedure:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Check if condition &lt;code&gt;while (expression/Condition)&lt;/code&gt; evaluates to true (nonzero)&lt;/li&gt;
&lt;li&gt;If yes: execute body of the loop and jump to 1.&lt;/li&gt;
&lt;li&gt;If no: resume program execution after the loop&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Program to find factorial of a number&lt;/span&gt;
&lt;span class="c1"&gt;// For a positive integer n, factorial = 1*2*3...n&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// printf("Enter an integer: ");&lt;/span&gt;
    &lt;span class="c1"&gt;// scanf("%d",&amp;amp;number); // cannot read from stdio in my blog :)&lt;/span&gt;
    &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// loop terminates when number is less than or equal to 0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;factorial&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// factorial = factorial*number;&lt;/span&gt;
	&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

	&lt;span class="c1"&gt;// alternatively: factorial *= number--;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Factorial= %lld"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Factorial= 120

&lt;/pre&gt;

&lt;p&gt;
Loops can be used to fill fields of an array:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// constant for array size&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arraySize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 0,1,2...11&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Element %d of arr: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Element 0 of arr: 0
Element 1 of arr: 1
Element 2 of arr: 4
Element 3 of arr: 9
Element 4 of arr: 16
Element 5 of arr: 25
Element 6 of arr: 36
Element 7 of arr: 49
Element 8 of arr: 64
Element 9 of arr: 81
Element 10 of arr: 100
Element 11 of arr: 121
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5490f84" class="outline-3"&gt;
&lt;h3 id="org5490f84"&gt;Do While Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5490f84"&gt;
&lt;p&gt;
The do while loop is similar to the while loop with the difference being that the do while loop checks the condition &lt;b&gt;after&lt;/b&gt; it has run, therefore it always runs at least one time.
The syntax is
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// notice the semicolon!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5392d8c" class="outline-3"&gt;
&lt;h3 id="org5392d8c"&gt;For Loop&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5392d8c"&gt;
&lt;p&gt;
A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;mutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eg&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;decrement&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// "conditon" and "mutation" are expressions (see C standard) but that is how they're used commonly&lt;/span&gt;
  &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Here is the flow of control in a 'for' loop :
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the init step is executed first, and only once
&lt;ul class="org-ul"&gt;
&lt;li&gt;this step allows you to declare and initialize any loop control variables&lt;/li&gt;
&lt;li&gt;you are not required to put a statement here, as long as a semicolon appears&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;next, the condition is evaluated
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the body of the loop is executed&lt;/li&gt;
&lt;li&gt;if it is false, the body of the loop does not execute and the flow of control jumps to the next statement just after the 'for' loop&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;after the body of the 'for' loop executes, the flow of control jumps back up to the mutation statement
&lt;ul class="org-ul"&gt;
&lt;li&gt;this statement allows you to update any loop control variables&lt;/li&gt;
&lt;li&gt;This statement can be left blank, as long as a semicolon appears after the condition&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the condition is now evaluated again 
&lt;ul class="org-ul"&gt;
&lt;li&gt;if it is true, the loop executes and the process repeats itself (body of loop, then mutation step, and then again condition)&lt;/li&gt;
&lt;li&gt;after the condition becomes false, the 'for' loop terminates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Omitting expressions:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// omitting initalization&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d. argument: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;


  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;;)&lt;/span&gt; &lt;span class="c1"&gt;// endless loop&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The answer is 42&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 


  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// never reached&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Dont forget it is possible to have more complex conditions and multiple assignments!
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d, %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2, 1
3, 2
4, 3
5, 4

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69dc198" class="outline-3"&gt;
&lt;h3 id="org69dc198"&gt;&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-09/</guid><pubDate>Sun, 04 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 08</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-08/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgf22ea76" class="outline-2"&gt;
&lt;h2 id="orgf22ea76"&gt;Complex Types&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf22ea76"&gt;
&lt;p&gt;
In C there are so called &lt;b&gt;derived types&lt;/b&gt;. We already know one kind of a derived type, that is &lt;i&gt;pointers&lt;/i&gt;. There are more types though:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;composite data types (Verbunddatentypen, &lt;b&gt;struct&lt;/b&gt; and &lt;b&gt;union&lt;/b&gt;)&lt;/li&gt;
&lt;li&gt;enumerated data types (Aufzählungstypen, &lt;b&gt;enum&lt;/b&gt;)&lt;/li&gt;
&lt;li&gt;array data types (Felddatentypen, &lt;b&gt;arrays&lt;/b&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Derived types are sometimes also called &lt;i&gt;complex types&lt;/i&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org343ae46" class="outline-3"&gt;
&lt;h3 id="org343ae46"&gt;Composite data type &lt;code&gt;struct&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org343ae46"&gt;
&lt;p&gt;
The &lt;code&gt;struct&lt;/code&gt; type can be used to deal with variables (elements/members) of different types in combination.
A declaration of a struct type consists of the keyword &lt;code&gt;struct&lt;/code&gt;, a &lt;b&gt;name&lt;/b&gt; (tag) and a list of declarations of elements wrapped in a block of curly braces.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This declaration introduces the type and now variables of this type may be declared and defined in the usual way:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Type and varibale declaration may also be done in one step:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
It is also possible to omit the name/tag (in this case "point") to create an anonymous type:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
However when omitting the tag it is not possible to create another type of the &lt;b&gt;same&lt;/b&gt; type. Even another type that seem structurally equal won't be treated the same and behave as a different type. So remember that anonymous types are not compatible (Question: What happens if I declare multiple anonymous type variables at the same anonymous type declaration? Are those compatible?).
&lt;/p&gt;

&lt;p&gt;
To access an element of a &lt;code&gt;struct&lt;/code&gt; the &lt;code&gt;.&lt;/code&gt; operator is used.
&lt;/p&gt;

&lt;p&gt;
When declaring a &lt;code&gt;struct&lt;/code&gt; it is also possible to initialize a variable of that struct type via &lt;code&gt;varName = { .. };&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="n"&gt;pt2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;105&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
To only initialize specific elements by their name one can use the following notation with a leading dot to do so:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// order does not matter (ᵔᴥᵔ)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There are only few operations and therefore operators allowed to be used on structs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;assignment via  &lt;code&gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;retrieve address via &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;access elements via &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
It is pretty common practice in C to create anonymous struct variables (the variable is anonymous not the struct!) with malloc/calloc and use them with pointers:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// dot has precedence over * thats why you need parens!&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"member of pt: x=%d, y=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ppt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Because you need to wrap the dereferencing part of a pointer in parens when accessing a member via &lt;code&gt;.&lt;/code&gt; because the dot has higher precedence there is another notation for this common use case.
The &lt;code&gt;-&amp;gt;&lt;/code&gt; operator does exactly this. The following code is therefore equivalent:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;109&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When creating a variable of specific struct type the &lt;code&gt;struct&lt;/code&gt; keyword has always to be used. This gets pretty repetitive and boring quick! That's why you may want to do a little type alias via &lt;code&gt;typedef&lt;/code&gt;.
So instead of:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
You can do:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Neat! (It is not possible to direclty initialize a variable with &lt;code&gt;typedef&lt;/code&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5158ea7" class="outline-3"&gt;
&lt;h3 id="org5158ea7"&gt;Composite data type &lt;code&gt;union&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5158ea7"&gt;
&lt;p&gt;
A union is a special data type available in C that allows to store different data types in the same memory location. You can define a union with many members, but only one member can contain a value at any given time. Unions provide an efficient way of using the same memory location for multiple-purpose.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Now, a variable of &lt;code&gt;Data&lt;/code&gt; type can store an integer, a floating-point number, or a string of characters. It means a single variable, i.e., same memory location, can be used to store multiple types of data. You can use any built-in or user defined data types inside a union based on your requirement.
&lt;/p&gt;

&lt;p&gt;
The memory occupied by a union will be large enough to hold the largest member of the union. For example, in the above example, Data type will occupy 20 bytes of memory space because this is the maximum space which can be occupied by a character string.
&lt;/p&gt;

&lt;p&gt;
To access a member of a union the &lt;b&gt;member access operator&lt;/b&gt; &lt;code&gt;.&lt;/code&gt; is used as with structs.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga68558a" class="outline-3"&gt;
&lt;h3 id="orga68558a"&gt;Enumeration data type &lt;code&gt;enum&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga68558a"&gt;
&lt;p&gt;
With the help of enumeration data types it is possible to define types with discrete, named values. The corresponding keyword in C is &lt;code&gt;enum&lt;/code&gt;.
We can use this keyword to declare and initialize a sequence of integer constants eg &lt;code&gt;enum colors {RED, YELLOW, GREEN, BLUE};&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Here, colors is the name given to the set of constants - the name is optional. Now, if you don't assign a value to a constant, the default value for the first one in the list - &lt;code&gt;RED&lt;/code&gt; in our case, has the value of &lt;code&gt;0&lt;/code&gt;. The rest of the undefined constants have a value &lt;code&gt;1&lt;/code&gt; more than the one before, so in our case, &lt;code&gt;YELLOW&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, GREEN is &lt;code&gt;2&lt;/code&gt; and BLUE is &lt;code&gt;3&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
But you can assign values if you wanted to also in random order as well:
&lt;code&gt;enum colors {RED=1, YELLOW, GREEN=6, BLUE };&lt;/code&gt;
Now &lt;code&gt;RED=1&lt;/code&gt;, &lt;code&gt;YELLOW=2&lt;/code&gt;, &lt;code&gt;GREEN=6&lt;/code&gt; and &lt;code&gt;BLUE=7&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The main advantage of enum is that if you don't initialize your constants, each one would have a unique value. The first would be zero and the rest would then count upwards.
&lt;/p&gt;

&lt;p&gt;
Enums are helpful to assign specific (constant) values:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;jan&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;apr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jun&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jul&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aug&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oct&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nov&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;escape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;NL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BACKSPACE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\b'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TAB&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\t'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RETURN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\r'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BELL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;'\a'&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Enums are determined at compile time and offer therefore the ability to define constants. This is however &lt;b&gt;only&lt;/b&gt; applies for integer constants.
In contrast to &lt;code&gt;const&lt;/code&gt; (see below) an "unused" (ungebrauchtes) &lt;code&gt;enum&lt;/code&gt; does not need memory space at runtime.
&lt;/p&gt;

&lt;p&gt;
Since enums are basically treated like ints, they only offer restricted type safety.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd6f4856" class="outline-3"&gt;
&lt;h3 id="orgd6f4856"&gt;Array data type&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd6f4856"&gt;
&lt;p&gt;
C provides the derived array type do deal with collection of values with the same type. The declaration of an array doesn't require a keyword, since it is done via the &lt;i&gt;index operator&lt;/i&gt; &lt;code&gt;[]&lt;/code&gt; in which the amount of elements has to be written in and which needs to go after the variable name &lt;code&gt;int xa[10]&lt;/code&gt; (array of 10 ints).
&lt;/p&gt;

&lt;p&gt;
The base type of an array can be of any type, look at the following declarations:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pxa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Array of 10 pointers to integers&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;pt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Array of 10 point structs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Elements of an array are also accessed via the index operator &lt;code&gt;int x1 = xa[0];&lt;/code&gt;, however keep in mind that an array of size n has the indexes 0 til n-1 because the indexing of arrays (in C) is zero based as in many programming languages.
&lt;/p&gt;

&lt;p&gt;
It is also possible to declare multidimensional arrays (array which elements are arrays themselves). Eg &lt;code&gt;int xa[4][3]&lt;/code&gt; declares an 4x3 array, which is an array that has 4 elements and those 4 elements are arrays as well with a size of 3 elements that can hold ints.
Basically this can be done for an arbitrary amount of arrays inside arrays &lt;code&gt;int xa[4][3][2]&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Since C90 it is possible to create variable arrays. That means arrays of variable length which is determined at runtime, for example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
In C11 this is still possible however one should not rely on this with regards to portability.
&lt;/p&gt;

&lt;p&gt;
VLA (variable length array) also have some disadvantages:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;cannot be &lt;code&gt;static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cannot be part of &lt;code&gt;struct&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;"Der Steuerfluss darf niemals hinter die Deklaration eines VLA in dessen Gültigkeitsbereich gelangen" (? ლ,ᔑ•ﺪ͟͠•ᔐ.ლ)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Similar to structs array can be initialized with curly braces &lt;code&gt;int xa[4] = {1, 2, 3, 4};&lt;/code&gt; . This also works for multidimensional arrays:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When an array is initialized when its defined the (last) dimension may also be ommitted &lt;code&gt;int xa[] = {5, 2, 1}&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Since C90 it is also possible to do a partial initialization ala &lt;code&gt;int xa[10] = { [4] = 43, [1] = 5 };&lt;/code&gt; . The elements which are not explicitly initialized then default to &lt;code&gt;0&lt;/code&gt;. Similar to enums the following is also possible:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
… results in &lt;code&gt;200,0,0,43,8,5,0,0&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
When passing arrays to functions it is said that arrays "decay" into pointers.
If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, sizeof no longer gives the complete array's size, because it essentially becomes a pointer. This is why it's preferred (among other reasons) to pass by reference or pointer.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* array.c -- an array decays */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;myarray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myarray&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of a: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// really yields pointer size (8 byte on 64 bit machines)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;myarray&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of x: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// decay looses dimensions thats why this is possible&lt;/span&gt;
  &lt;span class="n"&gt;arrSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;x:&lt;/td&gt;
&lt;td class="org-right"&gt;40&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;a:&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Size&lt;/td&gt;
&lt;td class="org-left"&gt;of&lt;/td&gt;
&lt;td class="org-left"&gt;a:&lt;/td&gt;
&lt;td class="org-right"&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
So when passing an array, what really gets passed is a pointer to the first element in the array. Therefore the following function declarations are equivalent:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;[]);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
A problem that occurs here is that there is no way to find out how big/large the array is that was passed. That's why many function which have arrays as parameters, have another (auxillary) parameter to specify the amount of elements of the array:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* array_param .c -- auxiliary parameter */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;[]);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="n"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;654&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="n"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;randomArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print_int_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;td class="org-right"&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;32&lt;/td&gt;
&lt;td class="org-right"&gt;32&lt;/td&gt;
&lt;td class="org-right"&gt;45&lt;/td&gt;
&lt;td class="org-right"&gt;54&lt;/td&gt;
&lt;td class="org-right"&gt;23&lt;/td&gt;
&lt;td class="org-right"&gt;77&lt;/td&gt;
&lt;td class="org-right"&gt;654&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org97ebf84" class="outline-2"&gt;
&lt;h2 id="org97ebf84"&gt;Memory Layout&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org97ebf84"&gt;
&lt;p&gt;
Why is it that we can treat arrays as pointers? It is because array values are stored in contiguous memory locations. The array &lt;code&gt;int x[6] = {1, 2, 3, 4, 5, 6};&lt;/code&gt; is for example stored like this in memory:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/array-in-memory.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
This also applies to multidimensional arrays:
&lt;code&gt;int x[4][12] = {{11,12}, {21,22}, {31,32}, {41,42}};&lt;/code&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/multi-array-in-memory.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
The notion of &lt;code&gt;xa[i]&lt;/code&gt; is actually just a different syntax for &lt;code&gt;*(&amp;amp;xa+i)&lt;/code&gt; (give me the address of xa which really gives the address of the first element of xa, then add i&lt;sup&gt;1&lt;/sup&gt; to it and dereference the resulting address to give me the value).
&lt;/p&gt;

&lt;p&gt;
1 When adding an integer to a pointer, the integer is multiplied by the size of the type that the pointer points to because that is the "distance between the addresses" in memory. One memory location usually stores 1 Byte (8 bits) on modern systems. So when an integer is stored in 4 bytes than the offset between the first and second address of an int value in a array would be 4.
&lt;/p&gt;

&lt;p&gt;
Look at the following code which is really interesting and makes a lot of things clear:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of int %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xa&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Size  of  int  4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Address:  0x7ffff4f329d8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdd810cc" class="outline-2"&gt;
&lt;h2 id="orgdd810cc"&gt;Char Arrays&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdd810cc"&gt;
&lt;p&gt;
As we already know C does not provide strings by default. That's why &lt;code&gt;char&lt;/code&gt; arrays are "abused" as such. There is a special way to intialize char arrays in C:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello!"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
which really is the equivalent to:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;'H'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As you can see character strings are stored as an array containing the characters and are terminated with a &lt;i&gt;null character&lt;/i&gt; (&lt;code&gt;0&lt;/code&gt; or &lt;code&gt;'\0'&lt;/code&gt;). Therefore &lt;code&gt;'\0'&lt;/code&gt; musnt be in any string because it designates the ending of a string.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"World"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"5th ('last') char: %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Really last element of the array %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of str: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// 5 characters + null character = 6&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
A terminating 0 is a C convention and many functions from the standard library for example assume that as well (&lt;code&gt;int printf(char*,...)&lt;/code&gt;, &lt;code&gt;int atoi(char*)&lt;/code&gt;). A convention can be broken tho! Look at the following example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;'H'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'e'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'o'&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// no terminating 0!&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;bla&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;" This is top secret&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Hello This is top secret

&lt;/pre&gt;

&lt;p&gt;
I faked this output result for illustrating purposes because most modern compilers do not store those stuff sequentially anymore to reduce vulnerabilities (reading out values). plz have mercy. It really just printed "Hello".
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga704855" class="outline-2"&gt;
&lt;h2 id="orga704855"&gt;Parameters of &lt;code&gt;main()&lt;/code&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga704855"&gt;
&lt;p&gt;
The signature of C's  &lt;code&gt;main()&lt;/code&gt; function is mentioned by C11 as the following:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int argc&lt;/code&gt; ist the count of prorgam parameters
&lt;ul class="org-ul"&gt;
&lt;li&gt;because the name of the program is always passed when executing main with params &lt;code&gt;argc&lt;/code&gt; is at least &lt;code&gt;1&lt;/code&gt; because that's the program name&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char* argv&lt;/code&gt; is the argument vector resp. an array of &lt;b&gt;pointers&lt;/b&gt; to C-Strings
&lt;ul class="org-ul"&gt;
&lt;li&gt;each of those C-Strings holds a &lt;i&gt;program parameter&lt;/i&gt; (inclusive the program name at &lt;code&gt;argv[0]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This is what the &lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf"&gt;C11 standard&lt;/a&gt; says:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt; represents the program name;
&lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the program name is not available from the host environment. 
If the value of &lt;code&gt;argc&lt;/code&gt; is greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt; represent the program parameters.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/argv-argc.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
As already mentioned the declaration &lt;code&gt;char *argv[]&lt;/code&gt; stands for an &lt;b&gt;array of pointers to &lt;code&gt;char&lt;/code&gt;'s&lt;/b&gt;
Calling for example the code from the picture above this is how the corresponding memory layout would look like:
&lt;img src="https://schoettkr.github.io/knowledge-database/images/argv-memory-layout.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org3b6c440" class="outline-2"&gt;
&lt;h2 id="org3b6c440"&gt;Revision: Storage Classes and Storage Types/Attributes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3b6c440"&gt;
&lt;p&gt;
→ see "Named Variables" in Lecture 06
&lt;/p&gt;

&lt;p&gt;
Storage classes:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; → variables can only be accessed within the block of declaration which defines their scope&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; → life cycle does not end with ending scope and last value is preserved through program execution; does not affect visibility&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; →  only declares a variable/function/we, addidtional definition is required (usally in another module or a library)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt; → same functionality as auto variables with the difference that the compiler tries to store these variables in the register of the microprocessor, which makes access much faster than that of the variables stored in memory
&lt;ul class="org-ul"&gt;
&lt;li&gt;address of register variables &lt;b&gt;is not retrievable using pointers&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The following code would not compile! (&lt;code&gt;error: address of register variable ‘fastInt’ requested&lt;/code&gt;)
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fastInt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;pf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fastInt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Fast int: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fastInt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Storage types (&lt;b&gt;Type Qualifiers&lt;/b&gt; seems to be the proper term, Speicherattribute in Skript):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;constants are also like normal variables with the difference that their values can’t be modified by the program once they are defined (compiler prohibits assignment anywhere else than when initialized)&lt;/li&gt;
&lt;li&gt;enables the compiler to do some optimizations&lt;/li&gt;
&lt;li&gt;Gotchas:
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;const int * p&lt;/code&gt; declares a &lt;i&gt;variable&lt;/i&gt; pointer to a &lt;i&gt;constant&lt;/i&gt; integer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int * const p&lt;/code&gt; declares a &lt;i&gt;constant&lt;/i&gt; pointer to a &lt;i&gt;variable&lt;/i&gt; integer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
&lt;code&gt;volatile&lt;/code&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;volatile (flüchtig, sprunghaft) variables indicate to the compiler that their value might have changed since the last explicit writing operation&lt;/li&gt;
&lt;li&gt;eg, if global variable’s address is passed to clock routine of the operating system to store the system time, the value in this address keep on changing without any assignment by the program&lt;/li&gt;
&lt;li&gt;indicates that the object should not be subject to compiler optimizations altering references to, or modifications of, the object&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;restrict&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;introduced in C99&lt;/li&gt;
&lt;li&gt;only for pointer variables (and hereby derived for arrays)&lt;/li&gt;
&lt;li&gt;it doesn’t add any new functionality and it is only a way for programmers to inform about optimizations that the compiler can make&lt;/li&gt;
&lt;li&gt;when using &lt;code&gt;restrict&lt;/code&gt; with a pointer &lt;code&gt;ptr&lt;/code&gt;, it tells the compiler that &lt;code&gt;ptr&lt;/code&gt; is the only way to access the object pointed by it and compiler doesn’t need to add any additional checks
&lt;ul class="org-ul"&gt;
&lt;li&gt;for example when a variable is restrict the compiler will not reload the value at that adddress in its assembly code and therefore the assembly code is optimized&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
(Since C11 there is also &lt;code&gt;_Atomic&lt;/code&gt; &lt;a href="https://en.cppreference.com/w/c/language/atomic"&gt;here is more&lt;/a&gt;)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-08/</guid><pubDate>Thu, 01 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Computer Science I - Lecture 04</title><link>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org2c2e2b2" class="outline-2"&gt;
&lt;h2 id="org2c2e2b2"&gt;Comparison&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2c2e2b2"&gt;
&lt;p&gt;
There are the following comparison operators which yield a boolean value ( &lt;code&gt;0&lt;/code&gt; for false and &lt;code&gt;≠0&lt;/code&gt; for true usually 1): &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbc06939" class="outline-2"&gt;
&lt;h2 id="orgbc06939"&gt;Assignment Shortcuts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbc06939"&gt;
&lt;p&gt;
&lt;code&gt;a = a+5&lt;/code&gt; can be written more concise as &lt;code&gt;a+=5&lt;/code&gt; this is possible with all operators (*, /, %, +, -). Yes this is also possible with &lt;code&gt;%&lt;/code&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;%=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// -&amp;gt; a = a % b;&lt;/span&gt;

&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Which yields &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;a&lt;/code&gt;. But this is rather hard to read!
&lt;/p&gt;

&lt;p&gt;
To increment/decrement by one it is even possible to write &lt;code&gt;a++&lt;/code&gt; and &lt;code&gt;a--&lt;/code&gt; , as well as &lt;code&gt;++a&lt;/code&gt; and &lt;code&gt;--a&lt;/code&gt;. The difference between &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;++&lt;/code&gt; as a pre- or postfix operaror is that as a prefix operator (eg &lt;code&gt;--a&lt;/code&gt;) &lt;code&gt;a&lt;/code&gt; is first decremented and then evaluated and in case of a postfix operator (&lt;code&gt;a++&lt;/code&gt;) &lt;code&gt;a&lt;/code&gt; is first evaluated and then incremented. So in regards to the continued use &lt;code&gt;a++&lt;/code&gt; is incremented after the usage and &lt;code&gt;++a&lt;/code&gt; would be incremented before the usage so &lt;code&gt;a&lt;/code&gt; is already up by one when it is then used.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org48e22fb" class="outline-2"&gt;
&lt;h2 id="org48e22fb"&gt;Flow Control&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org48e22fb"&gt;
&lt;p&gt;
Flow in C++ can be controlled via &lt;code&gt;if (cond) { ... } else if (cond) { ... } else { ... }&lt;/code&gt; statements. Take a look at the following example to solve quadratic equations:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"Solve Quadratic Equations &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"Enter coefficient a, b, c: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"Not a quadratic equation &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"no real resolution &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt;
	&lt;span class="p"&gt;{&lt;/span&gt;
	  &lt;span class="n"&gt;x1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	  &lt;span class="n"&gt;x2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	  &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"x1 = "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"x2 = "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The flow can also be controlled with a &lt;code&gt;switch-case&lt;/code&gt; statement. For example to "build a simple calculator":
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'+'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;// notice the single quotes '' because it is a char&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'-'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'/'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'*'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'%'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"*** Error ***"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Notice that without the &lt;code&gt;break;&lt;/code&gt; at each case the other cases would be checked and might be executed as well! Also the case values (eg &lt;code&gt;+&lt;/code&gt;) have to be unique and constant! Constant in that sense that there are no computations allowed (eg function calls).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9aed735" class="outline-2"&gt;
&lt;h2 id="org9aed735"&gt;Repetition&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9aed735"&gt;
&lt;p&gt;
There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.
&lt;/p&gt;

&lt;p&gt;
Programming languages provide various control structures that allow for more complicated execution paths.
&lt;/p&gt;

&lt;p&gt;
A loop statement allows us to execute a statement or group of statements multiple times. C== provides the following types of loops:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;while loop&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;repeats a statement or group of statements while a given condition is true&lt;/li&gt;
&lt;li&gt;it tests the condition before executing the loop body&lt;/li&gt;
&lt;li&gt;eg &lt;code&gt;while (count &amp;lt; 100) { ... count++; ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;do..while loop&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;like a ‘while’ statement, except that it tests the condition at the end of the loop body → therefore the "do..while" loop is executed at least one time&lt;/li&gt;
&lt;li&gt;eg &lt;code&gt;do { ... count++; ... } while ( count &amp;lt; 100);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;for loop&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;execute a sequence of statements multiple times and abbreviates the code that manages the loop variable&lt;/li&gt;
&lt;li&gt;eg &lt;code&gt;for (int x = 0; x &amp;lt; 10; x++) { ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
It is also possible to nest loops inside any other loop. 
&lt;/p&gt;

&lt;p&gt;
An infinite loop like 
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"This loop will run forever.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
wont stop running by itself because an absent conditional expression is considered to be true. To interrupt the loop for example from the terminal press &lt;code&gt;Ctrl-C&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Use for loop when number of iterations is known beforehand, i.e. the number of times the loop body is needed to be executed is known.
&lt;/p&gt;

&lt;p&gt;
Use while loops where exact number of iterations is not known but the loop termination condition is known.
&lt;/p&gt;

&lt;p&gt;
Use do while loop if the code needs to be executed at least once like in Menu driven programs.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-04/</guid><pubDate>Thu, 01 Nov 2018 23:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 07</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-07/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgb6513fa" class="outline-2"&gt;
&lt;h2 id="orgb6513fa"&gt;Storage and memory&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb6513fa"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge040e05" class="outline-3"&gt;
&lt;h3 id="orge040e05"&gt;Parameters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge040e05"&gt;
&lt;p&gt;
Besides the named variables for which memory is allocated at compile time and anonymous variables for which memory is allocated at runtime, there is a third kind of variables → &lt;b&gt;parameters&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Parameters are variables that are automatically created and initialized when a function is called.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;lifecycle&lt;/b&gt; → retention time (Verweilzeit) of the program in that function &lt;i&gt;instance&lt;/i&gt; (the surrounding function)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;visibility&lt;/b&gt; → whole function body as long as it's not shadowed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Parameters are declared and defined whith the function definition. They cannot have /storage classes/(auto, static, extern, register), but may have /storage types/(const, volatile, restrict).
&lt;/p&gt;

&lt;p&gt;
The term parameter (sometimes called formal parameter) is used to refer to the variable as found in the function definition which is used in the function body, while argument (sometimes called actual parameter) refers to the actual input supplied at function call.
&lt;/p&gt;

&lt;p&gt;
In general there are two ways of assocating an argument with a parameter. C for example uses &lt;b&gt;positional parameters&lt;/b&gt; &lt;i&gt;only&lt;/i&gt; which means arguments have to be provided in the order specified by the function definition. 
&lt;/p&gt;

&lt;p&gt;
Python in contrast provides the option to use positional arguments as well as &lt;b&gt;named parameters&lt;/b&gt;.
A function call using named parameters differs from a regular function call in that the values are passed by associating each one with a parameter name, instead of providing an ordered list of values.
&lt;/p&gt;

&lt;p&gt;
In languages with no named parameters, the order of parameters in a function call is necessarily fixed, since it is the only way that the language can identify which value is intended to be used for which purpose.
&lt;/p&gt;

&lt;p&gt;
With named parameters, it is usually possible to provide the values in any arbitrary order, since the name attached to each value identifies its purpose. This reduces the connascence between parts of the program. A few languages use named parameters but still require the parameters to be provided in a specific order.
&lt;/p&gt;

&lt;p&gt;
Example usage of &lt;b&gt;ordered/positional parameters&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;testFun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Title"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Example usage of &lt;b&gt;named parameters&lt;/b&gt;:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;testFun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Title"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;xPosition&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;yPosition&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="n"&gt;drawingNow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Besides the different ways to associate parameters and arguments, there are different ways in which arguments are &lt;i&gt;passed&lt;/i&gt; to the function!
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;call by value&lt;/b&gt;: the actual parameter (argument) is evaluated and the formal parameter recieves that value (the function recieves a copy of the value)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by name&lt;/b&gt;: the formal parameter is replaced by the name of the actual parameter&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by reference&lt;/b&gt;: the formal parameter becomes a "proxy object" (Stellvertreterobjekt) for the argument so that all changes are immediately effective outside of the function as well&lt;/li&gt;
&lt;li&gt;&lt;b&gt;call by copy/return&lt;/b&gt;: the argument is evaluated and the formal parameter gets this value at the begin of the function; when the function execution finishes the value of the formal parameter is assigned to the actual parameter (copy in - copy out, call by value - return)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In C the only way of passing parameters is &lt;b&gt;by value&lt;/b&gt; and it does not know the concept of procedures and reference parameters. 
&lt;/p&gt;

&lt;p&gt;
To be still able to manipulate values outside of the executing function one may pass &lt;i&gt;pointers&lt;/i&gt;. Changes outside of the function scope can then be realised via dereferencing those pointers. The effect of this is basically the same as it would be when calling by reference and is an often used practice in C.
&lt;/p&gt;

&lt;p&gt;
A manipulation of values outside of a functions local variables (including parameters) is called &lt;i&gt;side effect&lt;/i&gt; (input &amp;amp; output is also a side effect).
&lt;/p&gt;

&lt;p&gt;
Example of manipulating a value outside of a functions local scope via pointer and therefore simulating reference parameters:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* sideeffect .c -- simulated reference parameter */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sideeffect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;sideeffect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x=%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sideeffect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;x=42&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;x=23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Another use case of reference parameters is value input. The function &lt;code&gt;scanf()&lt;/code&gt; from the standard library provides this functionality. Similar to &lt;code&gt;printf()&lt;/code&gt; the parameters begin with a format string, followed by a sequence of pointers to the variables where the input should be stored in. &lt;code&gt;scanf&lt;/code&gt; returns the count of successfully read variables.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Give the point as &lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;(x,y )&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;: "&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"(%d ,%d)"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You provided : (%d, %d).&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c9f9d6" class="outline-3"&gt;
&lt;h3 id="org8c9f9d6"&gt;Excursus: Variables and References in Python&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8c9f9d6"&gt;
&lt;p&gt;
Parameter passing in Python is somewhat special. It is not one of the most known methods like "pass-by-value" or "pass-by-reference", in fact parameter passing in Python is &lt;b&gt;"pass-by-object-reference"&lt;/b&gt; of which is often said "Object references are passed by value".
&lt;/p&gt;

&lt;p&gt;
What is actually happening when you make a variable assignment? This is an important question in Python, because the answer differs somewhat from what you’d find in many other programming languages.
&lt;/p&gt;

&lt;p&gt;
Python is a highly object-oriented language. In fact, virtually every item of data in a Python program is an object of a specific type or class. 
&lt;/p&gt;

&lt;p&gt;
When presented with the statement &lt;code&gt;print(300)&lt;/code&gt;, the interpreter does the following:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Creates an integer object&lt;/li&gt;
&lt;li&gt;Gives it the value 300&lt;/li&gt;
&lt;li&gt;Displays it to the console&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
A Python variable is a symbolic name that is a reference or pointer to an object. Once an object is assigned to a variable, you can refer to the object by that name. But the data itself is still contained within the object.
&lt;/p&gt;

&lt;p&gt;
For example the assignment &lt;code&gt;n = 9000&lt;/code&gt; creates an integer object with the value &lt;code&gt;300&lt;/code&gt; and assigns the variable &lt;code&gt;n&lt;/code&gt; to point to that object:
\[n \longrightarrow \fbox{9000}\]
&lt;/p&gt;

&lt;p&gt;
Now consider the following statement &lt;code&gt;m = n&lt;/code&gt;. What happens when it is executed? Python does not create another object. It simply creates a new symbolic name or reference, &lt;code&gt;m&lt;/code&gt;, which points to the same object that &lt;code&gt;n&lt;/code&gt; points to.
\[n \longrightarrow \fbox{9000} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
Next suppose you do this &lt;code&gt;m = 400&lt;/code&gt;. Now Python creates a new integer object with the value &lt;code&gt;400&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; becomes a reference to it:
\[n \longrightarrow \fbox{9000} \\ \fbox{400} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
Lastly, suppose this statement is executed next &lt;code&gt;n = "foo"&lt;/code&gt; . Now Python creates a string object with the value &lt;code&gt;"foo"&lt;/code&gt; and makes &lt;code&gt;n&lt;/code&gt; reference that.
&lt;/p&gt;

&lt;p&gt;
\[n \longrightarrow \fbox{"foo"} \\ \fbox{9000} \\ \fbox{400} \longleftarrow m\]
&lt;/p&gt;

&lt;p&gt;
There is no longer any reference to the integer object &lt;code&gt;9000&lt;/code&gt;. It is orphaned, and there is no way to access it.
&lt;/p&gt;

&lt;p&gt;
An object’s life begins when it is created, at which time at least one reference to it is created. During an object’s lifetime, additional references to it may be created, as you saw above, and references to it may be deleted as well. An object stays alive, as it were, so long as there is at least one reference to it.
&lt;/p&gt;

&lt;p&gt;
When the number of references to an object drops to zero, it is no longer accessible. At that point, its lifetime is over. Python will eventually notice that it is inaccessible and reclaim the allocated memory so it can be used for something else. In computer lingo, this process is referred to as garbage collection.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7f04363" class="outline-4"&gt;
&lt;h4 id="org7f04363"&gt;Object Identity&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7f04363"&gt;
&lt;p&gt;
In Python, every object that is created is given a number that uniquely identifies it. It is guaranteed that no two objects will have the same identifier during any period in which their lifetimes overlap. Once an object’s reference count drops to zero and it is garbage collected, as happened to the &lt;code&gt;9000&lt;/code&gt; object above, then its identifying number becomes available and may be used again.
&lt;/p&gt;

&lt;p&gt;
The built-in Python function &lt;code&gt;id()&lt;/code&gt; returns an object’s integer identifier. Using the &lt;code&gt;id()&lt;/code&gt; function, you can verify that two variables indeed point to the same object:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;768&lt;/span&gt;
&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
True

&lt;/pre&gt;
&lt;p&gt;
After the assignment &lt;code&gt;m = n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; both point to the same object, confirmed by the fact that &lt;code&gt;id(m)&lt;/code&gt; and &lt;code&gt;id(n)&lt;/code&gt; return the same number.
&lt;/p&gt;

&lt;p&gt;
Now take a look at the following code:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"a="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(a)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"b="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(b)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"a="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;", id(a)="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
a= 23 , id(a)= 140345766270720
b= 42 , id(b)= 140345766271328
a= 42 , id(a)= 140345766271328

&lt;/pre&gt;

&lt;p&gt;
When dealing with &lt;i&gt;immutable objects&lt;/i&gt; (eg integers, bool, string) a variable assignment like &lt;code&gt;a = a+19&lt;/code&gt; &lt;b&gt;does not&lt;/b&gt; modify the &lt;i&gt;object&lt;/i&gt;, instead
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a &lt;b&gt;new object&lt;/b&gt; is created and referenced&lt;/li&gt;
&lt;li&gt;or if such object (eg obj with value &lt;code&gt;42&lt;/code&gt;) already exists it is referenced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Complex objects (eg list, dict, set) are &lt;i&gt;mutable&lt;/i&gt;. When operating on them, they are changed directly without the creation of new objects so the reference stays the same.
&lt;/p&gt;

&lt;p&gt;
In the code example above an object holding the integer &lt;code&gt;42&lt;/code&gt; already existed and was referenced by &lt;code&gt;b&lt;/code&gt; and thats why assigning &lt;code&gt;42&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; changes the reference to point to the same object, which is verified by comparing the object ids with &lt;code&gt;id()&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
So parameter passing in Python passes &lt;b&gt;object references&lt;/b&gt;. 
&lt;/p&gt;

&lt;p&gt;
In case of &lt;i&gt;immutable objects&lt;/i&gt; modifications inside the called function leads to creation and then referencing of other objects. Outside of the function the same ol' object is referenced, which was not modified so this has the same effect as "pass-by-value".
&lt;/p&gt;

&lt;p&gt;
In case of &lt;i&gt;mutable objects&lt;/i&gt; no new references and objects would be created when modifications occur so variables outside of the function that refer to the same object reference the same object to which the modifications are applied. This has the same effect as "pass-by-reference".
&lt;/p&gt;

&lt;p&gt;
Sources of the python excursus: &lt;a href="https://realpython.com/python-variables/"&gt;https://realpython.com/python-variables/&lt;/a&gt; and &lt;a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/"&gt;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-07/</guid><pubDate>Mon, 29 Oct 2018 23:00:00 GMT</pubDate></item><item><title>Computer Science I - Lecture 03</title><link>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-03/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org7adc5cb" class="outline-2"&gt;
&lt;h2 id="org7adc5cb"&gt;Characteristics of a language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7adc5cb"&gt;
&lt;p&gt;
Languages consist of three main characteristics:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Lexis (specification on formation of words)&lt;/li&gt;
&lt;li&gt;Syntax (specification on formation of sentences)&lt;/li&gt;
&lt;li&gt;Semantic (meaning)&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga85113b" class="outline-3"&gt;
&lt;h3 id="orga85113b"&gt;Lexis and lexical elements of C++&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga85113b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;keywords: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;predefined identifiers: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;identifiers: &lt;code&gt;temp1&lt;/code&gt;, &lt;code&gt;diff&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;have to start with a letter (&lt;code&gt;_&lt;/code&gt; is allowed aswell)&lt;/li&gt;
&lt;li&gt;can then contain arbitrary amount of characters/numbers&lt;/li&gt;
&lt;li&gt;are case sensitive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;special symbols:  ; , : . + − ∗ / % &amp;gt; &amp;lt; = ! ˜ ˆ &amp;amp; | [ ] { } ( )&lt;/li&gt;
&lt;li&gt;separators: whitespace, tabulator, newline&lt;/li&gt;
&lt;li&gt;numeric values:
&lt;ul class="org-ul"&gt;
&lt;li&gt;decimal: &lt;code&gt;255&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;octal: &lt;code&gt;377&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;hexadecimal: &lt;code&gt;0xff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;floats: &lt;code&gt;1.5&lt;/code&gt; or &lt;code&gt;3.1e-15&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;characters: &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'#'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt; (in single quotes!)&lt;/li&gt;
&lt;li&gt;strings: &lt;code&gt;"Test 1 \n"&lt;/code&gt; (in double quotes!)&lt;/li&gt;
&lt;li&gt;comments: 
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; until end of line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/* ... */&lt;/code&gt; multiple lines&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgb57f58a" class="outline-3"&gt;
&lt;h3 id="orgb57f58a"&gt;Syntax and presentation method (Darstellungsmittel)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb57f58a"&gt;
&lt;p&gt;
A method to present syntax is to use syntax diagrams. They represent a graphical alternative to e.g Backus–Naur form to represent formal or context-free grammar.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org859f90b" class="outline-4"&gt;
&lt;h4 id="org859f90b"&gt;Elements of syntax diagrams&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org859f90b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;▭ a rectangle with sharp corners represents an abstract entity&lt;/li&gt;
&lt;li&gt;▢ a ellipse (rectangle with rounded corners) represents a concrete term of the language, therefore an element of the lexis&lt;/li&gt;
&lt;li&gt;⟶  an arrow indicates the flow direction (to build "sentences")&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Example of an include directive represented as a syntax graph:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/include-directive-graph.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org24f7b3e" class="outline-2"&gt;
&lt;h2 id="org24f7b3e"&gt;Boolean algebra, logical connectives and truth tables&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org24f7b3e"&gt;
&lt;p&gt;
C++ has the data type &lt;code&gt;bool&lt;/code&gt; which can either be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. In integers a &lt;code&gt;0&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and everything &lt;code&gt;≠0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;a &amp;amp;&amp;amp; b&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;a ‖ b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
There is also the &lt;code&gt;!&lt;/code&gt; not operator to negate boolean values.
&lt;/p&gt;

&lt;p&gt;
Using these boolean operators in C++, yields values of type &lt;code&gt;bool&lt;/code&gt; (→ &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;)
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org035c414" class="outline-3"&gt;
&lt;h3 id="org035c414"&gt;Bitwise AND, OR, XOR, NOT&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org035c414"&gt;
&lt;p&gt;
In digital computer programming, a bitwise operation operates on one or more bit patterns or binary numerals at the level of their individual bits. It is a fast and simple action, directly supported by the processor, and is used to manipulate values for comparisons and calculations. 
&lt;/p&gt;

&lt;p&gt;
These are the bitwise operators in C++ &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
What is really important to understand is, that bitwise operators operate on the single bits (in comparison to boolean operators who operate on the whole value and yield true or false and are not bitwise operators!).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb9ff8ff" class="outline-4"&gt;
&lt;h4 id="orgb9ff8ff"&gt;Bitwise NOT&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb9ff8ff"&gt;
&lt;p&gt;
The bitwise NOT, or complement, is a unary operation that performs logical negation on each bit, forming the ones' complement of the given binary value. Bits that are 0 become 1, and those that are 1 become 0. For example
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~0111
= 1000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Comparing bitwise NOT to boolean NOT (the last letter indicates the number system e.g &lt;code&gt;d&lt;/code&gt; = decimal, &lt;code&gt;b&lt;/code&gt; = binary):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;boolean NOT: !1_d = 0_d; !5_d = 0_d
bitwise NOT: ~1_d = 0_d; ~5_d = ~0101_b = 1010_b = 10_d 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org160731e" class="outline-4"&gt;
&lt;h4 id="org160731e"&gt;Bitwise OR&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org160731e"&gt;
&lt;p&gt;
A bitwise OR takes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0101 | 0011
= 0111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The bitwise OR shall not be confused with the boolean OR that treats its operands as boolean values and returns such.
The bitwise OR can be used to manage flags if a program has to handle a lot of booleans and the memory is really limited. Each bit of a binary number could itself represent a boolean value (eg &lt;code&gt;0&lt;/code&gt; = false, &lt;code&gt;1&lt;/code&gt; true).
&lt;/p&gt;

&lt;p&gt;
For example &lt;code&gt;0010&lt;/code&gt; may be seen as a list of flags where the first, second and fourth flag is not set (&lt;code&gt;0&lt;/code&gt;), while the third flag is set (&lt;code&gt;1&lt;/code&gt;). To set the first flag, this bit string can be combined with another bitstring that has a &lt;code&gt;1&lt;/code&gt; in the first place:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="mo"&gt;0010&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1010&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc871cb7" class="outline-4"&gt;
&lt;h4 id="orgc871cb7"&gt;Bitwise AND&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc871cb7"&gt;
&lt;p&gt;
A bitwise AND takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 × 1 = 1); otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0). For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0101&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;   &lt;span class="mo"&gt;0011&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The operation may be used to determine whether a particular bit is &lt;i&gt;set&lt;/i&gt; (1) or &lt;i&gt;clear&lt;/i&gt; (0). For example, given a bit pattern &lt;code&gt;0011&lt;/code&gt; (decimal 3), to determine whether the second bit is set we use a bitwise AND with a bit pattern containing 1 only in the second bit:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0011&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;   &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Because the result &lt;code&gt;0010&lt;/code&gt; is non-zero, we know the second bit in the original pattern was set. This is often called bit masking. (By analogy, the use of masking tape covers, or masks, portions that should not be altered or portions that are not of interest. In this case, the 0 values mask the bits that are not of interest.)
&lt;/p&gt;

&lt;p&gt;
The bitwise AND may be used to clear selected bits (or flags) of a register in which each bit represents an individual Boolean state. This technique is an efficient way to store a number of Boolean values using as little memory as possible.
&lt;/p&gt;

&lt;p&gt;
For example, &lt;code&gt;0110&lt;/code&gt; (decimal 6) can be considered a set of four flags, where the first and fourth flags are clear (0), and the second and third flags are set (1). The second bit may be cleared by using a bitwise AND with the pattern that has a zero only in the second bit:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0110&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;   &lt;span class="mi"&gt;1011&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The bitwise AND can be used to check the parity(Parität, gerade ungerade) of a binary number, by checking the value of the lowest valued bit (&lt;code&gt;1_d&lt;/code&gt;) which would be &lt;code&gt;1_b&lt;/code&gt; if the number is odd:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0110&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;AND&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;

    &lt;span class="mo"&gt;0101&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;AND&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;odd&lt;/span&gt;

    &lt;span class="mo"&gt;0100&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;AND&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2c4b277" class="outline-4"&gt;
&lt;h4 id="org2c4b277"&gt;Bitwise XOR&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2c4b277"&gt;
&lt;p&gt;
In addition to &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; there is also &lt;code&gt;xor&lt;/code&gt; (exclusive or → only one value true):
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;a&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;b&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;a XOR b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;true&lt;/td&gt;
&lt;td class="org-left"&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
The bitwise &lt;code&gt;XOR&lt;/code&gt; operator in C++ is &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
A bitwise XOR takes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0101&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;XOR&lt;/span&gt; &lt;span class="mo"&gt;0011&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0110&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The bitwise XOR may be used to invert selected bits in a register (also called toggle or flip). Any bit may be toggled by XORing it with 1. For example, given the bit pattern &lt;code&gt;0010&lt;/code&gt; (decimal 2) the second and fourth bits may be toggled by a bitwise XOR with a bit pattern containing 1 in the second and fourth positions:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;XOR&lt;/span&gt; &lt;span class="mi"&gt;1010&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
This technique may be used to manipulate bit patterns representing sets of Boolean states.
&lt;/p&gt;

&lt;p&gt;
Assembly language programmers and optimizing compilers sometimes use XOR as a short-cut to setting the value of a register to zero. Performing XOR on a value against itself always yields zero, and on many architectures this operation requires fewer clock cycles and memory than loading a zero value and saving it to the register (german: Wendet man XOR auf zwei identische Operanden an, so erhält man immer 0. In vielen Architekturen benötigt diese Operation weniger Rechenzeit, als man für das Laden einer 0 und das Speichern im Register benötigt).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge6b8083" class="outline-3"&gt;
&lt;h3 id="orge6b8083"&gt;Bitwise shifting / bit shifts&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge6b8083"&gt;
&lt;p&gt;
The bit shifts are sometimes considered bitwise operations, because they treat a value as a series of bits rather than as a numerical quantity. In these operations the digits are moved, or shifted, to the left or right. Registers in a computer processor have a fixed width, so some bits will be "shifted out" of the register at one end, while the same number of bits are "shifted in" from the other end.
&lt;/p&gt;

&lt;p&gt;
The operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; shifts to the left by the following value and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; shifts to the right by the following value. For example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mo"&gt;0110&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1100&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
So &lt;code&gt;6 &amp;lt;&amp;lt; 1 = 12&lt;/code&gt; because the underlying bits are moved/shifted by 1 place to the left. Shifting left is equivalent to multiplication by powers of 2. So &lt;code&gt;6 &amp;lt;&amp;lt; 1&lt;/code&gt; is equivalent to &lt;code&gt;6 * 2&lt;/code&gt;, and &lt;code&gt;6 &amp;lt;&amp;lt; 3&lt;/code&gt; is equivalent to &lt;code&gt;6 * 2^3 = 6 * 8&lt;/code&gt;. A good optimizing compiler will replace multiplications with shifts when possible.
&lt;/p&gt;

&lt;p&gt;
A logical right shift is the converse to the left shift. Rather than moving bits to the left, they simply move to the right. For example, shifting the number 12:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1100&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0110&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
That will get us back our original 6. So we see that shifting to the right is equivalent to division by powers of 2.
&lt;/p&gt;

&lt;p&gt;
Another example:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="mo"&gt;0011&lt;/span&gt; &lt;span class="mi"&gt;1110&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;binary&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0001&lt;/span&gt; &lt;span class="mi"&gt;1111&lt;/span&gt; &lt;span class="mo"&gt;0100&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8000&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="mo"&gt;0111&lt;/span&gt; &lt;span class="mi"&gt;1101&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;125&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;decimal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There is also a difference between logical, arithmetic and circular shifting that you may want to look up. 
&lt;/p&gt;

&lt;p&gt;
Also note that the "&lt;a id="org45db69a"&gt;&lt;/a&gt;" as a stream operator takes precedence over bit shifting so the following code:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Would yield &lt;code&gt;51&lt;/code&gt;. To have it bitshifted one has to add parentheses:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Which would yield &lt;code&gt;10&lt;/code&gt; because b is leftshifted by a (&lt;code&gt;n&lt;/code&gt;) which is equal to a multiplication with 2&lt;sup&gt;n&lt;/sup&gt; and this case &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; so &lt;code&gt;b&lt;/code&gt; is multiplcated by 2 which gives 10.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/computer_science_I/cs-I-03/</guid><pubDate>Fri, 26 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Debugging with gdb</title><link>https://schoettkr.github.io/knowledge-database/posts/misc/debugging-with-gdb/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-orgdb798a8" class="outline-2"&gt;
&lt;h2 id="orgdb798a8"&gt;How to debug a c program with gdb&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdb798a8"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org99d4498" class="outline-4"&gt;
&lt;h4 id="org99d4498"&gt;Step 1. Compile the C program with debugging option&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org99d4498"&gt;
&lt;p&gt;
Compile the C program with the debugging option which is usually &lt;code&gt;-g&lt;/code&gt; for most compilers. This allows the compiler to collect the debugging information.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gcc -g example.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
The above command creates a &lt;code&gt;a.out&lt;/code&gt; file which will be used for debugging. Of course other compiler options e.g specifying file name or turning on warnings is possible!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd898800" class="outline-4"&gt;
&lt;h4 id="orgd898800"&gt;Step 2. Launch gdb&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd898800"&gt;
&lt;p&gt;
Launch the C debugger gdb as shown below:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gdb a.out
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org313e7fd" class="outline-4"&gt;
&lt;h4 id="org313e7fd"&gt;Step 3. Set breakpoints&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org313e7fd"&gt;
&lt;p&gt;
Places break point in the C program, where you suspect errors. While executing the program, the debugger will stop at the break point, and gives you the prompt to debug.
To set a breakpoint enter the following:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;break&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;linenumber&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Additionally it is also possible to do so in the following formats/ways (the filename is optional):
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;break&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;filename:&lt;span class="o"&gt;}{&lt;/span&gt;lineNumber&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="nb"&gt;break&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;filename:&lt;span class="o"&gt;}{&lt;/span&gt;functionName&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3ec17d2" class="outline-4"&gt;
&lt;h4 id="org3ec17d2"&gt;Step 4. Execute the C program&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3ec17d2"&gt;
&lt;p&gt;
Now the program can be executed using the &lt;code&gt;run&lt;/code&gt; command in the gdb debugger. It is now also possible to specify command line arguments via &lt;code&gt;run {args}&lt;/code&gt;.
The program then executes until it encounters the first breakpoint or finishes execution and stops.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7115561" class="outline-4"&gt;
&lt;h4 id="org7115561"&gt;Step 5. It stopped - now what?!&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7115561"&gt;
&lt;p&gt;
Now since the execution is halted there multiple things you can do. &lt;code&gt;print {varName}&lt;/code&gt; prints the current value of an variable (can be shortened to &lt;code&gt;p&lt;/code&gt;). &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; resumes execution until the next breakpoint. &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; executes the next line as &lt;i&gt;a single instruction&lt;/i&gt;. &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;step&lt;/code&gt; same as &lt;code&gt;next&lt;/code&gt; but doesn't treat functions as a single instruction, instead goes into the function to execute it line by line.
&lt;/p&gt;

&lt;p&gt;
By the way &lt;code&gt;&amp;lt;ENTER&amp;gt;&lt;/code&gt; repeats the previous command. &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt; can be used to print the source code, &lt;code&gt;l {lineNumber}&lt;/code&gt; can be used to view a specific line and &lt;code&gt;l {functionName}&lt;/code&gt; to show a function. &lt;code&gt;bt&lt;/code&gt; or &lt;code&gt;backtrack&lt;/code&gt; prints a backtrace of all stack frames. Finally &lt;code&gt;quit&lt;/code&gt; exits the gdb debugger.
&lt;/p&gt;



&lt;p&gt;
Source: &lt;a href="https://www.thegeekstuff.com/2010/03/debug-c-program-using-gdb/"&gt;https://www.thegeekstuff.com/2010/03/debug-c-program-using-gdb/&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/misc/debugging-with-gdb/</guid><pubDate>Fri, 26 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Usage of tar</title><link>https://schoettkr.github.io/knowledge-database/posts/misc/tar-usage/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org4cff337" class="outline-2"&gt;
&lt;h2 id="org4cff337"&gt;Usage of tar&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4cff337"&gt;
&lt;p&gt;
GNU's &lt;code&gt;tar&lt;/code&gt; is an archiving utility to store files into an archive and manipulate such archives.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org797228a" class="outline-3"&gt;
&lt;h3 id="org797228a"&gt;Compressing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org797228a"&gt;
&lt;p&gt;
To compress files into an archive with tar use:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -cvzf &amp;lt;name of tarball archive&amp;gt;.tgz /filepath/or/path/to/source/folder &lt;span class="c1"&gt;# creates ".tgz" archive&lt;/span&gt;
tar -cvzf &amp;lt;name of tarball archive&amp;gt;.tar /filepath/or/path/to/source/folder &lt;span class="c1"&gt;# creates ".tar" archive&lt;/span&gt;
tar -cvzf &amp;lt;name of tarball archive&amp;gt;.tar.gz /filepath/or/path/to/source/folder &lt;span class="c1"&gt;# creates ".tar.gz" archive&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org07dd298" class="outline-3"&gt;
&lt;h3 id="org07dd298"&gt;Extracting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org07dd298"&gt;
&lt;p&gt;
To extract or decompress archives use:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -xvzf &amp;lt;name of archive&amp;gt;.tgz &lt;span class="c1"&gt;# decompresses the archive into the current directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf4ef6d1" class="outline-3"&gt;
&lt;h3 id="orgf4ef6d1"&gt;Flags&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf4ef6d1"&gt;
&lt;p&gt;
The flags stand for:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;c&lt;/b&gt; → &lt;b&gt;C&lt;/b&gt; ompress/create&lt;/li&gt;
&lt;li&gt;&lt;b&gt;x&lt;/b&gt; → e &lt;b&gt;X&lt;/b&gt; tract&lt;/li&gt;
&lt;li&gt;z → zee (compression as in filter through gZip, Zlib, Zip)&lt;/li&gt;
&lt;li&gt;f → file&lt;/li&gt;
&lt;li&gt;v → verbose&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org76f78b3" class="outline-3"&gt;
&lt;h3 id="org76f78b3"&gt;Mnemonic&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org76f78b3"&gt;
&lt;p&gt;
To remember this more easily:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;tar -czf&lt;/code&gt; → "tar Create Zipped File"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xzf&lt;/code&gt; → "tar eXtract Zipped File"&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/misc/tar-usage/</guid><pubDate>Fri, 26 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Algos &amp; Programming - Lecture 06</title><link>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-06/</link><dc:creator>schoettkr</dc:creator><description>&lt;div id="outline-container-org28bcc5a" class="outline-2"&gt;
&lt;h2 id="org28bcc5a"&gt;Storage and memory&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org28bcc5a"&gt;
&lt;p&gt;
Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;storing in the file system (good for big data sets but slow)&lt;/li&gt;
&lt;li&gt;storing in memory (faster but limited in some aspects as well)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We continue with the latter option (ᵔᴥᵔ).
&lt;/p&gt;

&lt;p&gt;
C is theoretically able to write to and acces every place in memory. Due to the implied dangers of this, most operating systems prevent this to some degree. There are three fundamental methods to reserve (&lt;b&gt;allocate&lt;/b&gt;) memory:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(implicit) "named" memory allocation at compile time&lt;/li&gt;
&lt;li&gt;"anonymous" memory allocation at run time&lt;/li&gt;
&lt;li&gt;parameters which allocate storage at run rime as well&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The terms "named" and "anonymous" are taken from the lecture script, I don't like them and think they're confusing. As I understand it the first method refers to the memory allocation that happens when you have e.g &lt;code&gt;int num = 5;&lt;/code&gt; in your code and the compiler allocates/reserves at least 16 bits (2 bytes), while the second method refers to dynamic memory allocation via &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;calloc()&lt;/code&gt;. I'm not entirely sure if this is what the professor means xD. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgee5753f" class="outline-3"&gt;
&lt;h3 id="orgee5753f"&gt;Variables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgee5753f"&gt;
&lt;p&gt;
Should the value of a place in memory be modified (purpose of the state model), you speak of (named or anonymous) &lt;i&gt;variables&lt;/i&gt;. Should the value in memory stay unchanged, then it is a &lt;i&gt;constant&lt;/i&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0b77064" class="outline-4"&gt;
&lt;h4 id="org0b77064"&gt;Named variables&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0b77064"&gt;
&lt;p&gt;
Named variables in C have to be declared (analogus to functions). The declarations has to contain the type of the variable as well as the name. It is possible to declare multiple variables of the same type together ala &lt;code&gt;int x, y ,z;&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
When declaring a variable it is possible to also provide a &lt;i&gt;storage class&lt;/i&gt; and/or a &lt;i&gt;type qualifier&lt;/i&gt;. The storage class is declared via one of the following keywors &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt;. These basically impact the &lt;i&gt;scope&lt;/i&gt;, &lt;i&gt;visibility/(?! might be wrong) and the /life time&lt;/i&gt; of the specific variable.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; (assumed by default if no other storage class is specified)
&lt;ul class="org-ul"&gt;
&lt;li&gt;not often written because it is the default&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; variables can only be accessed within the block of declaration which defines their scope&lt;/li&gt;
&lt;li&gt;however they can be accessed outside their scope by using pointers&lt;/li&gt;
&lt;li&gt;get a garbage value assigned whenever they are declared (without initilization)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; variables preserve their (last) value even after they are out of scope&lt;/li&gt;
&lt;li&gt;therefore &lt;i&gt;only initialized once&lt;/i&gt; and exist until program termination, thus no new memory is allocated because they are not redeclared&lt;/li&gt;
&lt;li&gt;their scope is local to the function in which they were defined, global static variables can be accesed anywhere&lt;/li&gt;
&lt;li&gt;are assigned &lt;code&gt;0&lt;/code&gt; by default from the compiler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;same functionality as auto variables with the difference that the compiler tries to store these variables in the register of the microprocessor, which makes access much faster than that of the variables stored in memory&lt;/li&gt;
&lt;li&gt;if no free register is available the variable is stored in memory&lt;/li&gt;
&lt;li&gt;address of register variables is not retrievable using pointers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Type qualifiers are declared via the keywords &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;restrict&lt;/code&gt; and give hints to the compiler about the usage of the variables (see "Storage Classes and Storage Types/Attributes" in Lecture 08).
&lt;/p&gt;

&lt;p&gt;
Variables declared outside of any function are &lt;i&gt;global variables&lt;/i&gt;, while variables declared in blocks (&lt;code&gt;{..}&lt;/code&gt;) are &lt;i&gt;local variables&lt;/i&gt;. Only with the exception of variables with a storage class of &lt;code&gt;extern&lt;/code&gt;, variables are also &lt;i&gt;defined&lt;/i&gt; when they are &lt;i&gt;declared&lt;/i&gt; that means that memory for the varibale is automatically allocated in memory (dont mix this with initializing and/or assigning) without the programmer having to do anything.
&lt;/p&gt;

&lt;p&gt;
When the variable has a storage class of &lt;code&gt;extern&lt;/code&gt; it is &lt;b&gt;only declared&lt;/b&gt; but not defined and therefore has to be &lt;i&gt;globally defined&lt;/i&gt; (in a different module).
&lt;/p&gt;

&lt;p&gt;
A variable can be assigned a value via &lt;code&gt;0&lt;/code&gt;, this can also be done when declaring a variable → &lt;b&gt;initilization&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org34ce971"&gt;&lt;/a&gt;Addresses&lt;br&gt;
&lt;div class="outline-text-5" id="text-org34ce971"&gt;
&lt;p&gt;
Every variable has an address (place in memory where it is stored) that can be retrieved with the &lt;code&gt;&amp;amp;&lt;/code&gt; "address of" operator
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="cm"&gt;/* addr .c -- address of a variable */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Variable var has the address %p and the value %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;testVar&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Variable var has the address 0x7ffc5d3f3694 and the value 42

&lt;/pre&gt;

&lt;p&gt;
Actually the identifier of a variable (eg &lt;code&gt;testVar&lt;/code&gt;) is just a synonym of the address.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/identifier-memory.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgcbb85d2"&gt;&lt;/a&gt;Pointer&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgcbb85d2"&gt;
&lt;p&gt;
Variables can also hold addresses themselves! The prefix &lt;code&gt;*&lt;/code&gt; infront of the identifier of a variable makes it a pointer variable. It is essential for the compiler of what this address is built, therefore a pointer is always pointing to another &lt;b&gt;specific&lt;/b&gt; type. For instance:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;int *p&lt;/code&gt; → pointer that is pointing to an integer type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float *p&lt;/code&gt; → pointer that is pointing to a float type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int *p&lt;/code&gt; → pointer that is pointing to an unsigned integer type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
If a generic memory address without a specific type shall be used then the base type &lt;code&gt;void&lt;/code&gt; is used:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void *p&lt;/code&gt; pointer that is pointing to an address&lt;/li&gt;
&lt;li&gt;assigning void pointers is compatible to/with all other pointer types (→ no warnings!)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* addr2 .c -- pointer to a variable */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Variable var has the address %p and the value %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Variable pvar has the address %p and the value %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pvar&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The value that the pointer stored in pvar points to is %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pvar&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Variable var has the address 0x7ffd08a3f97c and the value 42
Variable pvar has the address 0x7ffd08a3f980 and the value 0x7ffd08a3f97c
The value that the pointer stored in pvar points to is 42

&lt;/pre&gt;

&lt;p&gt;
Example memory representation of the above code (addresses will differ):
&lt;img src="https://schoettkr.github.io/knowledge-database/images/pointer-memory-representation.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
A type and its derived type (eg &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;int *&lt;/code&gt;) are &lt;i&gt;different&lt;/i&gt; types.
&lt;/p&gt;

&lt;p&gt;
As seen in the code example above a pointer can be &lt;b&gt;dereferenced&lt;/b&gt; via the dereference operator &lt;code&gt;*&lt;/code&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* deref .c -- deref a pointer */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y=%d (at %p)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* same effect as printf ("y=%d\n" ,y); */&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* same effect as y=42 */&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"y=%d (at %p)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
y=23 (at 0x7ffeeff30f1c)
y=42 (at 0x7ffeeff30f1c)

&lt;/pre&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf8a29f4" class="outline-4"&gt;
&lt;h4 id="orgf8a29f4"&gt;Anonymous variables&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf8a29f4"&gt;
&lt;p&gt;
Anonymous variables in C don't have a name but get memory allocated nevertheless. They are created at &lt;i&gt;run time&lt;/i&gt; with functions from the C standard library. Anonymous variables are &lt;b&gt;not declared&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
More specifically the following functions that are &lt;i&gt;declared&lt;/i&gt; in &lt;code&gt;stdlib.h&lt;/code&gt; are used to allocate memory at run time:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;void *malloc(size_t size)&lt;/code&gt; → reserves &lt;code&gt;size&lt;/code&gt; bytes in memory (memory allocate)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *calloc(size_t count, size_t size)&lt;/code&gt; → reserves &lt;code&gt;count x size&lt;/code&gt; bytes in memory and initializes them with a value of &lt;code&gt;0&lt;/code&gt; (count allocate)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Both functions retrun the &lt;b&gt;address&lt;/b&gt; of the anonymous variable.
&lt;/p&gt;

&lt;p&gt;
To find out how much size/space is needed, C's &lt;code&gt;sizeof&lt;/code&gt; operator comes in handy because the size of eg an &lt;code&gt;int&lt;/code&gt; is not the same on all systems. It can be used on variables as well as on types and &lt;code&gt;sizeof(int)&lt;/code&gt; return for example &lt;code&gt;4&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The programmer has (in contrast to named variables) manage the scope and lifecycle of anonymous variables. To release the memory that was allocated for an anonymous variable &lt;code&gt;void free(void*)&lt;/code&gt; is used which takes the address of the anonymous variable.
To be able to do this you of course need the address of the anonymous variable and that is (amongst other reasons) why you should store it somewhere!
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* malloc .c -- anonymous variables */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// declare pointer to int&lt;/span&gt;

  &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// allocate memory for an int and store the returned address of the allocated memory location and store it in p&lt;/span&gt;

  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// dereference p and store the value 42&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Pointer p has address %p and points to %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" Anonymous variable has the value %d which is stored in %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* pass address and release memory */&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Pointer p has address 0x7fff1376cea0 and points to 0x55ffde405260
Anonymous variable has the value 42 which is stored in 0x55ffde405260

&lt;/pre&gt;

&lt;p&gt;
In the example above you can see that the variable is anonymous because the value &lt;code&gt;42&lt;/code&gt; is nowhere stored directly in a named variable but is retrieved by dereferencing the pointer that points to the memory location where &lt;code&gt;42&lt;/code&gt; is stored (&lt;code&gt;*p&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
Not releasing allocated memory can lead to so called &lt;i&gt;memory leaks&lt;/i&gt; and is a frequent error cause. Another frequent error is trying to use anonymous variables that are already released (&lt;i&gt;dangling pointer&lt;/i&gt;).
&lt;/p&gt;

&lt;p&gt;
Helping advice to avoid the above errors:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when you allocate memory with eg &lt;code&gt;malloc&lt;/code&gt; immediately write the code to free the memory as well&lt;/li&gt;
&lt;li&gt;when releasing/freeing an anonymous variable assign it the (symbolic) value &lt;code&gt;NULL&lt;/code&gt; which is defined in &lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;it is guaranteed that there is never another variable at a location that is described by &lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dereferencing &lt;code&gt;NULL&lt;/code&gt; leads to a run time error&lt;/li&gt;
&lt;li&gt;if functions like &lt;code&gt;malloc&lt;/code&gt; fail they also return &lt;code&gt;NULL&lt;/code&gt; therefore it is advised to check pointers against &lt;code&gt;null&lt;/code&gt; before using them&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1ed2e62" class="outline-4"&gt;
&lt;h4 id="org1ed2e62"&gt;Parameters&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1ed2e62"&gt;
&lt;p&gt;
Parameters are the third way memory is allocated to store values. We covered this in the next lecture (lecture 07). (¬‿¬)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>A&amp;P</category><category>university</category><guid>https://schoettkr.github.io/knowledge-database/posts/algos_and_programming/algos-and-prog-06/</guid><pubDate>Thu, 25 Oct 2018 22:00:00 GMT</pubDate></item><item><title>Database Essentials - Lecture 03</title><link>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-03/</link><dc:creator>schoettkr</dc:creator><description>&lt;p&gt;
As we have learned in the last lecture there are three distinct phases of database design:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;b&gt;Conceptual Design&lt;/b&gt; (lecture 02)
&lt;ul class="org-ul"&gt;
&lt;li&gt;creation of a semantic data model that describes all important aspects from the requirement analysis&lt;/li&gt;
&lt;li&gt;primarily serves the purpose to clearly (eindeutig) communicate the data that is to be stored and its realationships in a nontechnical way&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Logical Design&lt;/b&gt; (this lecture)
&lt;ul class="org-ul"&gt;
&lt;li&gt;transforms the conceptual model into a concrete data model, which can be implemented in a database system&lt;/li&gt;
&lt;li&gt;the logical design / data model also does not hold cocrete implementation details such as DBMS, programming language(s) or hardware&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Physical Design&lt;/b&gt; (Lecture 04)
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the actual implementation of the logical data model&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In this lecture we turn or focus onto the &lt;b&gt;logical design&lt;/b&gt;
&lt;/p&gt;

&lt;div id="outline-container-orgd4e09a4" class="outline-2"&gt;
&lt;h2 id="orgd4e09a4"&gt;Logical Data Model&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd4e09a4"&gt;
&lt;p&gt;
Which &lt;i&gt;data model&lt;/i&gt; is appropiate for the &lt;i&gt;logical design process&lt;/i&gt;? The &lt;b&gt;relational data model&lt;/b&gt; because it has a simple structure, an elegant theoretical foundation (formal description) and is economically relevant (about ~80% of database systems are based on the relational paradigm despite development/creation of alternatives).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfceda2c" class="outline-3"&gt;
&lt;h3 id="orgfceda2c"&gt;Relational Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfceda2c"&gt;
&lt;p&gt;
The relational model (RM) was introduced in a paper by E.F. Codd in 1970, which pertains as a milestone to this day. The most know prototype of this theoretical approach was created by IBM in 1975 (System R). The in the process developed query language SEQUEL was later standardized as SQL and is the most common query language for relational DBMS today.
&lt;/p&gt;

&lt;p&gt;
The first commercial systems were released at the end of the 70s for example Orcale (by Orcale Corporation) or DB2 (by IBM). Today there are hundreds of DBMS that are based on the relational data model.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgec60c46" class="outline-3"&gt;
&lt;h3 id="orgec60c46"&gt;Relational Model - Terms and Definitions&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgec60c46"&gt;
&lt;p&gt;
The relational model is based on the mathematical concept of a (finitary?) relation, which can be represented well as a table consisting of &lt;i&gt;rows&lt;/i&gt; and &lt;i&gt;columns&lt;/i&gt;.
&lt;b&gt;Rows&lt;/b&gt; represent &lt;b&gt;different attributes&lt;/b&gt; of &lt;b&gt;one entity&lt;/b&gt;. &lt;b&gt;Columns&lt;/b&gt; represent the &lt;b&gt;same attribute&lt;/b&gt; of &lt;b&gt;all entities&lt;/b&gt;. An attribute corresponds with the attribute idea in the Entity Relationship Model (conceptual design) and is a property/characteristic of an entity.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;domain&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;describes the domain(Wertebereich, aber Wertebereich ist eig codomain und definitionsmenge ist domain..) of an attribute&lt;/li&gt;
&lt;li&gt;this domain has to be &lt;b&gt;atomic&lt;/b&gt; → cannot hold nested structures and/or sets&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;relation&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation R is a subset of the cartesian product of \(n\) domains \(D_i\):&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
\( R \subseteq D_1 * D_2 ... * D_i ... D_n \)
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;tuple&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;an element (row) of a relation is called "tuple"&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;degree&lt;/b&gt; (Grad) 
&lt;ul class="org-ul"&gt;
&lt;li&gt;the degree of a relation R describes the amount of attributes resp involved domains&lt;/li&gt;
&lt;li&gt;symbol: degree(R) / Grad(R)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;cardinality&lt;/b&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the cardinality of a relation R describes the amount of tuples (rows/elements) in R&lt;/li&gt;
&lt;li&gt;symbol: |R|&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/rel-model-example.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3456940" class="outline-3"&gt;
&lt;h3 id="org3456940"&gt;Relations and Schemas&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3456940"&gt;
&lt;p&gt;
&lt;b&gt;database context&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the mathematical definition of a relation just describes a set of tuples&lt;/li&gt;
&lt;li&gt;an attribute results from the position of the attribute domain when forming the product (Produktbildung)&lt;/li&gt;
&lt;li&gt;since database context attributes shall be comfortably identifiable via their name, we need an additional compononent to describe the relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;relation schema&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;includes the specification of the domains and sets of all domain names/identifiers (attributes) which are uniquely to a relation (umfasst die Spezifikation der Domänen und die Menge aller - innerhalb einer Relation eindeutigen - Domänenbezeichnungen (Attribute))&lt;/li&gt;
&lt;li&gt;describes the creation procedure (Bildungsvorschrift/Schablone) for a relation
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation is a set of tuples that is created with the help of this procedure guide&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;databases usually manage multiple tables, therefore multiple relation schemas have to be described - this is done through &lt;b&gt;database schemas&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;when \(A_1, A_2, ..., A_n\) are named attributes with the domains \(D_1, D_2, ..., D_n\) then the set \({A_1:D_1, A_2:D_2, ..., A_n:D_n}\) is the according relation schema&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;relation&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a relation R that is defined by a relation schema S is a set of projection (Menge von Abbildungen) of attribute names onto their corresponding domains
&lt;ul class="org-ul"&gt;
&lt;li&gt;that means R is a set of \(n\) tuples \(A_1:d_1, A_2:d_2, ..., A_n:d_n\) with \(d_1 \in D_1, d_2 \in D_2, ..., d_n \in D_n\)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;eg: Buch \(\subseteq\) string(isbn) x string(titel) x decimal(preis)&lt;/li&gt;
&lt;li&gt;in the common use of language the terms "relation" and "relation schema" are often used interchangebly
&lt;ul class="org-ul"&gt;
&lt;li&gt;so the term "relation" may refer to the relation schema, the manifestation (Ausprägung) of a schema or both&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;however it is important to keep both aspects in mind: &lt;b&gt;a relation underlies (unterliegt) a schema and is itself an instance (Ausprägung) of that schema&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;one of Codds requirements was that domains are atomic → the term &lt;b&gt;normalized relation&lt;/b&gt; clarifies this demand and usually "relation" is meant as "normalized relation"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;database schema&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;when \(R_1, R_2, ..., R_n\) are differently named relation schemas then the set \(R = {R_1, R_2, ..., R_n}\) represents the relation database schema R&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5b3bc8d" class="outline-3"&gt;
&lt;h3 id="org5b3bc8d"&gt;Relations and Tables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5b3bc8d"&gt;
&lt;p&gt;
Tables are physical representation forms of relation with some differences:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;finiteness&lt;/b&gt; (Endlichkeit)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables are finite (because of limited ressources)&lt;/li&gt;
&lt;li&gt;relations can be infinite (as long as at least one domain is finite)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;order&lt;/b&gt; (Sortierung)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables are always sorted (even when the sorting criteria is not immediately obvious)&lt;/li&gt;
&lt;li&gt;in case of relations only the existence of a tuple is relevant, for existing tuples is doesnt matter at which position they are&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;duplications&lt;/b&gt; (Duplikate)
&lt;ul class="org-ul"&gt;
&lt;li&gt;tables may hold entries multiple times / duplicates&lt;/li&gt;
&lt;li&gt;all tuples of a relation are pairwise distinct&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7a1b9f6" class="outline-3"&gt;
&lt;h3 id="org7a1b9f6"&gt;Alternative Terms&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7a1b9f6"&gt;
&lt;p&gt;
Especially when using a concrete DBMS alternative terms than those of the relation model are used that are closer to the physical representation (I also added those somewhere above by myself b4 reading this because it felt more natural :D ):
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a "relation" is often called a "table" or a "file"&lt;/li&gt;
&lt;li&gt;a "tuple" is often called a "row" or "data record"&lt;/li&gt;
&lt;li&gt;an "attribute" is often called a "column" or "field"&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge0e4ba8" class="outline-3"&gt;
&lt;h3 id="orge0e4ba8"&gt;Relational Keys&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge0e4ba8"&gt;
&lt;p&gt;
&lt;b&gt;superkeys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a superkey represents a set of attributes which allows to differentiate all tuples of a relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;candidate keys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a canidate key is a superkey who'se attribute set is minimal → that means no subset of his attributes allows the unique identification of all tuples of a relation (so viel attribute wie nötig um eindeutig zu unterscheiden/identifizieren und mit weniger attributen nicht möglich)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;primary keys&lt;/b&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;a primary key is a canidate which is used primarily to distingiush tuples of a relation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/relational-keys.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0470387" class="outline-3"&gt;
&lt;h3 id="org0470387"&gt;Relational Model - Relationships&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0470387"&gt;
&lt;p&gt;
Relations can be associated with each other. To achieve that primary key attributes of the relation which should be associated is added to the relation which realizes that relationship. The primary key which was added to a relation for this purpose is called &lt;b&gt;foreign key&lt;/b&gt;. Therefore &lt;i&gt;every foreign key has to be a primary key somewhere in a relation&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="https://schoettkr.github.io/knowledge-database/images/relationship-rm.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgacd83c0" class="outline-3"&gt;
&lt;h3 id="orgacd83c0"&gt;Null Values&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgacd83c0"&gt;
&lt;p&gt;
For some tuples of a relation the concrete value of an attribute may not be known (yet) or it may be inappropiate to have an value existing there. To represent such cases the &lt;b&gt;null value&lt;/b&gt; (null) exists which is a "non-value" alas "unknown value" (which shall not be confused with the value 0).
&lt;/p&gt;

&lt;p&gt;
Null values have to be treated differently than the usual attribute values. There's an trivalent (dreiwertig) logic to deal with them (more on that later).
&lt;/p&gt;

&lt;p&gt;
It should be a goal to minimize the cases where null values are needed although this is often not possible to realize. An excessive use should be avoided, this is especially true when representing relationships.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2f31216" class="outline-2"&gt;
&lt;h2 id="org2f31216"&gt;Logical Design: ERM to RM&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2f31216"&gt;
&lt;p&gt;
The task at hand is to translate the conceptual data model (ERM, entity relationship model) from the conceptual design phase into the logical data model (RM, relational model).
&lt;/p&gt;

&lt;p&gt;
The steps required are:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;derive the relations from the attributes, entity types and relationship types of the ERM (ERM to RM)&lt;/li&gt;
&lt;li&gt;normalization of relations&lt;/li&gt;
&lt;li&gt;validation of relations in regards to user transactions&lt;/li&gt;
&lt;li&gt;verification of integrity conditions (Integritätsbeziehungen)&lt;/li&gt;
&lt;li&gt;consultation (Rücksprache) with users&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b8d34a" class="outline-3"&gt;
&lt;h3 id="org9b8d34a"&gt;ERM to RM&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9b8d34a"&gt;
&lt;p&gt;
F 20
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://schoettkr.github.io/knowledge-database/posts/database_essentials/db-essentials-03/</guid><pubDate>Tue, 23 Oct 2018 22:00:00 GMT</pubDate></item></channel></rss>