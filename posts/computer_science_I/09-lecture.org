#+BEGIN_COMMENT
.. title: Computer Science I - Lecture 09
.. slug: cs-I-09
.. date: 2018-12-07
.. tags: 
.. category: university cs01
.. link: 
.. description: 
.. type: text
.. has_math: true
#+END_COMMENT

This post will be rather short (the CS posts usually are shorter anyway) because I already covered some of the stuff in the last post by accident because I wasn't able to attend the lecture and overestimated our progress.

* Development Cycle
Typically you don't hear the task/problem and start writing code immediately. Because usually real world problems are not trivial. Here's an outline of how things should/may go:

*Specification* (input = task/problem; resolve conflicts & misunderstandings; output = functional requirements) \rightarrow *Design* (Entwurf; input = functional requirements; output = design) \rightarrow *Implementation* (input = design output = source code) \rightarrow *Compilation* (input = source code; possibly throw errors; output = executable)

All the above steps stand in correlation to each other meaning the arrows could go in both directions because you often have to go back to a previous step before continuing.

The rest of the lecture was about how we can *specify* and *design*. It covered pseudocode, structograms, PAP and so on... I cba to repeat this stuff here. If you want to take a look feel free to do so in the slides from page 60 till 64.

Next week we'll probably cover the next step  of *"Implementation"* which may or may not be more interesting as the others at this high level view..
