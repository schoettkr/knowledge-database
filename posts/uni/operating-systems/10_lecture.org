#+TITLE: Operating Systems - Coordination Problems
#+DATE: 2019-06-05 10:00
#+HUGO_TAGS: uni os
#+HUGO_BASE_DIR: ../../../
#+HUGO_SECTION: uni/os
#+HUGO_DRAFT: false
#+HUGO_AUTO_SET_LASTMOD: true

Coordination mechanisms and techniques can solve a lot of problems like guaranteeing data consistency when cooperating (guarding critical sections), managing exclusive ressource access etc. However new problems may occur when employing coordination mechanisms:
- priority inversion
- starving (verhungern)
- deadlock (verklemmen)
  
** Priority Inversion
In the case of priority based scheduling a process with higher priority may be blocked by a process with lower priority, for example:
- low-prio process $P_L$ enters a critical section
- high-prio process $P_H$ gets ready to execute and tries the same
- $P_H$ is blocked
  
Now if a process with medium priority $P_M$ suspenses the low-prio process $P_L$ the blocking/stopping of $P_H$ may continue.
- multiple medium-prio processes may take over each other (abloesen)

This is known as unlimited priority inversion and leads to performance problems.

** Deadlock vs Starvation
*Deadlock*
- no process participates in the scheduling process
- static situation
- no forward resolution (Vorwaertsaufloesung)
- no (inner) progress: processes don't move forward
  
*Starvation*
- processes continue to participate in the scheduling process
- dynamic situation
- forward resolution is possible
- no (outer) progress: process doesn't move beyond a certain point
  
The problem of starvation can be solved by breaking the dynamic symmetry by eg randomization. We focus on (dead)locks for now.

** Deadlock
A *deadlock* is a situation in which none of the involved processes can continue to execute, e.g:\\
[[/knowledge-database/images/deadlock-example.png]]

An illustrative example of this is that of the dining philosophers (Dijkstra): 5 philosophers sit in an italian restaurant, eat spaghetti and think. They have 5 forks and to eat one needs 2 forks. If everyone takes one fork all 5 forks are in one hand each and nobody can eat and they will wait forever \rightarrow deadlock.

In context of operating systems resources the following criteria (/Coffman Conditions/) are needed for a deadlock:
- resource(s) is/are used exclusively
- processes already hold/occupy some resource while waiting for another resource
- suspension doesn't happen
  
Now if in this situation the following happens, the last coffman condition for a deadlock is met:
- there are cyclic (waiting) dependencies
  
Note: Condition 1-3 are system design dependant, while condition 4 is something that may arise during run time.

*** Deadlock Countermeasures
- prevention (Vorbeugung)
- detection (Entdeckung)
- avoidance (Vermeidung, Verhinderung)
- resolution, recovery (Aufloesung)

  
**** Deadlock Prevention
- prevention = preventive procedure where the resource distribution is realized in a way where deadlocks cannot occur
- *preclaiming* (Summenbelegung): all ever needed ressources are requested upfront

[[/knowledge-database/images/preclaiming.png]]

Preclaiming implicates total release of all resources (Totalfreigabe) at/before every (re-)occupation (Neubelegung) or resource request. This perforates the Coffman condition "hold & wait". This is how things would go in case of the dining philosophers:\\
[[/knowledge-database/images/total-release.png]]\\
\rightarrow Deadlock won't occur, but cycles without progress may occur \rightarrow starvation (livelock)

Another countermeasures to prevent deadlocks is ordered allocation of resources which means access to resources is sorted and resources may only be requested in this order. This breaks the cyclicality from Coffman Condition 4\\
[[/knowledge-database/images/ordered-allocation.png]]\\

All in all preventing measures only work in certain conditions and are rather impractical in real life scenarios, that's why they are used rarely.

**** Deadlock Detection
If a deadlock cannot be prevented per se, it is advantageous to detect the occurance of a deadlock. We'll look at deadlock detection algorithms.\\
Informally: There's an order in which all process can come to an end \rightarrow no deadlock

A detection algorithm has to account for /all/ processes and cann be called..
- at each occupation / resource request / allocation
- periodically
- in the system idle process (Leerlaufprozess)
- when suspicious (manually)
  
F 19
