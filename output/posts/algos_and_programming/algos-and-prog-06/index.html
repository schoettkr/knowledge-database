<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Algos &amp; Programming - Lecture 06 | Knowledge Database</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://example.com/posts/algos_and_programming/algos-and-prog-06/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="schoettkr">
<meta property="og:site_name" content="Knowledge Database">
<meta property="og:title" content="Algos &amp; Programming - Lecture 06">
<meta property="og:url" content="https://example.com/posts/algos_and_programming/algos-and-prog-06/">
<meta property="og:description" content="Storage and memory


Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:


">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-10-26T00:00:00+02:00">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://example.com/" title="Knowledge Database" rel="home">
                Knowledge Database
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../../archive.html">Archive</a></li>
                <li><a href="../../../categories/">Tags</a></li>
                <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Algos &amp; Programming - Lecture 06
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-10-26T00:00:00+02:00">2018/10/26</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgc43f3c6" class="outline-2">
<h2 id="orgc43f3c6">Storage and memory</h2>
<div class="outline-text-2" id="text-orgc43f3c6">
<p>
Up until now our C programs followed the function model (stateless). Storing data is however required to realise the state model. To store data there are basically two options:
</p>
<ul class="org-ul">
<li>storing in the file system (good for big data sets but slow)</li>
<li>storing in memory (faster but limited in some aspects as well)</li>
</ul>
<p>
We continue with the latter option (ᵔᴥᵔ).
</p>

<p>
C is theoretically able to write to and acces every place in memory. Due to the implied dangers of this, most operating systems prevent this to some degree. There are three fundamental methods to reserve (<b>allocate</b>) memory:
</p>
<ul class="org-ul">
<li>(implicit) "named" memory allocation at compile time</li>
<li>"anonymous" memory allocation at run time</li>
<li>parameters which allocate storage at run rime as well</li>
</ul>
<p>
The terms "named" and "anonymous" are taken from the lecture script, I don't like them and think they're confusing. As I understand it the first method refers to the memory allocation that happens when you have e.g <code>int num = 5;</code> in your code and the compiler allocates/reserves at least 16 bits (2 bytes), while the second method refers to dynamic memory allocation via <code>malloc()</code> and <code>calloc()</code>. I'm not entirely sure if this is what the professor means xD. 
</p>
</div>

<div id="outline-container-orga456659" class="outline-3">
<h3 id="orga456659">Variables</h3>
<div class="outline-text-3" id="text-orga456659">
<p>
Should the value of a place in memory be modified (purpose of the state model), you speak of (named or anonymous) <i>variables</i>. Should the value in memory stay unchanged, then it is a <i>constant</i>.
</p>
</div>
<div id="outline-container-org2e6fdfa" class="outline-4">
<h4 id="org2e6fdfa">Named variables</h4>
<div class="outline-text-4" id="text-org2e6fdfa">
<p>
Named variables in C have to be declared (analogus to functions). The declarations has to contain the type of the variable as well as the name. It is possible to declare multiple variables of the same type together ala <code>int x, y ,z;</code>.
</p>

<p>
When declaring a variable it is possible to also provide a <i>storage class</i> and/or a <i>type qualifier</i>. The storage class is declared via one of the following keywors <code>auto</code>, <code>static</code>, <code>extern</code> or <code>register</code>. These basically impact the <i>scope</i>, <i>visibility</i> and the <i>life time</i> of the specific variable.
</p>
<ul class="org-ul">
<li>
<code>auto</code> (assumed by default if no other storage class is specified)
<ul class="org-ul">
<li>not often written because it is the default</li>
<li>
<code>auto</code> variables can only be accessed within the block of declaration which defines their scope</li>
<li>however they can be accessed outside their scope by using pointers</li>
<li>get a garbage value assigned whenever they are declared (without initilization)</li>
</ul>
</li>
<li>
<code>static</code>
<ul class="org-ul">
<li>
<code>static</code> variables preserve their (last) value even after they are out of scope</li>
<li>therefore <i>only initialized once</i> and exist until program termination, thus no new memory is allocated because they are not redeclared</li>
<li>their scope is local to the function in which they were defined, global static variables can be accesed anywhere</li>
<li>are assigned <code>0</code> by default from the compiler</li>
</ul>
</li>
<li>
<code>register</code>
<ul class="org-ul">
<li>same functionality as auto variables with the difference that the compiler tries to store these variables in the register of the microprocessor, which makes access much faster than that of the variables stored in memory</li>
<li>if no free register is available the variable is stored in memory</li>
<li>address of register variables is not retrievable using pointers</li>
</ul>
</li>
</ul>
<p>
Type qualifiers are declared via the keywords <code>const</code>, <code>volatile</code> or <code>restrict</code> and give hints to the compiler about the usage of the variables.
</p>

<p>
Variables declared outside of any function are <i>global variables</i>, while variables declared in blocks (<code>{..}</code>) are <i>local variables</i>. Only with the exception of variables with a storage class of <code>extern</code>, variables are also <i>defined</i> when they are <i>declared</i> that means that memory for the varibale is automatically allocated in memory (dont mix this with initializing and/or assigning) without the programmer having to do anything.
</p>

<p>
When the variable has a storage class of <code>extern</code> it is <b>only declared</b> but not defined and therefore has to be <i>globally defined</i> (in a different module).
</p>

<p>
A variable can be assigned a value via <code>0</code>, this can also be done when declaring a variable → <b>initilization</b>.
</p>
</div>

<ul class="org-ul">
<li>
<a id="org6265d7a"></a>Addresses<br><div class="outline-text-5" id="text-org6265d7a">
<p>
Every variable has an address (place in memory where it is stored) that can be retrieved with the <code>&amp;</code> "address of" operator
</p>
<div class="highlight"><pre><span></span> <span class="cm">/* addr .c -- address of a variable */</span>
<span class="k">extern</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">testVar</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">" Variable var has the address %p and the value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">testVar</span> <span class="p">,</span><span class="n">testVar</span> <span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>

<pre class="example">
Variable var has the address 0x7ffc5d3f3694 and the value 42

</pre>

<p>
Actually the identifier of a variable (eg <code>testVar</code>) is just a synonym of the address.
</p>

<p>
<img src="../../../images/identifier-memory.png" alt="nil"></p>
</div>
</li>

<li>
<a id="orga88de6b"></a>Pointer<br><div class="outline-text-5" id="text-orga88de6b">
<p>
Variables can also hold addresses themselves! The prefix <code>*</code> infront of the identifier of a variable makes it a pointer variable. It is essential for the compiler of what this address is built, therefore a pointer is always pointing to another <b>specific</b> type. For instance:
</p>
<ul class="org-ul">
<li>
<code>int *p</code> → pointer that is pointing to an integer type</li>
<li>
<code>float *p</code> → pointer that is pointing to a float type</li>
<li>
<code>unsigned int *p</code> → pointer that is pointing to an unsigned integer type</li>
</ul>
<p>
If a generic memory address without a specific type shall be used then the base type <code>void</code> is used:
</p>
<ul class="org-ul">
<li>
<code>void *p</code> pointer that is pointing to an address</li>
<li>assigning void pointers is compatible to/with all other pointer types (→ no warnings!)</li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/* addr2 .c -- pointer to a variable */</span>
<span class="k">extern</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">,</span> <span class="o">*</span> <span class="n">pvar</span> <span class="p">;</span>
  <span class="n">pvar</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">var</span> <span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">" Variable var has the address %p and the value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pvar</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Variable pvar has the address %p and the value %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvar</span> <span class="p">,</span> <span class="n">pvar</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"The value that the pointer stored in pvar points to is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">pvar</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre class="example">
Variable var has the address 0x7ffd08a3f97c and the value 42
Variable pvar has the address 0x7ffd08a3f980 and the value 0x7ffd08a3f97c
The value that the pointer stored in pvar points to is 42

</pre>

<p>
Example memory representation of the above code (addresses will differ):
<img src="../../../images/pointer-memory-representation.png" alt="nil"></p>


<p>
A type and its derived type (eg <code>int</code> and <code>int *</code>) are <i>different</i> types.
</p>

<p>
As seen in the code example above a pointer can be <b>dereferenced</b> via the dereference operator <code>*</code>
</p>
<div class="highlight"><pre><span></span><span class="cm">/* deref .c -- deref a pointer */</span>
<span class="k">extern</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">23</span> <span class="p">,</span> <span class="o">*</span><span class="n">py</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"y=%d (at %p)</span><span class="se">\n</span><span class="s">"</span> <span class="p">,</span><span class="o">*</span><span class="n">py</span><span class="p">,</span> <span class="n">py</span> <span class="p">);</span> <span class="cm">/* same effect as printf ("y=%d\n" ,y); */</span>
  <span class="o">*</span><span class="n">py</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="cm">/* same effect as y=42 */</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"y=%d (at %p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre class="example">
y=23 (at 0x7ffeeff30f1c)
y=42 (at 0x7ffeeff30f1c)

</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgea0a277" class="outline-4">
<h4 id="orgea0a277">Anonymous variables</h4>
<div class="outline-text-4" id="text-orgea0a277">
<p>
Anonymous variables in C don't have a name but get memory allocated nevertheless. They are created at <i>run time</i> with functions from the C standard library. Anonymous variables are <b>not declared</b>.
</p>

<p>
More specifically the following functions that are <i>declared</i> in <code>stdlib.h</code> are used to allocate memory at run time:
</p>
<ul class="org-ul">
<li>
<code>void *malloc(size_t size)</code> → reserves <code>size</code> bytes in memory</li>
<li>
<code>void *calloc(size_t count, size_t size)</code> → reserves <code>count x size</code> bytes in memory and initializes them with a value of <code>0</code>
</li>
</ul>
<p>
Both functions retrun the <b>address</b> of the anonymous variable.
</p>

<p>
To find out how much size/space is needed, C's <code>sizeof</code> operator comes in handy because the size of eg an <code>int</code> is not the same on all systems. It can be used on variables as well as on types and <code>sizeof(int)</code> return for example <code>4</code>.
</p>

<p>
The programmer has (in contrast to named variables) manage the scope and lifecycle of anonymous variables. To release the memory that was allocated for an anonymous variable <code>void free(void*)</code> is used which takes the address of the anonymous variable.
To be able to do this you of course need the address of the anonymous variable and that is (amongst other reasons) why you should store it somewhere!
</p>

<div class="highlight"><pre><span></span><span class="cm">/* malloc .c -- anonymous variables */</span>
<span class="k">extern</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// declare pointer to int</span>

  <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// allocate memory for an int and store the returned address of the allocated memory location and store it in p</span>

  <span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="mi">42</span> <span class="p">;</span> <span class="c1">// dereference p and store the value 42</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">" Pointer p has address %p and points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">p</span> <span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">" Anonymous variable has the value %d which is stored in %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* pass address and release memory */</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<pre class="example">
Pointer p has address 0x7fff1376cea0 and points to 0x55ffde405260
Anonymous variable has the value 42 which is stored in 0x55ffde405260

</pre>

<p>
In the example above you can see that the variable is anonymous because the value <code>42</code> is nowhere stored directly in a named variable but is retrieved by dereferencing the pointer that points to the memory location where <code>42</code> is stored (<code>*p</code>).
</p>

<p>
Not releasing allocated memory can lead to so called <i>memory leaks</i> and is a frequent error cause. Another frequent error is trying to use anonymous variables that are already released (<i>dangling pointer</i>).
</p>

<p>
Helping advice to avoid the above errors:
</p>
<ul class="org-ul">
<li>when you allocate memory with eg <code>malloc</code> immediately write the code to free the memory as well</li>
<li>when releasing/freeing an anonymous variable assign it the (symbolic) value <code>NULL</code> which is defined in <code>stdlib.h</code>
<ul class="org-ul">
<li>it is guaranteed that there is never another variable at a location that is described by <code>NULL</code>
</li>
<li>dereferencing <code>NULL</code> leads to a run time error</li>
<li>if functions like <code>malloc</code> fail they also return <code>NULL</code> therefore it is advised to check pointers against <code>null</code> before using them</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org290f852" class="outline-4">
<h4 id="org290f852">Parameters</h4>
</div>
</div>
</div>
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2018         <a href="mailto:schoettkr@gmail.com">schoettkr</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
